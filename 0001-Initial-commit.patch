From 69a6f1dbba683148eadc48f542a05b4dd1ccc5cc Mon Sep 17 00:00:00 2001
From: Bob Stobie <stobib@bsnepc.us>
Date: Tue, 17 Sep 2019 08:11:28 -0500
Subject: [PATCH] Initial commit

---
 PowerShell/APPS/GPO/RemoteAccess.ps1          |   37 +
 PowerShell/APPS/Splunk/UniversalForwarder.ps1 |  137 +
 PowerShell/Configure ADDS.ps1                 |   24 +
 PowerShell/ConfigureWSUS.txt                  |    1 +
 PowerShell/CopyData.ps1                       |  277 ++
 ...Create Users  Usergroups and OUs in AD.ps1 |  185 ++
 .../Create system management container.ps1    |   22 +
 PowerShell/General/6to4.ps1                   |    2 +
 PowerShell/General/CheckComputerStatus.ps1    |  302 ++
 .../General/CheckComputerStatus_2018-0408.ps1 |  224 ++
 PowerShell/General/CopyData.ps1               |  306 ++
 PowerShell/General/EncryptPWD.ps1             |  169 +
 PowerShell/General/Export-ADComputers.ps1     | 1116 +++++++
 .../Initialize-PowerCLIEnvironment.ps1        |  295 ++
 PowerShell/General/MapNetworkDrives.ps1       |  224 ++
 PowerShell/General/PrintServiceStatus.ps1     |  112 +
 PowerShell/General/PrivilegedUsers.ps1        |   10 +
 PowerShell/General/RenHostName.ps1            |  600 ++++
 PowerShell/General/RepairWMI.ps1              |  183 ++
 PowerShell/General/RepairWMI_failed.ps1       |  220 ++
 .../General/Reset-LocalAdminPassword.ps1      |   94 +
 PowerShell/General/ResetFailedVM.ps1          |  421 +++
 PowerShell/General/RunningProcess-Test.ps1    |   33 +
 PowerShell/General/Set-UserStatus.ps1         |   19 +
 PowerShell/General/Test.ps1                   |  366 +++
 PowerShell/General/UTA-sftpadmingrp.ps1       |    1 +
 PowerShell/General/VerifyDNS-old.ps1          |  264 ++
 PowerShell/General/VerifyDNS.ps1              |  296 ++
 PowerShell/General/VerifyHash.ps1             |   36 +
 PowerShell/General/WinEvents-Test.ps1         |    2 +
 PowerShell/General/ping_cmcs.ps1              |  130 +
 ...all SCCM Current Branch latest version.ps1 |  144 +
 PowerShell/Install SQL Server 2016.ps1        |  161 +
 PowerShell/JoinDomain.ps1                     |   10 +
 PowerShell/Linux-Rename.ps1                   |   68 +
 PowerShell/Modules/ProcessCredentials.psm1    |  173 +
 PowerShell/ReinstallSccmClient.ps1            |    8 +
 PowerShell/RepairWMI.ps1                      |   54 +
 .../ClientHealthMonitor.ps1                   |  307 ++
 .../ConfigMgrClientHealth.ps1                 | 2917 +++++++++++++++++
 ...gr_Daily_Servers_Health_Check_Reports.html |  705 ++++
 .../MostAmazingSCCMReport.sql                 |  130 +
 .../Remove-WMIInvalidContent.ps1              |   86 +
 .../Repair_User_Profile.ps1                   |  112 +
 PowerShell/SCCM_Client_Health/config.xml      |   46 +
 PowerShell/TestingSSH.ps1                     |  105 +
 PowerShell/delegate permissions.ps1           |   28 +
 PowerShell/install roles and features.ps1     |   26 +
 .../install roles and features_WSUS.ps1       |   35 +
 PowerShell/setup ADK and WDS.ps1              |   64 +
 backup/MapNetworkDrives.ps1                   |  222 ++
 backup/PowerCLI_Examples.txt                  |   82 +
 backup/ResetFailedVM.ps1                      |  622 ++++
 backup/ResetFailedVM_bk0.ps1                  |  339 ++
 backup/ResetFailedVM_bk1.ps1                  |  489 +++
 55 files changed, 13041 insertions(+)
 create mode 100644 PowerShell/APPS/GPO/RemoteAccess.ps1
 create mode 100644 PowerShell/APPS/Splunk/UniversalForwarder.ps1
 create mode 100644 PowerShell/Configure ADDS.ps1
 create mode 100644 PowerShell/ConfigureWSUS.txt
 create mode 100644 PowerShell/CopyData.ps1
 create mode 100644 PowerShell/Create Users  Usergroups and OUs in AD.ps1
 create mode 100644 PowerShell/Create system management container.ps1
 create mode 100644 PowerShell/General/6to4.ps1
 create mode 100644 PowerShell/General/CheckComputerStatus.ps1
 create mode 100644 PowerShell/General/CheckComputerStatus_2018-0408.ps1
 create mode 100644 PowerShell/General/CopyData.ps1
 create mode 100644 PowerShell/General/EncryptPWD.ps1
 create mode 100644 PowerShell/General/Export-ADComputers.ps1
 create mode 100644 PowerShell/General/Initialize-PowerCLIEnvironment.ps1
 create mode 100644 PowerShell/General/MapNetworkDrives.ps1
 create mode 100644 PowerShell/General/PrintServiceStatus.ps1
 create mode 100644 PowerShell/General/PrivilegedUsers.ps1
 create mode 100644 PowerShell/General/RenHostName.ps1
 create mode 100644 PowerShell/General/RepairWMI.ps1
 create mode 100644 PowerShell/General/RepairWMI_failed.ps1
 create mode 100644 PowerShell/General/Reset-LocalAdminPassword.ps1
 create mode 100644 PowerShell/General/ResetFailedVM.ps1
 create mode 100644 PowerShell/General/RunningProcess-Test.ps1
 create mode 100644 PowerShell/General/Set-UserStatus.ps1
 create mode 100644 PowerShell/General/Test.ps1
 create mode 100644 PowerShell/General/UTA-sftpadmingrp.ps1
 create mode 100644 PowerShell/General/VerifyDNS-old.ps1
 create mode 100644 PowerShell/General/VerifyDNS.ps1
 create mode 100644 PowerShell/General/VerifyHash.ps1
 create mode 100644 PowerShell/General/WinEvents-Test.ps1
 create mode 100644 PowerShell/General/ping_cmcs.ps1
 create mode 100644 PowerShell/Install SCCM Current Branch latest version.ps1
 create mode 100644 PowerShell/Install SQL Server 2016.ps1
 create mode 100644 PowerShell/JoinDomain.ps1
 create mode 100644 PowerShell/Linux-Rename.ps1
 create mode 100644 PowerShell/Modules/ProcessCredentials.psm1
 create mode 100644 PowerShell/ReinstallSccmClient.ps1
 create mode 100644 PowerShell/RepairWMI.ps1
 create mode 100644 PowerShell/SCCM_Client_Health/ClientHealthMonitor.ps1
 create mode 100644 PowerShell/SCCM_Client_Health/ConfigMgrClientHealth.ps1
 create mode 100644 PowerShell/SCCM_Client_Health/Daily_Servers_Health_Check_Reports/ConfigMgr_Daily_Servers_Health_Check_Reports.html
 create mode 100644 PowerShell/SCCM_Client_Health/MostAmazingSCCMReport/MostAmazingSCCMReport.sql
 create mode 100644 PowerShell/SCCM_Client_Health/Remove-WMIInvalidContent.ps1
 create mode 100644 PowerShell/SCCM_Client_Health/Repair_User_Profile.ps1
 create mode 100644 PowerShell/SCCM_Client_Health/config.xml
 create mode 100644 PowerShell/TestingSSH.ps1
 create mode 100644 PowerShell/delegate permissions.ps1
 create mode 100644 PowerShell/install roles and features.ps1
 create mode 100644 PowerShell/install roles and features_WSUS.ps1
 create mode 100644 PowerShell/setup ADK and WDS.ps1
 create mode 100644 backup/MapNetworkDrives.ps1
 create mode 100644 backup/PowerCLI_Examples.txt
 create mode 100644 backup/ResetFailedVM.ps1
 create mode 100644 backup/ResetFailedVM_bk0.ps1
 create mode 100644 backup/ResetFailedVM_bk1.ps1

diff --git a/PowerShell/APPS/GPO/RemoteAccess.ps1 b/PowerShell/APPS/GPO/RemoteAccess.ps1
new file mode 100644
index 0000000..cc4e9e9
--- /dev/null
+++ b/PowerShell/APPS/GPO/RemoteAccess.ps1
@@ -0,0 +1,37 @@
+﻿Clear-Host;Clear-History
+#    Temporary static server name for testing purposes
+$ServerName="w16aestack01"
+#    Temporary static server name for testing purposes #>
+Set-Variable -Name DnsDomain -Value $env:USERDNSDOMAIN
+If($DnsDomain-eq""){$DnsDomain="utshare.local"}
+Set-Variable -Name PolicyName -Value $null
+Set-Variable -Name GUID -Value $null
+Set-Variable -Name ReportFormat -Value "xml"
+Set-Variable -Name ExistingGpo -Value $false
+Set-Variable -Name ReportPath -Value "I:\GPO\Report"
+Set-Variable -Name GpoName -Value "serveradmins-$ServerName"
+Set-Variable -Name ReportDate (Get-Date -Format "yyyy-MMdd")
+Set-Variable -Name AdGroupAcct -Value "grpsrvadmin-$ServerName"
+Set-Variable -Name AdGroupPath -Value "OU=Groups,OU=SIS,OU=UTSystem,OU=AllUsers,DC=utshare,DC=local"
+Get-GPO -All -Domain $DnsDomain|Out-File -FilePath "$ReportPath\$ServerName.txt"
+ForEach($PolicyName In Get-Content -Path "$ReportPath\$ServerName.txt"){
+    If($PolicyName-like"DisplayName*"){
+        $PolicyName=$PolicyName.Split(":")[1]
+        If($PolicyName.Trim()-eq$GpoName){
+            $ReportDate="_$ReportDate"
+            $ReportName="$ReportPath\$ServerName$ReportDate.$ReportFormat"
+            Get-GPOReport -Name $GpoName -ReportType $ReportFormat -Path $ReportName
+            $ExistingGpo=$true;Break
+        }
+    }
+}
+If($ExistingGpo-eq$false){
+    New-GPO -Name $GpoName -Comment "This is a test GPO for creating remote access to servers."
+    Set-GPPermission -Name $GpoName -TargetName "Authenticated Users" -TargetType Group -PermissionLevel None -WarningAction SilentlyContinue
+    Set-GPPermission -Name $GpoName -TargetName "$ServerName$" -TargetType Group -PermissionLevel GpoApply
+    Get-ADGroup -Filter "Name -like '*$AdGroupAcct*'" -Properties * -SearchBase $AdGroupPath|Select Name
+    New-ADGroup -Name $AdGroupAcct -SamAccountName $AdGroupAcct -GroupCategory Security -GroupScope Global -Path $AdGroupPath -Description "Server Administrators for $ServerName"
+}
+If(Test-Path -Path "$ReportPath\$ServerName.txt"){
+    Remove-Item -Path "$ReportPath\$ServerName.txt"
+}
diff --git a/PowerShell/APPS/Splunk/UniversalForwarder.ps1 b/PowerShell/APPS/Splunk/UniversalForwarder.ps1
new file mode 100644
index 0000000..4f98a62
--- /dev/null
+++ b/PowerShell/APPS/Splunk/UniversalForwarder.ps1
@@ -0,0 +1,137 @@
+﻿Clear-Host;Clear-History
+Set-Variable -Name ProductName -Value "Splunk"
+Set-Variable -Name AppLogPath -Value "$env:SystemDrive\SCCM-AppLog\$ProductName"
+Set-Variable -Name WorkingDir -Value ("$AppLogPath\temp").ToLower()
+Set-Variable -Name InstDate -Value (Get-Date -Format "yyyy-MMdd")
+Set-Variable -Name AppLog -Value "$AppLogPath\Install-Script_$InstDate.log"
+$DateTime=(Get-Date).ToString()
+Set-Variable -Name Message -Value "$DateTime : Beginning new log for installation of $AppNameList from $ProductName."
+$Message|Out-File -FilePath $AppLog
+Set-Variable -Name ProcessID -Value $null
+Set-Variable -Name ProcessInfo -Value $null
+Set-Variable -Name DnsDomain -Value ("\\$env:USERDNSDOMAIN").ToLower()
+If($DnsDomain-eq"\\"){$DnsDomain="\\utshare.local"}
+$DateTime=(Get-Date).ToString()
+Set-Variable -Name Message -Value "$DateTime : DNS Domain: $DnsDomain."
+$Message|Out-File -FilePath $AppLog -Append
+Set-Variable -Name AppShare -Value "departments\sysadm"
+Set-Variable -Name AppPath -Value "Downloads\SplunkUniversalForwarder"
+Set-Variable -Name DownloadDir -Value "$DnsDomain\$AppShare\$AppPath"
+$DateTime=(Get-Date).ToString()
+Set-Variable -Name Message -Value "$DateTime : Download location: $DownloadDir."
+$Message|Out-File -FilePath $AppLog -Append
+Set-Variable -Name AppNameList -Value "splunkforwarder-7.0.0-x64.msi","splunkforwarder-7.0.3-fa31da744b51-x64-release.msi"
+Set-Variable -Name InstallDir -Value "$env:SystemDrive\Program Files\$ProductName"
+Set-Variable -Name DeploymentServer -Value "splunkdeploya01.inf.utshare.local:8089"
+Set-Variable -Name ReceivingIndexer -Value "10.118.0.19:9998"
+If((Test-Path -Path $AppLogPath)-eq$false){New-Item -Path $AppLogPath -ItemType Directory > $null}
+If((Test-Path -Path $WorkingDir)-eq$false){New-Item -Path $WorkingDir -ItemType Directory > $null}
+$DateTime=(Get-Date).ToString()
+Set-Variable -Name Message -Value "$DateTime : Verifying that $env:Computername has enough free disk space available on the C: drive for processing this installation."
+$Message|Out-File -FilePath $AppLog -Append
+Set-Variable -Name InstOptions -Value "INSTALLDIR=""$InstallDir"" DEPLOYMENT_SERVER=""$DeploymentServer"" RECEIVING_INDEXER=""$ReceivingIndexer"" AGREETOLICENSE=yes"
+Set-Variable -Name FreeDiskSpace -Value (Get-WmiObject Win32_LogicalDisk|Where-Object{$_.DriveType-eq3}|Where-Object{$_.DeviceID-eq"C:"}|Select @{Name="GB";Expression={[math]::round($_.FreeSpace/1GB,2)}}).GB
+Set-Variable -Name TotalSpace -Value (Get-WmiObject Win32_LogicalDisk|Where-Object{$_.DriveType-eq3}|Where-Object{$_.DeviceID-eq"C:"}|Select @{Name="GB";Expression={[math]::round($_.Size/1GB,2)}}).GB
+Set-Variable -Name Percentage -Value ([math]::Truncate(($FreeDiskSpace/$TotalSpace)*100))
+$DateTime=(Get-Date).ToString()
+Set-Variable -Name Message -Value "$DateTime : $env:Computername has $Percentage% free disk space available on drive C:."
+$Message|Out-File -FilePath $AppLog -Append
+If($Percentage-gt1){
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : Verifying registry is clear of previously uninstalled versions of $ProductName."
+    $Message|Out-File -FilePath $AppLog -Append
+    $KeyPath="HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\Folders"
+    Set-Location $KeyPath
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : Processing registry key: [$KeyPath]."
+    $Message|Out-File -FilePath $AppLog -Append
+    Get-ItemProperty -Path .|Out-File $WorkingDir\ReyValues.txt
+    ForEach($CurrentLine In Get-Content "$WorkingDir\ReyValues.txt"){
+        If($CurrentLine-like"*Splunk*"){
+            (($CurrentLine).Split(":")).Trim()|Out-File $WorkingDir\ReyValues-Trim.txt -Append
+        }
+    }
+    If(Test-Path -Path "$WorkingDir\ReyValues-Trim.txt"){
+        ForEach($CurrentLine In Get-Content "$WorkingDir\ReyValues-Trim.txt"){
+            If($CurrentLine-like"*Splunk*"){
+                $SubkeyValue="C:$CurrentLine"
+                $DateTime=(Get-Date).ToString()
+                Set-Variable -Name Message -Value "$DateTime : Deleting registry subkey value: [$SubkeyValue]."
+                $Message|Out-File -FilePath $AppLog -Append
+                Remove-ItemProperty -Path . -Name "$SubkeyValue"
+            }
+        }
+    }
+    If(Test-Path -Path "$WorkingDir\ReyValues-Trim.txt"){Remove-Item "$WorkingDir\ReyValues-Trim.txt"}
+    If(Test-Path -Path "$WorkingDir\ReyValues.txt"){Remove-Item "$WorkingDir\ReyValues.txt"}
+    Set-Location -Path "$WorkingDir"
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : Continuing with the installation script because there is enough free disk space available."
+    $Message|Out-File -FilePath $AppLog -Append
+    $WorkingDir="$WorkingDir\$ProductName"
+    If((Test-Path -Path $WorkingDir)-eq$false){New-Item -Path $WorkingDir -ItemType Directory > $null}
+    Set-Location -Path "$WorkingDir"
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : Installing $AppName in directory [$InstallDir]."
+    $Message|Out-File -FilePath $AppLog -Append
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : The deployment server for this installation is [$DeploymentServer]."
+    $Message|Out-File -FilePath $AppLog -Append
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : The receiving indexer for this installation is [$ReceivingIndexer]."
+    $Message|Out-File -FilePath $AppLog -Append
+    ForEach($AppName In $AppNameList){
+        Copy-Item -Path "$DownloadDir\$AppName" -Destination $WorkingDir
+        If(Test-Path -Path "$WorkingDir\$AppName"){
+            $DateTime=(Get-Date).ToString()
+            Set-Variable -Name Message -Value "$DateTime : Installation process using MSIEXEC for $AppName is beginning."
+            $Message|Out-File -FilePath $AppLog -Append
+            If(Test-Path -Path ("$WorkingDir\$ProductName.log").ToLower()){
+                Remove-Item -Path ("$WorkingDir\$ProductName.log").ToLower()
+            }
+            Start-Process "msiexec.exe" "/i $AppName INSTALLDIR=""$InstallDir"" DEPLOYMENT_SERVER=""$DeploymentServer"" RECEIVING_INDEXER=""$ReceivingIndexer"" AGREETOLICENSE=yes /quiet" -Wait
+            If(Test-Path -Path ("$env:temp\$ProductName.log").ToLower()){
+                ForEach-Object{Get-Content ("$env:temp\$ProductName.log").ToLower()|Out-File -FilePath $AppLog -Append}
+            }
+            $DateTime=(Get-Date).ToString()
+            Set-Variable -Name Message -Value "$DateTime : Installation process using MSIEXEC for $AppName has completed."
+            $Message|Out-File -FilePath $AppLog -Append
+        }Else{
+            $DateTime=(Get-Date).ToString()
+            Set-Variable -Name Message -Value "$DateTime : Failed to copy [$DownloadDir\$AppName] to $WorkingDir."
+            $Message|Out-File -FilePath $AppLog -Append
+        }
+        Start-Sleep -Milliseconds 500
+        $DateTime=(Get-Date).ToString()
+        Set-Variable -Name Message -Value "$DateTime : Continuing script after pausing for 500 ms."
+        $Message|Out-File -FilePath $AppLog -Append
+    }
+}
+Set-Location -Path "$env:windir\System32"
+$DateTime=(Get-Date).ToString()
+Set-Variable -Name Message -Value "$DateTime : Completed processing installation script."
+$Message|Out-File -FilePath $AppLog -Append
+If(Test-Path -Path $WorkingDir){
+    Start-Sleep -Milliseconds 500
+    Remove-Item -Path $WorkingDir -Recurse -Force
+    $DateTime=(Get-Date).ToString()
+    Set-Variable -Name Message -Value "$DateTime : Removed working directory: [$WorkingDir] to cleanup unneeded files."
+    $Message|Out-File -FilePath $AppLog -Append
+}
+$AppShare=$null
+$AppPath=$null
+$DownloadDir=$null
+$AppNameList=$null
+$WorkingDir=$null
+$ProductName=$null
+$AppLogPath=$null
+$AppLog=$null
+$InstallDir=$null
+$InstOptions=$null
+$DeploymentServer=$null
+$ReceivingIndexer=$null
+$FreeDiskSpace=$null
+$TotalSpace=$null
+$Percentage=$null
+$ProcessID=$null
+$ProcessInfo=$null
\ No newline at end of file
diff --git a/PowerShell/Configure ADDS.ps1 b/PowerShell/Configure ADDS.ps1
new file mode 100644
index 0000000..21713cf
--- /dev/null
+++ b/PowerShell/Configure ADDS.ps1	
@@ -0,0 +1,24 @@
+﻿<#
+# Configure ADDS, 2016/12/1 Niall Brady
+# Windows PowerShell script for AD DS Deployment
+#>
+
+$DomainName = "windowsnoob.lab.local"
+$DomainNetbiosName = "WINDOWSNOOB"
+$SafeModeAdministratorPassword = convertto-securestring "P@ssw0rd" -asplaintext -force
+
+Install-windowsfeature -name AD-Domain-Services –IncludeManagementTools
+Import-Module ADDSDeployment
+Install-ADDSForest `
+-CreateDnsDelegation:$false `
+-DatabasePath "C:\Windows\NTDS" `
+-DomainMode "WinThreshold" `
+-DomainName $DomainName `
+-DomainNetbiosName $DomainNetbiosName `
+-ForestMode "WinThreshold" `
+-InstallDns:$true `
+-LogPath "C:\Windows\NTDS" `
+-NoRebootOnCompletion:$false `
+-SysvolPath "C:\Windows\SYSVOL" `
+-SafeModeAdministratorPassword $SafeModeAdministratorPassword `
+-Force:$true
diff --git a/PowerShell/ConfigureWSUS.txt b/PowerShell/ConfigureWSUS.txt
new file mode 100644
index 0000000..67e2fc1
--- /dev/null
+++ b/PowerShell/ConfigureWSUS.txt
@@ -0,0 +1 @@
+wsusUtil.exe postinstall content_dir=e:\wsus sql_instance_name=%computername%\sccm
\ No newline at end of file
diff --git a/PowerShell/CopyData.ps1 b/PowerShell/CopyData.ps1
new file mode 100644
index 0000000..80948f7
--- /dev/null
+++ b/PowerShell/CopyData.ps1
@@ -0,0 +1,277 @@
+﻿Clear-Host;Clear-History
+Set-Location $env:SystemRoot\System32
+$CurrentLocation=Get-Location
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Set-Variable -Name Loops -Value 0
+Set-Variable -Name LoopCount -Value 0
+Clear
+Do{
+    Set-Variable -Name Domain -Value $env:USERDNSDOMAIN.ToLower()
+    Set-Variable -Name SecureUser -Value $env:USERNAME@$Domain
+    Set-Variable -Name WorkingPath -Value "$env:USERProfile\AppData\Local\$Domain\Credentials"
+    Set-Variable -Name SecureFile -Value "$WorkingPath\Encrypted.pwd"
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value 'pwd','key'
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+    }
+	$WorkingPath="$env:USERProfile\AppData\Local\Temp"
+    Set-Variable -Name SrcSrvr -Value "fs8600a01.inf.$Domain"
+    Set-Variable -Name DecSrvr -Value "w16adfs01.inf.$Domain"
+    Set-Variable -Name Options -Value '/XA:RSH'
+    Set-Variable -Name NetDrvs -Value $null
+    Set-Variable -Name LastDrv -Value $null
+    Set-Variable -Name Counter -Value 0
+    Set-Location -Path $WorkingPath
+    $SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    If($SrcSrvr.Substring(1,1)-ne":"){$SrcSrvr="\\$SrcSrvr"}
+    If($DecSrvr.Substring(1,1)-ne":"){$DecSrvr="\\$DecSrvr"}
+    Set-Variable -Name NetDrvs -Value "D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"
+    $DrvLtrs=Get-CimInstance -Class Win32_LogicalDisk
+    Set-Variable -Name MapDrvList -Value $null
+    $IntLoop=0
+    Do{
+        $Counter++
+        $LastDrv=$null
+        Switch($Counter){
+            1{$CurPath=$SrcSrvr;Break}
+            2{$CurPath=$DecSrvr;Break}
+        }
+        If($CurPath.Substring(0,2)-eq"\\"){
+            ForEach($NetDrv In $NetDrvs){
+                If($IntLoop-eq$Counter){Break}
+                If(($LastDrv-eq$null)-or($MapDrvList-eq$NetDrv)){
+                    ForEach($DrvLtr In $DrvLtrs.DeviceID){
+                        $NetID=$NetDrv+':'
+                        If(($DrvLtrs.DeviceID-notcontains"$NetID")-and($MapDrvList-notlike"*$NetDrv*")){
+                            $IntLoop++
+                            Switch($IntLoop){
+                                1{$MapDrvList=$NetDrv;Break}
+                                2{If($MapDrvList-eq$null){
+                                        $MapDrvList=$NetDrv;Break
+                                    }Else{
+                                        $MapDrvList=$MapDrvList+","+$NetDrv;Break
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }Until($Counter-eq2)
+    $Shares="arshared","dashared","sashared","tyshared","projects","iso","Stat-Projects","Stat-Shared"
+    Set-Variable -Name SrcDrv -Value $null
+    Set-Variable -Name DesDrv -Value $null
+    Set-Variable -Name Folders -Value $null
+    $Counter=0
+    ForEach($Share In $Shares){
+        $CurrentSrc="$SrcSrvr\$Share"
+        If($CurrentSrc.Substring(0,2)-eq"\\"){
+            $SrcDrv=$MapDrvList.Substring(0,1)
+            New-PSDrive -Name "$SrcDrv" -Root "$CurrentSrc" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        }
+        $Counter++
+        If($Counter-le5){
+            Switch($Counter){
+                5{
+                    $Share="developers\za"
+                    Break}
+                Default{
+                    $Share="developers\"+$Share.ToString().Substring(0,2)
+                    Break}
+            }
+        }
+        $CurrentDes="$DecSrvr\$Share"
+        If($CurrentDes.Substring(0,2)-eq"\\"){
+            If($MapDrvList.Substring(1,1)-eq","){
+                $DesDrv=$MapDrvList.Substring(2,1)
+            }Else{
+                $DesDrv=$MapDrvList.Substring(0,1)
+            }
+            New-PSDrive -Name "$DesDrv" -Root "$CurrentDes" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        }
+        Robocopy $SrcDrv":\" $DesDrv":\" '*.*' $Options /E /SL /MIR /R:0 /W:0 /XD ".clusterConfig" /XD "DfsrPrivate" /XD ".TemporaryItems" /XD "replica*" /XD "cache"
+        If($SrcDrv-ne$null){Get-PSDrive $SrcDrv|Remove-PSDrive}
+        If($DesDrv-ne$null){Get-PSDrive $DesDrv|Remove-PSDrive}
+    }
+    $CurrentSrc=$DecSrvr+"\sysadm"
+    $CurrentDes=$DecSrvr+"\sysadmins"
+    New-PSDrive -Name "$SrcDrv" -Root "$CurrentSrc" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+    New-PSDrive -Name "$DesDrv" -Root "$CurrentDes" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+    Robocopy $SrcDrv":\" $DesDrv":\" '*.*' $Options /E /SL /MIR /R:0 /W:0 /XD /XD ".clusterConfig" /XD "DfsrPrivate" /XD ".TemporaryItems" /XD "replica*" /XD "cache"
+    If($SrcDrv-ne$null){Get-PSDrive $SrcDrv|Remove-PSDrive}
+    If($DesDrv-ne$null){Get-PSDrive $DesDrv|Remove-PSDrive}
+    $Folders="ar","da","ep","pb","rg","sa","sy","ty"
+    ForEach($Folder In $Folders){
+        $CurrentSrc=$DecSrvr+"\working"
+        $CurrentDes=$DecSrvr+"\users"
+        New-PSDrive -Name "$SrcDrv" -Root "$CurrentSrc" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        New-PSDrive -Name "$DesDrv" -Root "$CurrentDes" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+#        Remove-Item $DesDrv":\"$Folder -Recurse -Force
+        Robocopy $SrcDrv":\"$Folder $DesDrv":\"$Folder '*.*' $Options /E /SL /COPYALL /R:0 /W:0 /XD /XD ".clusterConfig" /XD "DfsrPrivate" /XD ".TemporaryItems" /XD "replica*" /XD "cache"
+        If($SrcDrv-ne$null){Get-PSDrive $SrcDrv|Remove-PSDrive}
+        If($DesDrv-ne$null){Get-PSDrive $DesDrv|Remove-PSDrive}
+    }
+    $LoopCount++
+}While($LoopCount-le$Loops)
+Set-Location -Path $CurrentLocation
diff --git a/PowerShell/Create Users  Usergroups and OUs in AD.ps1 b/PowerShell/Create Users  Usergroups and OUs in AD.ps1
new file mode 100644
index 0000000..b6e77eb
--- /dev/null
+++ b/PowerShell/Create Users  Usergroups and OUs in AD.ps1	
@@ -0,0 +1,185 @@
+﻿<#
+# Creates an OU structure and then adds users and groups to AD 
+# niall brady 2016/12/2
+#>
+
+function ADDOU($OUName, $OUPath) {
+   try {$IsOUInAD=Get-ADOrganizationalUnit -Identity "OU=$OUName,$OUPath" 
+         write-host "The $OUNAme OU was already found in AD."
+        }
+    catch {
+   write-host "About to add the following OU: " -ForegroundColor White -NoNewline 
+   write-host $OUName -ForegroundColor Green -NoNewLine
+   write-host -ForegroundColor White " to this OUPath: " -NoNewLine
+   write-host $OUPath -ForegroundColor Green -NoNewLine
+            New-ADOrganizationalUnit -Name $OUName -Path $OUPath
+            write-host " Done !" -ForegroundColor White}
+}
+
+function ADDUser($User, $DistinguishedName, $SelectedOU) {
+
+
+    try {$IsUsserInAD=Get-ADUser -LDAPFilter "(sAMAccountName=$User)"
+        If ($IsUsserInAD -eq $Null) 
+            {write-host "User $User does not exist in AD, adding..." -NoNewline
+            New-ADUser -Name $User -GivenName $User -SamAccountName $User -UserPrincipalName $User$DistinguishedName -AccountPassword (ConvertTo-SecureString $Password -AsPlainText -Force) -Path $SelectedOU -PassThru | Enable-ADAccount
+            # -ErrorAction Stop -Verbose
+            write-host "Done !" -ForegroundColor Green}
+        Else {
+            write-host "User $User was already found in AD."
+             }
+        }
+        catch{
+   write-host "About to add the following User: " -ForegroundColor White -NoNewline 
+   write-host $User -ForegroundColor Green -NoNewLine
+   write-host -ForegroundColor White " to this DistinguishedName: " -NoNewLine
+   write-host $SelectedOU -ForegroundColor Green
+            }  
+}  
+
+function ADDUserGroup($UserGroup, $SelectedOU) {
+    try {$IsUserGroupInAD=Get-ADGroup -LDAPFilter "(sAMAccountName=$UserGroup)"
+        If ($IsUserGroupInAD -eq $Null) 
+            {write-host "UserGroup $UserGroup does not exist in AD, adding..." -NoNewline
+            New-ADGroup -Name $UserGroup -DisplayName $UserGroup -SamAccountName $UserGroup -GroupCategory Security -GroupScope Global -Path $SelectedOU
+             
+            # -ErrorAction Stop -Verbose
+            write-host "Done !" -ForegroundColor Green}
+        Else {
+            write-host "UserGroup $UserGroup was already found in AD."
+             }
+        }
+        catch{
+            write-host "Error adding UserGroup: " $UserGroup -ForegroundColor Red
+            }  
+}  
+
+clear
+try {
+    Import-Module ActiveDirectory
+    }
+    catch {
+    Write-host "The Active Directory module was not found, try running this on the DC."
+    }
+
+#
+# define your variables below
+#
+$DistinguishedName="DC=windowsnoob,DC=lab,DC=local"
+$OUroot="windowsnoob"
+$OUchild=@("Security Groups","Servers","Service Accounts","Users","Workstations")
+$OUchild2=@("SCCM","MDT","MBAM")
+$Password = "P@ssw0rd"
+# Users
+$YourUserName = "niall"
+$CMUsers = @("CM_BA", "CM_CP", "CM_JD", "CM_NAA", "CM_SR", "CM_TS", "CM_WS")
+$MDTUsers = @("MDT_BA", "MDT_JD")
+$RegularUsers = @("$YourUserName", "testuser1", "testuser2", "testuser3")
+$MBAMUsers = @("MBAM_DB_RO","MBAM_HD_AppPool","MBAM_Reports_Compl")
+# UserGroups
+$MBAMUserGroups = @("MBAM_DB_RW","MBAM_HD", "MBAM_HD_Adv", "MBAM_HD_Report", "MBAM_Reports_RO")
+# the below 4 variables are for adding YourUserName as local admin on the ConfigMgr server, 
+# you must have first configured the following GPO on AD1
+# "Windows Firewall: Allow inbound file and printer sharing exception: Enabled"
+# otherwise disable the lines at the bottom of this script.
+  
+$Computer = "CM01"
+$Group = "Administrators"
+$Domain = "windowsnoob.lab.local"
+
+#
+# add root OU
+#
+
+write-host "Adding the root OU..." -ForegroundColor yellow
+
+$OUName=$OUroot
+$OUPath=$DistinguishedName
+ADDOU $OUName $OUPath
+
+#
+# add 2ndlevel OUs
+#
+
+write-host "Adding child OU's..." -ForegroundColor yellow
+
+$OUName=$OUchild
+$OUPath="OU=windowsnoob, " + $DistinguishedName  
+
+# create an array of OUs to add to AD
+foreach($OU in $OUchild){
+            ADDOU $OU $OUPath
+} 
+
+write-host "Adding more child OU's..." -ForegroundColor yellow
+# add 3rdlevel OUs
+#
+$OUName=$OUchild2
+$OUPath="OU=Service Accounts, OU=windowsnoob, " + $DistinguishedName
+
+# create an array of OUs to add to AD
+foreach($OU in $OUchild2){
+            ADDOU $OU $OUPath
+}  
+
+# add ConfigMgr users
+#
+
+$SelectedOU="OU=SCCM, OU=Service Accounts, OU=windowsnoob, " + $DistinguishedName
+
+write-host "Adding Users to " -ForegroundColor yellow -NoNewline
+write-host $SelectedOU -ForegroundColor green
+foreach($User in $CMUsers){
+ADDUser $User $DistinguishedName $SelectedOU
+                             }
+# add MDT users
+#
+
+$SelectedOU="OU=MDT, OU=Service Accounts, OU=windowsnoob, " + $DistinguishedName
+
+write-host "Adding Users to " -ForegroundColor yellow -NoNewline
+write-host $SelectedOU -ForegroundColor green
+foreach($User in $MDTUsers){
+ADDUser $User $DistinguishedName $SelectedOU
+                             }
+
+# add MBAM users
+#
+
+$SelectedOU="OU=MBAM, OU=Service Accounts, OU=windowsnoob, " + $DistinguishedName
+
+write-host "Adding Users to " -ForegroundColor yellow -NoNewline
+write-host $SelectedOU -ForegroundColor green
+foreach($User in $MBAMUsers){
+ADDUser $User $DistinguishedName $SelectedOU
+                             }
+
+# add Regular users
+#
+
+$SelectedOU="OU=Users, OU=windowsnoob, " + $DistinguishedName
+
+write-host "Adding Users to " -ForegroundColor yellow -NoNewline
+write-host $SelectedOU -ForegroundColor green
+foreach($User in $RegularUsers){
+ADDUser $User $DistinguishedName $SelectedOU
+                           }
+
+
+$SelectedOU="OU=MBAM,OU=Service Accounts,OU=windowsnoob," + $DistinguishedName
+# create an array of usergroups to add to AD
+write-host "Adding UserGroups to " -ForegroundColor yellow -NoNewline
+write-host $SelectedOU -ForegroundColor green
+
+foreach($UserGroup in $MBAMUserGroups){
+ADDUserGroup $UserGroup $SelectedOU
+                             }
+
+# add YourUserName as local admin on ConfigMgr server
+write-host "Adding "  -ForegroundColor yellow -NoNewline
+write-host $YourUserName -ForegroundColor green -NoNewline
+write-host " as a Local administrator on " -ForegroundColor yellow -NoNewline
+write-host $Computer -ForegroundColor green
+([ADSI]"WinNT://$computer/$Group,group").psbase.Invoke("Add",([ADSI]"WinNT://$domain/$YourUserName").path)
+#
+write-host "All done !" -ForegroundColor Yellow
\ No newline at end of file
diff --git a/PowerShell/Create system management container.ps1 b/PowerShell/Create system management container.ps1
new file mode 100644
index 0000000..e159dc4
--- /dev/null
+++ b/PowerShell/Create system management container.ps1	
@@ -0,0 +1,22 @@
+﻿<# modified via a script from https://trevorsullivan.net/2011/05/04/powershell-creating-the-system-management-container/
+#  niall brady 2016/12/5
+#>
+
+# Get the distinguished name of the Active Directory domain
+$DomainDn = ([adsi]"").distinguishedName
+# Build distinguished name path of the System container
+$SystemDn = "CN=System," + $DomainDn
+# Retrieve a reference to the System container using the path we just built
+$SysContainer = [adsi]"LDAP://$SystemDn"
+$SystemManagementContainer = "ad:CN=System Management,CN=System,$DomainDn" 
+
+ If (!(Test-Path $SystemManagementContainer)) { 
+ # Create a new object inside the System container called System Management, of type "container"
+  write-host "Creating System Management container..."
+  $SysMgmtContainer = $SysContainer.Create("Container", "CN=System Management")
+
+# Commit the new object to the Active Directory database
+$SysMgmtContainer.SetInfo()}
+else{
+write-host "System Management container already exists..."}
+write-host "All done."
diff --git a/PowerShell/General/6to4.ps1 b/PowerShell/General/6to4.ps1
new file mode 100644
index 0000000..72bb452
--- /dev/null
+++ b/PowerShell/General/6to4.ps1
@@ -0,0 +1,2 @@
+﻿netsh interface ipv6 set prefix ::/96 60 3
+netsh interface ipv6 set prefix ::ffff:0:0/96 55 4
\ No newline at end of file
diff --git a/PowerShell/General/CheckComputerStatus.ps1 b/PowerShell/General/CheckComputerStatus.ps1
new file mode 100644
index 0000000..b7356bd
--- /dev/null
+++ b/PowerShell/General/CheckComputerStatus.ps1
@@ -0,0 +1,302 @@
+﻿Function CheckConnectivity{param([string]$SearchObject,[string]$SearchValue)
+    Start-Process -FilePath "$env:comspec" -ArgumentList "/c ping $SearchObject -n $PingCount -w 1" -RedirectStandardOutput $PingResults -WindowStyle Hidden -Wait
+    If(Test-Path $PingResults){
+        ForEach($CurrentLine In Get-Content $PingResults){
+            If($CurrentLine-like$SearchValue){
+                Return $true;Break
+            }
+        }Return $false
+    }
+}
+Function DeleteComputer{
+    Write-Host "Attempting to remove '$DNSHostName' from $DomainName."
+    $ADIdentity=@($($Computer.DistinguishedName))
+    Remove-ADComputer -Credential $AuthUser -AuthType Negotiate -Server $DomainController -Identity "$ADIdentity" -Confirm
+}
+Function DisplayMessage{param([string]$Description,[string]$StatusMessage,$FontColor="White",$Background="DarkBlue")
+    [int]$Buffer=$RightAlign-$Description.Length
+    Write-Host @($($Description)) @($($StatusMessage).PadLeft($Buffer)) -ForegroundColor $FontColor -BackgroundColor $Background
+    Return $($Description)
+}
+Function DNSLookup{param([string]$ObjectValue,[string]$SearchValue)
+    Start-Process -FilePath "$env:comspec" -ArgumentList "/c nslookup $ObjectValue" -RedirectStandardOutput $NSLookupData -WindowStyle Hidden -Wait
+    If(Test-Path $NSLookupData){
+        ForEach($CurrentLine In Get-Content $NSLookupData){
+            If($CurrentLine-like$SearchValue){
+                Return $true;Break
+            }
+        }Return $false
+    }
+}
+Function GetTempPassword{Param([int]$Characters=32,[string[]]$SourceData)
+    For($Loop=1;$Loop–le$Characters;$Loop++){
+    $TempPassword+=($SourceData | GET-RANDOM)
+    }
+    Return $TempPassword | ConvertTo-SecureString -AsPlainText -Force
+}
+Function TestCredential{[CmdletBinding()]Param($UserName,$Password,$HostName)
+    if(!($UserName)-or!($Password)){
+        Write-Warning 'TestCredential: Please specify both user name and password'
+    }else{
+        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
+        $DS=New-Object System.DirectoryServices.AccountManagement.PrincipalContext('machine',$HostName)
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password)
+        $UnsecurePassword=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        $DS.ValidateCredentials($UserName,$UnsecurePassword)
+    }
+}
+Function VerifyIPv4Address{
+    Switch(@($($Computer.IPv4Address).Split("."))[2]){
+        {($_-ge4-and$_-le7)-or($_-ge20-and$_-le23)-or($_-ge36-and$_-le39)-or($_-ge52-and$_-le55)-or($_-ge68-and$_-le712)-or($_-ge84-and$_-le87)}{$SubDomain="prd";Break}
+        {($_-eq10)-or($_-eq26)-or($_-eq42)-or($_-eq58)-or($_-eq74)-or($_-eq90)}{$SubDomain="trn";Break}
+        {($_-eq11)-or($_-eq27)-or($_-eq43)-or($_-eq59)-or($_-eq75)-or($_-eq91)}{$SubDomain="sbx";Break}
+        {($_-eq12)-or($_-eq28)-or($_-eq44)-or($_-eq60)-or($_-eq76)-or($_-eq92)}{$SubDomain="tst";Break}
+        {($_-eq13)-or($_-eq29)-or($_-eq45)-or($_-eq61)-or($_-eq77)-or($_-eq93)}{$SubDomain="dev";Break}
+        {($_-eq14)-or($_-eq30)-or($_-eq46)-or($_-eq62)-or($_-eq78)-or($_-eq94)}{$SubDomain="dmo";Break}
+        {($_-eq8)-or($_-eq24)-or($_-eq40)-or($_-eq56)-or($_-eq72)-or($_-eq88)}{$SubDomain="uat";Break}
+        {($_-eq9)-or($_-eq25)-or($_-eq41)-or($_-eq57)-or($_-eq73)-or($_-eq89)}{$SubDomain="fly";Break}
+        {($_-eq64)-or($_-eq65)}{$SubDomain="bkp";Break}
+        {($_-eq18)-or($_-eq19)}{$SubDomain="vdi";Break}
+        {($_-eq0)-or($_-eq1)}{$SubDomain="inf";Break}
+        {($_-eq2)}{$SubDomain="mgt";Break}
+        Default{$SubDomain="all";Break}
+    }Return $SubDomain
+}
+Function WriteCustomError{param([System.Exception]$Exception,$targetObject,[string]$errorID,[System.Management.Automation.ErrorCategory]$errorCategory="NotSpecified")
+    $errorRecord=new-object System.Management.Automation.ErrorRecord($Exception,$errorID,$errorCategory,$targetObject)
+    $PSCmdlet.WriteError($errorRecord)
+}
+Clear-Host;Clear-History
+$StartDate=(Get-Date).AddDays(-30).toString('M/d/yyyy')
+$StartDate=[datetime]::ParseExact($StartDate,'M/d/yyyy',$null)
+$ScriptName=$MyInvocation.MyCommand.Name
+Write-Host "Beginning '$ScriptName' to reset the local administrator's account password."
+$Ascii=$null;For($a=48;$a–le122;$a++){$ascii+=,[char][byte]$a}
+$WorkingPath="C:\Users\Public\Documents"
+Set-Location -Path $WorkingPath
+$ImportForPMP="ImportForPMP.csv"
+$ExportFile="ExportList.csv"
+$SearchDomain="utshare.local"
+$DomainController="dca01."+$SearchDomain
+$AuthUser=$env:USERDOMAIN+"\"+$env:USERNAME
+If(Test-Path $ExportFile){Remove-Item -Path $ExportFile}
+$SharedFile="\\fs8600a1.inf.utshare.local\sysadm\pmp\$ImportForPMP"
+Write-Host "Retrieving list of domain computers from the'$SearchDomain' domain."
+Write-Host "Exporting list of domain computers to '$WorkingPath\$ExportFile'."
+$Headers='ResourceName','DNSName','Description','Department','Location','ResourceType','ResourceURL','UserAccount','Password','Notes','DistinguishedName'
+Get-ADComputer -Credential $AuthUser -Server $DomainController -Filter * -Property * | Select-Object Name,LastLogonDate,PasswordLastSet,OperatingSystem,IPv4Address,DNSHostName,DistinguishedName,CanonicalName | Sort-Object -Property Name | Export-CSV $ExportFile -NoTypeInformation -Encoding UTF8
+$ShowHeaders='DNSName','UserAccount','Password'
+$FileData="TempImport.csv"
+If(Test-Path $ExportFile){
+    Write-Host "Completed export of domain computers to '$ExportFile'."
+    Write-Host "Adding exported list of domain computers to memory."
+    $ComputerList=Import-Csv $ExportFile
+    $NSLookupData="nslookup.txt"
+    $PingResults="PingData.txt"
+    $ResultFile="Results.log"
+    $AliasesFound=$true
+    [int]$RightAlign=87
+    $ImportOS="Windows"
+    $ImportSheet=$null
+    $DomainName=$null
+    [int]$PingCount=2
+    $IPv4Found=$false
+    $ProcessDC=$false
+    $Aliases=$null
+    $DCCounter=0
+    Write-Host "Completed import of domain computers to memory."
+    If(Test-Path $ResultFile){Remove-Item -Path $ResultFile}
+    If(Test-Path $ImportForPMP){Remove-Item -Path $ImportForPMP}
+    Write-Host "Starting to process imported list of domain computers."
+    $Message=DisplayMessage -Description "" -Background "Black"
+    ForEach($Computer In $ComputerList){
+        If(@($($Computer.IPv4Address).Split("."))[1]-like"118"){
+            $IPv4Address=$($Computer.IPv4Address).ToString()
+            If($($Computer.OperatingSystem)-like"Windows Server*"){
+                $Message=DisplayMessage -Description "" -Background "Black"
+                $root=$false
+                $Campus=$false
+                $Disabled=$null
+                $SubDomain=$null
+                $ProcessDC=$false
+                $ErrorSettingPWD=$true
+                $OnlineStatus="Offline"
+                $HostName=@($($Computer.Name)).toLower()
+                $LastLogonDate=$($Computer.LastLogonDate)
+                $DNSHostName=@($($Computer.DNSHostName).toLower())
+                $EndDate=@($($Computer.PasswordLastSet).Split(" "))[0]
+                $EndDate=[datetime]::ParseExact($EndDate,'M/d/yyyy',$null)
+                $DomainName=@($($Computer.CanonicalName).Split("/"))[0]
+                $Message=DisplayMessage -Description "Working on current computer:" -StatusMessage $DNSHostName
+                $AbleToPing=CheckConnectivity -SearchObject $DNSHostName -SearchValue ("Reply from*")
+                If(!($AbleToPing)){$Message=DisplayMessage -Description "Not able to ping $DNSHostName by using hostname" -FontColor "Yellow" -Background "DarkRed"}
+                If($AbleToPing){$Message=DisplayMessage -Description "'$DNSHostName' is online." -StatusMessage ($IPv4Address) -FontColor "Yellow"}
+                $ServerFound=DNSLookup -ObjectValue $DNSHostName -SearchValue ("Name*"+$HostName+"*")
+                If(!($ServerFound)){$Message=DisplayMessage -Description "Not able to resolve Forward DNS for $DNSHostName" -FontColor "Yellow" -Background "DarkRed"}
+                $SubDomain=@($($DNSHostName).Split("."))[1]
+                Switch($($HostName).Substring(0,2).toLower()){
+                    {($_-eq"ar")-or($_-eq"da")-or($_-eq"pb")-or($_-eq"rg")-or($_-eq"ty")-or($_-eq"za")-or($_-eq"zb")}{$Campus=$true;Break}
+                    default{$Campus=$false;Break}
+                }
+                If($Campus-eq$true){
+                    Switch($($HostName).Substring(4,3).toLower()){
+                        {($_-eq"cfg")-or($_-eq"cnv")}{$CheckSubDomain="fly";Break}
+                        {($_-eq"prd")-or($_-eq"rpt")}{$CheckSubDomain="prd";Break}
+                        "dev"{$CheckSubDomain="dev";Break}
+                        "dmo"{$CheckSubDomain="dmo";Break}
+                        "fly"{$CheckSubDomain="fly";Break}
+                        "pum"{$CheckSubDomain="pum";Break}
+                        "sbx"{$CheckSubDomain="sbx";Break}
+                        "trn"{$CheckSubDomain="trn";Break}
+                        "tst"{$CheckSubDomain="tst";Break}
+                        "uat"{$CheckSubDomain="uat";Break}
+                        Default{$CheckSubDomain=$null;Break}
+                    }
+                    If(($SubDomain-eq$null)-or!($SubDomain-eq$CheckSubDomain)){$SubDomain=VerifyIPv4Address}
+                    $ZoneName=$SubDomain+"."+$SearchDomain
+                    If(($Campus-eq$true)-and($HostName.Length-le9)){
+                        $Aliases=$HostName.Substring(0,4)+$SubDomain+$HostName.Substring(4,5)
+                    }
+                    If((!($ServerFound)-or!($AbleToPing))-or($HostName.Length-le9)){
+                        $ServerFound=DNSLookup -ObjectValue $IPv4Address -SearchValue ("Name*"+$HostName+"*")
+                        $IPv4Found=DNSLookup -ObjectValue $IPv4Address -SearchValue ("Address*"+$IPv4Address)
+                        $AliasesFound=DNSLookup -ObjectValue $Aliases -SearchValue ("Address*"+$IPv4Address)
+                        $AbleToPing=CheckConnectivity -SearchObject $IPv4Address -SearchValue ("Reply from*")
+                        $DNSHostName=@($($HostName)+"."+$($ZoneName)).toLower()
+                        If($IPv4Found-and$AbleToPing){
+                            If(($ServerFound-eq$true)-and!($AliasesFound-eq$true)){
+                                $Message=DisplayMessage -Description "Creating CNAME for '$Aliases'" -FontColor "Cyan"
+                                Add-DnsServerResourceRecordCName -ComputerName $DomainController -Name $Aliases -ZoneName $ZoneName -HostNameAlias $($DNSHostName)
+                            }
+                            If($AbleToPing-and!($ServerFound)){
+                                $Message=DisplayMessage -Description "Creating A Record for '$HostName'" -FontColor "Cyan"
+                                Add-DnsServerResourceRecordA -ComputerName $DomainController -Name $HostName -ZoneName $ZoneName -AllowUpdateAny -IPv4Address $IPv4Address
+                            }
+                        }
+                    }
+                }
+                $DomainControllers=@($($Computer.CanonicalName).Split("/"))[1]-eq"Domain Controllers"
+                If($DomainControllers){
+                    $DCCounter++
+                    $AbleToPing=CheckConnectivity -SearchObject $DNSHostName -SearchValue ("Reply from*")
+                    If(!$AbleToPing){
+                        $Message=DisplayMessage -StatusMessage "Not able to access domain controller at this time." -FontColor "Yellow" -Background "DarkRed"
+                        $DCCounter--
+                    }
+                    If($DCCounter-eq1){
+                        $Message=DisplayMessage -StatusMessage "Processing first available domain controller in the list." -FontColor "Green"
+                        $ProcessDC=$true
+                    }
+                }Else{
+                    If(!($ServerFound)-or!($AbleToPing)){
+                        If(!($ServerFound)){
+                            $ServerFound=DNSLookup -ObjectValue $IPv4Address -SearchValue ("Name*"+$HostName+"*")
+                            If(!($ServerFound)){$Message=DisplayMessage -Description "Not able to resolve $DNSHostName using Reverse DNS" -FontColor "Yellow" -Background "DarkRed"}
+                        }
+                        If(!($AbleToPing)){
+                            $AbleToPing=CheckConnectivity -SearchObject $IPv4Address -SearchValue ("Reply from*")
+                            If(!($AbleToPing)){$Message=DisplayMessage -Description "Not able to ping $DNSHostName by using IP Address" -FontColor "Yellow" -Background "DarkRed"}
+                        }
+                    }
+                }
+                $DateDifference=(New-TimeSpan –Start $StartDate –End $EndDate).Days
+                $Message=DisplayMessage -Description "'$DateDifference' day(s) until computer account password is changed."
+                If((($DateDifference-eq0)-and!($AbleToPing))-or($DateDifference-lt0)){
+                    $Message=DisplayMessage -Description "The computer hasn't changed it's password in over 30 days." -FontColor "Yellow" -Background "DarkRed"
+                    $Message=DisplayMessage -Description "If the computer isn't able to successfully change the" -FontColor "Yellow" -Background "DarkRed"
+                    $Message=DisplayMessage -Description "computer account password, it will risk becoming stale." -FontColor "Yellow" -Background "DarkRed"
+                }
+                If(($ProcessDC-eq$true)-or!($DomainControllers)){
+                    $ComputerADSI=[ADSI] "WinNT://$($Computer.DNSHostName),Computer"
+                    ForEach($ChildObject in $ComputerADSI.Children){
+                        if($ChildObject.Class-ne"User"){
+                            Continue
+                        }
+                        $Type="System.Security.Principal.SecurityIdentifier"
+                        $ChildObjectSID=new-object $Type($ChildObject.objectSid[0],0)
+                        if($ChildObjectSID.Value.EndsWith("-500")){
+                            $UserName=@($($ChildObject.Name[0]))
+                            $Message=DisplayMessage -Description "Local Administrator account name:" -StatusMessage $UserName
+                            $Message=DisplayMessage -Description "Local Administrator account SID:" -StatusMessage $($ChildObjectSID.Value)
+                            try{
+                                $Disabled=$true <#
+                                $AdminPassword=GetTempPassword -SourceData $Ascii
+                                $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($AdminPassword)
+                                $UnsecurePassword=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                                $Message=DisplayMessage -Description "Attempting to change password on" -StatusMessage $HostName
+                                ([ADSI] "WinNT://$HostName/$UserName").SetPassword($UnsecurePassword);$Disabled=$false
+                                $Resource="$HostName,$DNSHostName,,,,$ImportOS,,$UserName,$UnsecurePassword,,"
+                                $Resource | ForEach{Add-Content -Path $ImportForPMP -Value $_}#>
+                                $ErrorSettingPWD=$false
+                            }catch [System.Management.Automation.MethodInvocationException]{
+                                $Message="Cannot reset password for '$HostName\$UserName' due the following error: '$($_.Exception.InnerException.Message)'"
+                                $Exception=new-object ($_.Exception.GetType().FullName)($Message,$_.Exception.InnerException)
+                                WriteCustomError $Exception "$HostName\$UserName" $ScriptName
+                            }
+                            If($Disabled){
+                                $ImportSheet=Import-Csv -LiteralPath $SharedFile -Header $Headers | Select $ShowHeaders | where {$_.DNSName-eq$DNSHostName}
+                                $ImportSheet | Export-CSV $FileData -NoTypeInformation
+                                $ImportSheet | ForEach-Object{
+                                    ForEach($Property In $_.PSObject.Properties){
+                                        Switch($Property.Name){
+                                            "DNSName"{$DNSHostName=$Property.Value;Break}
+                                            "UserAccount"{$UserName=$Property.Value;Break}
+                                            "Password"{$AdminPassword=$Property.Value | ConvertTo-SecureString -AsPlainText -Force;Break}
+                                        }
+                                    }
+                                }
+                            }
+                            If(TestCredential($UserName)($AdminPassword)($DNSHostName)){
+                                $Message=DisplayMessage -Description "Successfully changed the password on" -StatusMessage $DNSHostName -FontColor "Green"
+                                $OnlineStatus="Online"
+                            }Break
+                        }
+                    }
+                    If($ErrorSettingPWD-eq$true){
+                        $Message=DisplayMessage -Description "Failed to retrieve user information on server: $DNSHostName" -FontColor "Yellow" -Background "DarkRed"
+                        Add-Content -Path $ResultFile -Value $Message
+                    }ElseIf($OnlineStatus-eq"Offline"){
+                        $Message=DisplayMessage -Description "Server: $DNSHostName is not remote administration accessible" -FontColor "Yellow" -Background "DarkRed"
+                        Add-Content -Path $ResultFile -Value $Message
+                    }
+                }
+                $ChildObjectSID=$null
+                $AdminPassword=$null
+                $LastLogonDate=$null
+                $ServerFound=$false
+                $AliasesFound=$true
+                $OnlineStatus=$null
+                $ComputerName=$null
+                $AbleToPing=$false
+                $DNSHostName=$null
+                $ChildObject=$null
+                $ImportSheet=$null
+                $IPv4Found=$false
+                $DomainName=$null
+                $HostName=$null
+                $UserName=$null
+                $Resource=$null
+                $Aliases=$null
+                $Message=$null
+                $Message=DisplayMessage -Description "" -Background "Black"
+            }
+        }
+    }
+    $Message=DisplayMessage -Description "Completed processing imported list of local administrator's account password."
+}
+If(Test-Path $FileData){Remove-Item $FileData}
+If(Test-Path $ExportFile){Remove-Item -Path $ExportFile -Force}
+If(Test-Path $PingResults){Remove-Item -Path $PingResults -Force}
+If(Test-Path $NSLookupData){Remove-Item -Path $NSLookupData -Force}
+Write-Host "Deleted the temporary files from '$WorkingPath'."
+$DomainController=$null
+$ImportForPMP=$null
+$SearchValue=$null
+$ShowHeaders=$null
+$WorkingPath=$null
+$ExportFile=$null
+$SharedFile=$null
+$PingCount=$null
+$ImportOS=$null
+$Headers=$null
+Set-Location -Path "C:\Windows\System32"
\ No newline at end of file
diff --git a/PowerShell/General/CheckComputerStatus_2018-0408.ps1 b/PowerShell/General/CheckComputerStatus_2018-0408.ps1
new file mode 100644
index 0000000..916fefd
--- /dev/null
+++ b/PowerShell/General/CheckComputerStatus_2018-0408.ps1
@@ -0,0 +1,224 @@
+﻿Function DeleteComputer(){
+    Write-Host "Attempting to remove '$DNSHostName' from $DomainName."
+    $ADIdentity=@($($Computer.DistinguishedName))
+    Remove-ADComputer -Credential $AuthUser -AuthType Negotiate -Server $DomainController -Identity "$ADIdentity" -Confirm
+}
+Function GET-TempPassword(){Param([int]$Characters=32,[string[]]$SourceData)
+    For($Loop=1;$Loop–le$Characters;$Loop++){
+    $TempPassword+=($SourceData | GET-RANDOM)
+    }
+    Return $TempPassword
+}
+Function Test-ADCredential{[CmdletBinding()]Param($UserName,$Password,$HostName)
+    if(!($UserName)-or!($Password)){
+        Write-Warning 'Test-ADCredential: Please specify both user name and password'
+    }else{
+        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
+        $DS=New-Object System.DirectoryServices.AccountManagement.PrincipalContext('machine',$HostName)
+        $DS.ValidateCredentials($UserName,$Password)
+    }
+}
+Function Write-CustomError{param([System.Exception]$Exception,$targetObject,[String]$errorID,[System.Management.Automation.ErrorCategory]$errorCategory="NotSpecified")
+    $errorRecord=new-object System.Management.Automation.ErrorRecord($Exception,$errorID,$errorCategory,$targetObject)
+    $PSCmdlet.WriteError($errorRecord)
+}
+Clear
+$StartDate=(Get-Date).AddDays(-30).toString('M/d/yyyy')
+$StartDate=[datetime]::ParseExact($StartDate,'M/d/yyyy',$null)
+$ScriptName=$MyInvocation.MyCommand.Name
+Write-Host "Beginning '$ScriptName' to reset the local administrator's account password."
+$Ascii=$null;For($a=48;$a–le122;$a++){$ascii+=,[char][byte]$a}
+$WorkingPath="C:\Users\Public\Documents"
+Set-Location -Path $WorkingPath
+$ImportForPMP="ImportForPMP.csv"
+$ExportFile="ExportList.csv"
+$SearchDomain="utshare.local"
+$DomainController="dca01."+$SearchDomain
+$AuthUser=$env:USERDOMAIN+"\"+$env:USERNAME
+If(Test-Path $ExportFile){Remove-Item -Path $ExportFile}
+Write-Host "Exporting list of domain computers to '$ExportFile'."
+Get-ADComputer -Credential $AuthUser -Server $DomainController -Filter * -Property * | Select-Object Name,LastLogonDate,PasswordLastSet,OperatingSystem,IPv4Address,DNSHostName,DistinguishedName,CanonicalName | Sort-Object -Property Name | Export-CSV $ExportFile -NoTypeInformation -Encoding UTF8
+Write-Host "Completed export of domain computers to '$ExportFile'."
+Write-Host "Adding exported list of domain computers to memory."
+$ComputerList=Import-Csv $ExportFile
+$NSLookupData="nslookup.txt"
+$PingResults="PingData.txt"
+$ResultFile="Results.log"
+$ErrorSettingPWD=$true
+$ImportOS="Windows"
+$DomainName=$null
+[int]$PingCount=2
+$DCCounter=0
+Write-Host "Completed import of domain computers to memory."
+If(Test-Path $ResultFile){Remove-Item -Path $ResultFile}
+If(Test-Path $ImportForPMP){Remove-Item -Path $ImportForPMP}
+Write-Host "Starting to process imported list of domain computers."
+Write-Host ""
+ForEach($Computer In $ComputerList){
+    If(@($($Computer.IPv4Address).Split("."))[1]-like"118"){
+        If($($Computer.OperatingSystem)-like"Windows Server*"){
+            $root=$false
+            $Campus=$false
+            $AbleToPing=$false
+            $ComputerName=$null
+            $BadDNSRecord=$false
+            $HostName=@($($Computer.Name)).toLower()
+            $DNSHostName=@($($Computer.DNSHostName))
+            $LastLogonDate=$($Computer.LastLogonDate)
+            $EndDate=@($($Computer.PasswordLastSet).Split(" "))[0]
+            $EndDate=[datetime]::ParseExact($EndDate,'M/d/yyyy',$null)
+            $DomainName=@($($Computer.CanonicalName).Split("/"))[0]
+            If(@($($Computer.CanonicalName).Split("/"))[1]-eq"AllServers"){
+                $SubDomain=@($($DNSHostName).Split("."))[1]
+                If($SubDomain-eq@($($SearchDomain).Split("."))[0]){
+                    Switch($($HostName).Substring(0,2).toLower()){
+                       "ar"{$Campus=$true;Break}
+                       "da"{$Campus=$true;Break}
+                       "pb"{$Campus=$true;Break}
+                       "rg"{$Campus=$true;Break}
+                       "ty"{$Campus=$true;Break}
+                       "za"{$Campus=$true;Break}
+                       "zb"{$Campus=$true;Break}
+                       default{$root=$true;Break}
+                    }
+                    If($Campus-eq$true){
+                        Switch($($HostName).Substring(4,3).toLower()){
+                            "cfg"{$SubDomain="fly";Break}
+                            "cnv"{$SubDomain="fly";Break}
+                            "dev"{$SubDomain="dev";Break}
+                            "dmo"{$SubDomain="dmo";Break}
+                            "fly"{$SubDomain="fly";Break}
+                            "prd"{$SubDomain="prd";Break}
+                            "pum"{$SubDomain="pum";Break}
+                            "rpt"{$SubDomain="prd";Break}
+                            "sbx"{$SubDomain="sbx";Break}
+                            "trn"{$SubDomain="trn";Break}
+                            "tst"{$SubDomain="tst";Break}
+                            "uat"{$SubDomain="uat";Break}
+                            default{$SubDomain="all";Break}
+                        }
+                        $DNSHostName=@($($HostName)+"."+$($SubDomain)+"."+$($SearchDomain)).toLower()
+                    }Else{
+                        $DNSHostName=@($($HostName)+".inf."+$($SearchDomain)).toLower()
+                    }
+                    $BadDNSRecord=$true
+                }
+            }
+            Write-Host "Working on current computer:                     $DNSHostName"
+            Start-Process -FilePath "$env:comspec" -ArgumentList "/c ping $DNSHostName -n $PingCount -w 1" -RedirectStandardOutput $PingResults -WindowStyle Hidden -Wait
+            $DoubleCheck={
+                $ServerFound=$false
+                $SearchValue="Reply from*"
+                If(Test-Path $PingResults){
+                    ForEach($CurrentLine In Get-Content $PingResults){
+                        If($CurrentLine-like$SearchValue){
+                            $AbleToPing=$true
+                            Break
+                        }
+                    }
+                    $DateDifference=(New-TimeSpan –Start $StartDate –End $EndDate).Days
+                    If(($AbleToPing-eq$true)-and($ComputerName-eq$null)){
+                        Write-Host "'$DNSHostName' is online." -ForegroundColor Green
+                    }ElseIf(($AbleToPing-eq$true)-and!($ComputerName-eq$null)){
+                        Write-Host "'$ComputerName' is online." -ForegroundColor Cyan
+                        $DNSHostName=$ComputerName
+                    }ElseIf(($ComputerName-eq$null)-and!($AbleToPing-eq$true)){
+                        $ServerStatus="not found in Windows DNS"
+                        $SearchValue="Name*$HostName*"
+                        Start-Process -FilePath "$env:comspec" -ArgumentList "/c nslookup $DNSHostName" -RedirectStandardOutput $NSLookupData -WindowStyle Hidden -Wait
+                        If(Test-Path $NSLookupData){
+                            ForEach($CurrentLine In Get-Content $NSLookupData){
+                                If($CurrentLine-like$SearchValue){
+                                    $ServerStatus="not responding to ping"
+                                    $ServerFound=$true
+                                    Break
+                                }
+                            }
+                            Write-Host "The server: '$DNSHostName' is $ServerStatus" -ForegroundColor Yellow -BackgroundColor DarkRed
+                            Write-Host "'Last Logon Date' is: "$LastLogonDate -ForegroundColor White -BackgroundColor DarkRed
+                            If(!($ServerFound-eq$true)){
+                                $ComputerName=@($($HostName)+"."+$($SearchDomain)).toLower()
+                                Write-Host "Attempting to ping '$ComputerName' using the root domain: '$SearchDomain'"
+                                Start-Process -FilePath "$env:comspec" -ArgumentList "/c ping $ComputerName -n $PingCount -w 1" -RedirectStandardOutput $PingResults -WindowStyle Hidden -Wait
+                                .$DoubleCheck
+                            }ElseIf(($DateDifference-lt0)-and!($AbleToPing-eq$true)){DeleteComputer}
+                        }
+                    }ElseIf((!($ComputerName-eq$null)-and!($AbleToPing-eq$true))-or(($DateDifference-lt0)-and!($AbleToPing-eq$true))){
+                        Write-Host "The server: '$ComputerName' is not pingable using the root domain." -ForegroundColor Yellow -BackgroundColor DarkRed;DeleteComputer
+                    }
+                    If(($AbleToPing-eq$true)-and($ComputerName-eq$null)){
+                        $ErrorSettingPWD=$true
+                        $OnlineStatus="Offline"
+                        $DomainController=$false
+                        Write-Host "Retrieving local account information from:       $DNSHostName"
+                        If(@($($Computer.DistinguishedName))-like"*OU=Domain Controllers*"){
+                            $DCCounter++;$DomainController=$true
+                        }
+                        If(($DCCounter-le1-and$DomainController-eq$true)-or($DomainController-eq$false)){
+                            $AdminPassword=GET-TempPassword -SourceData $Ascii
+                            $ComputerADSI=[ADSI] "WinNT://$($Computer.DNSHostName),Computer"
+                            ForEach($ChildObject in $ComputerADSI.Children){
+                                if($ChildObject.Class-ne"User"){
+                                    Continue
+                                }
+                                $Type="System.Security.Principal.SecurityIdentifier"
+                                $ChildObjectSID=new-object $Type($ChildObject.objectSid[0],0)
+                                if($ChildObjectSID.Value.EndsWith("-500")){
+                                    $UserName=@($($ChildObject.Name[0]))
+                                    Write-Host "Local Administrator account name:                $UserName"
+                                    Write-Host "Local Administrator account SID:                 $($ChildObjectSID.Value)"
+                                    try{
+                                        Write-Host "Attempting to change password on                 $HostName"
+                                        ([ADSI] "WinNT://$HostName/$UserName").SetPassword($AdminPassword)
+                                        $Resource="$HostName,$DNSHostName,,,,$ImportOS,,$UserName,$AdminPassword,,"
+                                        $Resource | ForEach{Add-Content -Path $ImportForPMP -Value $_}
+                                        $ErrorSettingPWD=$false
+                                    }catch [System.Management.Automation.MethodInvocationException]{
+                                        $Message="Cannot reset password for '$HostName\$UserName' due the following error: '$($_.Exception.InnerException.Message)'"
+                                        $Exception=new-object ($_.Exception.GetType().FullName)($Message,$_.Exception.InnerException)
+                                        Write-CustomError $Exception "$HostName\$UserName" $ScriptName
+                                    }
+                                    Write-Host "Verifying the password was changed on            $HostName"
+                                    If(Test-ADCredential($UserName)($AdminPassword)($DNSHostName)){
+                                        $OnlineStatus="Online"
+                                        Write-Host "Successfully changed the password on             '$DNSHostName'" -ForegroundColor Green
+                                    }Break
+                                }
+                            }
+                            If($ErrorSettingPWD-eq$true){
+                                $Message="Failed to retrieve user information on server:  '$DNSHostName'"
+                                Add-Content -Path $ResultFile -Value $Message -PassThru
+                            }ElseIf($OnlineStatus-eq"Offline"){
+                                $Message="Server: $DNSHostName is not remote administration accessible"
+                                Add-Content -Path $ResultFile -Value $Message -PassThru
+                            }
+                        }
+                        Write-Host ""
+                    }
+                }$ComputerName=$null
+            }
+            If($AbleToPing-eq$false){&$DoubleCheck}
+            $ChildObjectSID=$null
+            $AdminPassword=$null
+            $LastLogonDate=$null
+            $OnlineStatus=$null
+            $DNSHostName=$null
+            $ChildObject=$null
+            $DomainName=$null
+            $HostName=$null
+            $ImportOS=$null
+            $UserName=$null
+            $Resource=$null
+            $Message=$null
+            Write-Host ""
+        }
+    }
+}
+Write-Host "Completed processing imported list of local administrator's account password."
+If(Test-Path $PingResults){Remove-Item -Path $PingResults}
+If(Test-Path $NSLookupData){Remove-Item -Path $NSLookupData}
+If(Test-Path $ExportFile){Remove-Item -Path $ExportFile -Force}
+Write-Host "Deleted the temporary files from '$WorkingPath'."
+$SearchValue=$null
+$PingCount=$null
+Set-Location -Path "C:\Windows\System32"
\ No newline at end of file
diff --git a/PowerShell/General/CopyData.ps1 b/PowerShell/General/CopyData.ps1
new file mode 100644
index 0000000..6dad240
--- /dev/null
+++ b/PowerShell/General/CopyData.ps1
@@ -0,0 +1,306 @@
+Clear-Host;Clear-History
+Set-Location $env:SystemRoot\System32
+$CurrentLocation=Get-Location
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Set-Variable -Name Loops -Value 0
+Set-Variable -Name LoopCount -Value 0
+Clear
+Do{
+    Set-Variable -Name Domain -Value $env:USERDNSDOMAIN.ToLower()
+    Set-Variable -Name SecureUser -Value $env:USERNAME@$Domain
+    Set-Variable -Name WorkingPath -Value "$env:USERProfile\AppData\Local\$Domain\Credentials"
+    Set-Variable -Name SecureFile -Value "$WorkingPath\Encrypted.pwd"
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value 'pwd','key'
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+    }
+	$WorkingPath="$env:USERProfile\AppData\Local\Temp"
+    Set-Variable -Name SrcSrvr -Value "fs8600a01.inf.$Domain"
+    Set-Variable -Name DecSrvr -Value "w16adfs01.inf.$Domain"
+    Set-Variable -Name Options -Value '/XA:RSH'
+    Set-Variable -Name NetDrvs -Value $null
+    Set-Variable -Name LastDrv -Value $null
+    Set-Variable -Name Counter -Value 0
+    Set-Location -Path $WorkingPath
+    $SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    $ServerList=@("$SrcSrvr","$DecSrvr")
+    $LocalHost=$env:COMPUTERNAME.ToLower()
+    ForEach($Server In $ServerList){
+        If($Server-like"*$LocalHost*"){
+            Switch($Server){
+                $SrcSrvr{$SrcSrvr="E:";Break}
+                $DecSrvr{$DecSrvr="E:";Break}
+            }
+        }
+    }
+    $Counter=0
+    If($SrcSrvr.Substring(1,1)-ne":"){$SrcSrvr="\\$SrcSrvr"}
+    If($DecSrvr.Substring(1,1)-ne":"){$DecSrvr="\\$DecSrvr"}
+    Set-Variable -Name NetDrvs -Value "D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"
+    $DrvLtrs=Get-CimInstance -Class Win32_LogicalDisk
+    Set-Variable -Name MapDrvList -Value $null
+    $IntLoop=0
+    Do{
+        $Counter++
+        $LastDrv=$null
+        Switch($Counter){
+            1{$CurPath=$SrcSrvr;Break}
+            2{$CurPath=$DecSrvr;Break}
+        }
+        If($CurPath.Substring(0,2)-eq"\\"){
+            ForEach($NetDrv In $NetDrvs){
+                If($IntLoop-eq$Counter){Break}
+                If(($LastDrv-eq$null)-or($MapDrvList-eq$NetDrv)){
+                    ForEach($DrvLtr In $DrvLtrs.DeviceID){
+                        $NetID=$NetDrv+':'
+                        If(($DrvLtrs.DeviceID-notcontains"$NetID")-and($MapDrvList-notlike"*$NetDrv*")){
+                            $IntLoop++
+                            Switch($IntLoop){
+                                1{$MapDrvList=$NetDrv;Break}
+                                2{If($MapDrvList-eq$null){
+                                        $MapDrvList=$NetDrv;Break
+                                    }Else{
+                                        $MapDrvList=$MapDrvList+","+$NetDrv;Break
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }Until($Counter-eq2)
+    $Shares="arshared","dashared","sashared","tyshared","projects","iso","Stat-Projects","Stat-Shared"
+    Set-Variable -Name SrcDrv -Value $null
+    Set-Variable -Name DesDrv -Value $null
+    Set-Variable -Name Folders -Value $null
+    ForEach($Share In $Shares){
+        $CurrentSrc="$SrcSrvr\$Share"
+        If($CurrentSrc.Substring(0,2)-eq"\\"){
+            $SrcDrv=$MapDrvList.Substring(0,1)
+            New-PSDrive -Name "$SrcDrv" -Root "$CurrentSrc" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        }Else{$SrcDrv=$SrcSrvr.Substring(0,1)}
+        $Counter++
+        If($Counter-le5){
+            Switch($Counter){
+                5{
+                    $Share="developers\za"
+                    Break}
+                Default{
+                    $Share="developers\"+$Share.ToString().Substring(0,2)
+                    Break}
+            }
+        }
+        $CurrentDes="$DecSrvr\$Share"
+        If($CurrentDes.Substring(0,2)-eq"\\"){
+            If($MapDrvList.Substring(1,1)-eq","){
+                $DesDrv=$MapDrvList.Substring(2,1)
+            }Else{
+                $DesDrv=$MapDrvList.Substring(0,1)
+            }
+            New-PSDrive -Name "$DesDrv" -Root "$CurrentDes" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        }Else{$DesDrv=$DecSrvr.Substring(0,1)}
+#        Robocopy $SrcDrv":\" $DesDrv":\" '*.*' $Options /E /SL /MIR /R:0 /W:0 /XD ".clusterConfig" /XD "DfsrPrivate" /XD ".TemporaryItems" /XD "replica*"
+        If($SrcDrv-ne$null){Get-PSDrive $SrcDrv|Remove-PSDrive}
+        If($DesDrv-ne$null){Get-PSDrive $DesDrv|Remove-PSDrive}
+    }
+    $CurrentSrc=$DecSrvr+"\sysadm"
+    $CurrentDes=$DecSrvr+"\sysadmins"
+    If($CurrentSrc.Substring(0,2)-eq"\\"){
+        New-PSDrive -Name "$SrcDrv" -Root "$CurrentSrc" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+    }
+    If($CurrentDes.Substring(0,2)-eq"\\"){
+        New-PSDrive -Name "$DesDrv" -Root "$CurrentDes" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+    }
+#    Robocopy $SrcDrv":\" $DesDrv":\" '*.*' $Options /E /SL /MIR /R:0 /W:0 /XD ".clusterConfig" /XD "DfsrPrivate" /XD ".TemporaryItems" /XD "replica*"
+    If($CurrentSrc.Substring(0,2)-eq"\\"){
+        If($SrcDrv-ne$null){Get-PSDrive $SrcDrv|Remove-PSDrive}
+    }
+    If($CurrentDes.Substring(0,2)-eq"\\"){
+        If($DesDrv-ne$null){Get-PSDrive $DesDrv|Remove-PSDrive}
+    }
+    $Folders="ar","da","ep","pb","rg","sa","sy","ty"
+    ForEach($Folder In $Folders){
+        $CurrentSrc=$DecSrvr+"\working"
+        $CurrentDes=$DecSrvr+"\storage\users"
+<#
+        If($CurrentSrc.Substring(0,2)-eq"\\"){
+            New-PSDrive -Name "$SrcDrv" -Root "$CurrentSrc" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        }Else{
+            $SrcDrv=$CurrentSrc
+        }
+        If($CurrentDes.Substring(0,2)-eq"\\"){
+            New-PSDrive -Name "$DesDrv" -Root "$CurrentDes" -Credential $SecureCredentials -Persist -PSProvider FileSystem
+        }
+#>
+        $SrcDrv=$CurrentSrc
+        $DesDrv=$CurrentDes
+        Robocopy $SrcDrv"\"$Folder $DesDrv"\"$Folder '*.*' $Options /E /COPYALL /MIR /R:0 /W:0 /XD ".clusterConfig" /XD "DfsrPrivate" /XD ".TemporaryItems" /XD "replica*"
+<#
+        If($SrcDrv-ne$null){Get-PSDrive $SrcDrv|Remove-PSDrive}
+        If($DesDrv-ne$null){Get-PSDrive $DesDrv|Remove-PSDrive}
+#>
+    }
+    $LoopCount++
+}While($LoopCount-le$Loops)
+Set-Location -Path $CurrentLocation
diff --git a/PowerShell/General/EncryptPWD.ps1 b/PowerShell/General/EncryptPWD.ps1
new file mode 100644
index 0000000..40e08b7
--- /dev/null
+++ b/PowerShell/General/EncryptPWD.ps1
@@ -0,0 +1,169 @@
+﻿<#Function ClearVariables{[CmdletBinding(SupportsShouldProcess)]param()
+    If($StartupVariables){
+        $UserVariables=Get-Variable -Exclude $StartupVariables -Scope Global
+        ForEach($UserItem In $UserVariables){
+            Try{
+                Clear-Variable -Name "UserItem" -Force -Scope Global -ErrorAction SilentlyContinue
+            }Catch [Exception]{
+                If($($_.Exception.Message)-eq"Cannot find a variable with the name '$($UserItem.Name)'."){
+                }Else{
+                    $Message="Error: [ClearVariables]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+                }
+            }
+        }
+    }
+}#>
+Function ClearVariables{[CmdletBinding()]param([Parameter(Mandatory=$true)]$VariableList=@())
+    Try{
+        ForEach($Item In $VariableList){
+            If($Item.length-lt1){
+            }Else{
+                Set-Variable -Name $Item -Value $null
+                Clear-Variable -Name $Item -Scope Global -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }Catch [Exception]{
+        If($_.Exception.Message-eq"Cannot find a variable with the name '$Item'."){
+        }Else{
+            $Message=$_.Exception.Message
+            Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+    }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Clear-Host;Clear-History
+Set-Location -Path "$($env:USERProfile)\Documents"
+Set-Variable -Name "AuthUser" -Value "bstobie@utsystem.edu"
+Set-Variable -Name "WorkingPath" -Value "$env:USERProfile\Documents\Passwords"
+Set-Variable -Name "SecureFile" -Value "$WorkingPath\Encrypted.pwd"
+Set-Variable -Name "EncryptionKeyFile" -Value ""
+Set-Variable -Name "Characters" -Value ""
+Set-Variable -Name "PrivateKey" -Value ""
+Set-Variable -Name "SecureKey" -Value ""
+[String]$Key=0
+[Int]$Min=8
+[Int]$Max=1024
+$Prompt="Enter the length you want to use for the security key: [up to 16 bytes]"
+[Int]$RandomKey=Read-Host -Prompt $Prompt
+If(Test-Path $WorkingPath){
+    $Results=Get-ChildItem -Path $WorkingPath -File
+    ForEach($File In $Results){
+        $FileName=$($File.Name).Split(".")[0]
+        If($FileName.length-eq$RandomKey){
+            $KeyFile="$($File.Name)"
+            $Key=$($KeyFile).Split(".")[0]
+            If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                Break
+            }
+        }
+    }
+}Else{
+    $Dir=MkDir $WorkingPath
+}
+If($PrivateKey.length-lt1){
+    Do{
+        Switch($RandomKey){
+            {($_-eq8)}{
+                $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                Break
+            }
+            {($_-eq12)}{
+                $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                Break
+            }
+            {($_-eq16)}{
+                $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                Break
+            }
+            {($Key.length-lt$RandomKey)}{
+                $RandomKey+=1
+                Break
+            }
+            {($Key.length-gt$RandomKey)}{
+                $RandomKey-=1
+                Break
+            }
+            Default{
+                $RandomKey=16
+                Break
+            }
+        }
+    }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+    $i=0
+    Do{
+        $i++
+        If(Test-Path -Path $SecureFile){
+            $SecureFile="$WorkingPath\Encrypted$i.pwd"
+        }
+    }While((Test-Path -Path $SecureFile)-eq$true)
+    $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+    Do{
+        [Int]$Characters=Read-Host -Prompt $Prompt
+        If(($Characters-ge$Min)-and($Characters-le$Max)){
+        }Else{
+            $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+        }
+    }Until(($Characters-ge$Min)-and($Characters-le$Max))
+    For($i=0;$i-le$Characters;$i++){
+        Switch($i){
+            {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+            Default{$PrivateKey="";$Set="";Break}
+        }
+        $PrivateKey+=$Set
+    }
+    Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+    Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+    $Validate=Unprotect-String $PrivateKey $Key
+    If($Validate-ne$false){
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+    }
+    $SecureString=Read-Host -Prompt "Enter your [$AuthUser] credentials" -AsSecureString
+    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+    $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+}
+Clear-Host;Clear-History
+Try{
+    $Validate=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Validate)
+    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+}Catch [Exception]{
+    $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+}Finally{
+    ClearVariables -VariableList 'AuthUser','BSTR','Characters','EncryptedString','EncryptionKeyFile','File','FileName','i','Key','Max','Message','Min','PrivateKey','Prompt','RandomKey','Results','SecureFile','SecureKey','SecureString','Set','Validate','WorkingPath'
+}
\ No newline at end of file
diff --git a/PowerShell/General/Export-ADComputers.ps1 b/PowerShell/General/Export-ADComputers.ps1
new file mode 100644
index 0000000..42076a9
--- /dev/null
+++ b/PowerShell/General/Export-ADComputers.ps1
@@ -0,0 +1,1116 @@
+﻿Clear-Host;Clear-History
+<# 
+#Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
+#Install once and then disable these packages.
+Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
+Install-Module Posh-SSH
+Install-Module PSWriteColor
+#>
+Function Add-StartupVariables{[CmdletBinding(SupportsShouldProcess)]param([Parameter(Mandatory)][ValidateSet('AllUsersAllHosts','AllUsersCurrentHost','CurrentUserAllHosts','CurrentUserCurrentHost')]$Location)
+    $Content=@'
+$StartupVariables=@()
+$StartupVariables=Get-Variable|Select-Object -ExpandProperty Name
+'@
+    If(-not(Test-Path -Path $Profile.$Location)){
+        New-Item -Path $Profile.$Location -ItemType File|Set-Content -Value $Content
+    }ElseIf(-not(Get-Content -Path $Profile.$Location|Select-String -SimpleMatch '$StartupVariables=Get-Variable|Select-Object -ExpandProperty Name')) {
+        Add-Content -Path $Profile.$Location -Value "`r`n$Content"
+    }Else{
+        Write-Verbose -Message "`$StartupVariables already exists in '$($Profile.$Location)'"
+    }
+}
+<#
+Function ClearVariables{[CmdletBinding(SupportsShouldProcess)]param()
+    If($StartupVariables){
+        $UserVariables=Get-Variable -Exclude $StartupVariables -Scope Global
+        ForEach($UserItem In $UserVariables){
+            Try{
+                Clear-Variable -Name "UserItem" -Force -Scope Global -ErrorAction SilentlyContinue
+            }Catch [Exception]{
+                If($($_.Exception.Message)-eq"Cannot find a variable with the name '$($UserItem.Name)'."){
+                }Else{
+                    $Message="Error: [ClearVariables]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+                }
+            }
+        }
+    }
+}
+#>
+Function ClearVariables{[CmdletBinding()]param([Parameter(Mandatory=$true)]$VariableList=@())
+    Try{
+        ForEach($Item In $VariableList){
+            If($Item.length-lt1){
+            }Else{
+                Set-Variable -Name $Item -Value $null
+                Clear-Variable -Name $Item -Scope Global -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }Catch [Exception]{
+        If($_.Exception.Message-eq"Cannot find a variable with the name '$Item'."){
+        }Else{
+            $Message=$_.Exception.Message
+            Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+    }
+}
+Function Get-DateDiff{param([DateTime]$StartDate,[DateTime]$EndDate)
+    $Days=(New-TimeSpan –Start $StartDate.AddDays(-30) –End $EndDate).Days
+    Return $($Days)
+}
+Function Get-ForwardDnsData{param([Parameter(Position=0,Mandatory=$true)][String]$WorkLocation,[Parameter(Position=1,Mandatory=$true)][String]$DNSServer,[String]$SystemName="",[IPAddress]$IPAddress=$null)
+    NullVariables -ItemList 'Data','FileName','ForwardZoneInfo','Found','Record','RecordType','RRType','SubDomain','Zone','ZoneName','ZoneRecord','ZoneRecords','Zones'
+    Try{
+        $Found=$false
+        If(($SystemName-like"*.*")){
+            $SystemName=$SystemName.Split(".")[0]
+        }
+        If($SystemName.Substring(0,2)-eq"fs"){
+            $SubDomain="inf",$SystemName
+        }Else{
+            If($IPAddress.IPAddressToString.Length-gt1){
+                $Results=Get-SubDomain -NetBIOS $SystemName -IPAddress $IPAddress.IPAddressToString
+            }Else{
+                $Results=Get-SubDomain -NetBIOS $SystemName
+            }
+            NullVariables -ItemList 'Campus','Left','Right','SubDomain'
+            $SubDomain=$Results.SubDomain
+        }
+        $ZoneName="$($SubDomain).$SearchDomain"
+        $FileName="$WorkLocation\$ZoneName.csv"
+        If(Test-Path -Path "$FileName"){
+            $ForwardZoneInfo=Import-Csv $FileName|Sort -Property HostName
+            ForEach($Record In $ForwardZoneInfo){
+                If($Record.HostName-eq$SystemName){
+                    $SystemName=$Record.HostName
+                    $RecordType=$Record.RecordType
+                    $Zones=@(Get-DnsServerZone -ComputerName $DNSServer)|Where-Object{$_.ZoneName-eq$ZoneName}|Sort -Property ZoneName
+                    ForEach($Zone In $Zones){
+                        If($Zone.ZoneName-eq$ZoneName){
+                            $ZoneRecords=$Zone|Get-DnsServerResourceRecord -ComputerName $DNSServer|Where-Object{$_.RecordType-eq"$RecordType"}
+                            ForEach($ZoneRecord In $ZoneRecords){
+                                If($ZoneRecord.HostName-eq$SystemName){
+                                    Switch($RecordType){
+                                        "A"{$Data="IPv4Address";Break}
+                                        Default{$Data="";Break}
+                                    }
+                                    $RecordData=$ZoneRecord.RecordData.$Data
+                                    $Found=$true
+                                    Break
+                                }
+                            }
+                            Break
+                        }
+                    }
+                    Break
+                }
+            }
+        }
+        $ParseArray=New-Object PSObject
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $Found
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $SystemName
+        [IPAddress]$AddressList=$($RecordData.AddressList)
+        $SubArray=New-Object PSObject
+        ForEach($AddressList In $RecordData){
+            $SubArray|Add-Member -MemberType NoteProperty -Name "Address" -Value $AddressList.Address
+            $SubArray|Add-Member -MemberType NoteProperty -Name "AddressFamily" -Value $AddressList.AddressFamily
+            $SubArray|Add-Member -MemberType NoteProperty -Name "ScopeId" -Value $AddressList.ScopeId
+            $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Multicast" -Value $AddressList.IsIPv6Multicast
+            $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6LinkLocal" -Value $AddressList.IsIPv6LinkLocal
+            $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6SiteLocal" -Value $AddressList.IsIPv6SiteLocal
+            $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Teredo" -Value $AddressList.IsIPv6Teredo
+            $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv4MappedToIPv6" -Value $AddressList.IsIPv4MappedToIPv6
+            $SubArray|Add-Member -MemberType NoteProperty -Name "IPAddressToString" -Value $AddressList.IPAddressToString
+        }
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "AddressList" -Value $SubArray
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "ZoneName" -Value $ZoneName
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "RRType" -Value $RecordType
+        Return $ParseArray
+    }Catch [Exception]{
+        $Message="Error: [Get-ForwardDnsData]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        Return $Found
+    }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Function Get-ReverseDnsData{param([Parameter(Position=0,Mandatory=$true)][String]$WorkLocation,[Parameter(Position=1,Mandatory=$true)][String]$DNSServer,[String]$SystemName="",[IPAddress]$IPAddress=$null)
+    NullVariables -ItemList 'Data','FileName','ReverseZoneInfo','Found','Record','RecordData','RecordType','RRType','Zone','ZoneName','ZoneRecord','ZoneRecords','Zones'
+    Try{
+        $Found=$false
+        [Int]$Octate1=0
+        [Int]$Octate2=0
+        [Int]$Octate3=0
+        [Int]$Octate4=0
+        For($o=0;$o-le3;$o++){
+            Switch($o){
+                "0"{[Int]$Octate1=$IPAddress.IPAddressToString.Split(".")[$o];Break}
+                "1"{[Int]$Octate2=$IPAddress.IPAddressToString.Split(".")[$o];Break}
+                "2"{[Int]$Octate3=$IPAddress.IPAddressToString.Split(".")[$o];Break}
+                "3"{[Int]$Octate4=$IPAddress.IPAddressToString.Split(".")[$o];Break}
+            }
+        }
+        $ZoneName="$Octate3.$Octate2.$Octate1.in-addr.arpa"
+        $FileName="$WorkLocation\$ZoneName.csv"
+        If(Test-Path -Path "$FileName"){
+            $ReverseZoneInfo=Import-Csv $FileName|Sort -Property HostName
+            ForEach($Record In $ReverseZoneInfo){
+                If($Record.HostName-eq$Octate4){
+                    $Octate4=$Record.HostName
+                    $RecordType=$Record.RecordType
+                    $Zones=@(Get-DnsServerZone -ComputerName $DNSServer)|Where-Object{$_.ZoneName-eq$ZoneName}|Sort -Property ZoneName
+                    ForEach($Zone In $Zones){
+                        If($Zone.ZoneName-eq$ZoneName){
+                            $ZoneRecords=$Zone|Get-DnsServerResourceRecord -ComputerName $DNSServer|Where-Object{$_.RecordType-eq"$RecordType"}
+                            ForEach($ZoneRecord In $ZoneRecords){
+                                If($ZoneRecord.HostName-eq$Octate4){
+                                    Switch($RecordType){
+                                        "PTR"{$Data="PtrDomainName";Break}
+                                        Default{$Data="";Break}
+                                    }
+                                    $RecordData=$ZoneRecord.RecordData.$Data
+                                    $Found=$true
+                                    Break
+                                }
+                            }
+                            Break
+                        }
+                    }
+                    Break
+                }
+            }
+        }
+        $ParseArray=New-Object PSObject
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $Found
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $Octate4
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "PtrDomainName" -Value $RecordData
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "ZoneName" -Value $ZoneName
+        $ParseArray|Add-Member -MemberType NoteProperty -Name "RRType" -Value $RecordType
+        Return $ParseArray
+    }Catch [Exception]{
+        $Message="Error: [Get-ReverseDnsData]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        Return $Found
+    }
+}
+Function Get-SubDomain{param([Parameter(Position=0,Mandatory=$true)][String]$NetBIOS,[Parameter(Position=1,Mandatory=$false)][IPAddress]$IPAddress=$null)
+    NullVariables -ItemList 'Campus','Left','Right','SubDomain'
+    [IPAddress]$IPv4=$null
+    [String]$SubDomain=""
+    If($IPAddress.IpAddressToString.Length-gt1){$IPv4=$IPAddress}
+    $NetBIOS=$NetBIOS.Split(".")[0]
+    If($NetBIOS.Substring(0,2)-eq"fs"){
+    }Else{
+        $Campus=@($NetBIOS.Remove(2)).ToLower()
+        If($Campus-eq"ar"-or$Campus-eq"da"-or$Campus-eq"pb"-or$Campus-eq"rg"-or$Campus-eq"ty"-or$Campus-eq"za"){
+            $Campus=$true
+            Switch($NetBIOS){
+                {($_-like"*prd*"-or$_-like"*rpt*")}{$SubDomain="prd";Break}
+                {($_-like"*uat*")}{$SubDomain="uat";Break}
+                {($_-like"*fly*"-or$_-like"*cfg*"-or$_-like"*cnv*")}{$SubDomain="fly";Break}
+                {($_-like"*trn*")}{$SubDomain="trn";Break}
+                {($_-like"*sbx*")}{$SubDomain="sbx";Break}
+                {($_-like"*tst*")}{$SubDomain="tst";Break}
+                {($_-like"*dev*")}{$SubDomain="dev";Break}
+                {($_-like"*dmo*")}{$SubDomain="dmo";Break}
+                {($_-like"*pum*")}{$SubDomain="inf";Break}
+                Default{$SubDomain="";Break}
+            }
+        }
+    }
+    If($IPv4.IpAddressToString.Length-lt1){
+    }ElseIf($SubDomain.Length-lt1){
+        $SubDomain=Get-ZoneName -Octate3 $($IPv4.IpAddressToString.Split(".")[2])
+        If(($Campus-eq$true)-and(($NetBIOS.Length-lt12)-or($NetBIOS.Length-gt12))){
+            $NetBIOS="$($Left=$NetBIOS.Substring(0,4))$SubDomain$($Right=$NetBIOS.Substring(4,5))"
+        }
+    }
+    If(($RootSystems-notcontains$NetBIOS)-and($IPv4.IpAddressToString.Length-lt1)-and($SubDomain.Length-lt1)-and($Campus-ne$true)){
+        $SubDomain="inf"
+    }
+    $ParseArray=New-Object PSObject
+    $ParseArray|Add-Member -MemberType NoteProperty -Name "SubDomain" -Value $SubDomain
+    $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $NetBIOS
+    Return $ParseArray
+}
+Function Get-SystemNetDNS{param([IPAddress]$IPAddress=$null,[String]$ComputerName=$null)
+    NullVariables -ItemList 'AddressList','LineItem','RecordData','Results','SearchType','SearchValue','SubArray','ValueCheck'
+    Try{
+        $Results=$null
+        $ValueCheck=""
+        $SearchType="IPAddress"
+        If(!$($ComputerName).Length-lt1){
+            $ValueCheck=$($ComputerName.Split(" "))
+            Switch($ValueCheck[1].Length-gt1){
+                {($_-eq$true)}{$ComputerName=$ValueCheck[1];Break}
+                Default{Break}
+            }
+            $SearchValue=$ComputerName;$SearchType="HostName"
+        }
+        If($($IPAddress.AddressFamily)-eq"InterNetwork"){$SearchValue=$IPAddress.IPAddressToString}
+        Switch($SearchType){
+            Default{$Results=[System.Net.Dns]::GetHostEntry($SearchValue);Break}
+        }
+        If($ComputerName-eq$env:COMPUTERNAME){
+            $ParseArray=New-Object PSObject
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $true
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $($Results.HostName)
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "Aliases" -Value $($Results.Aliases)
+            For($i=0;$($Results.AddressList[$i])-ne$null;$i++){
+                If($($Results.AddressList[$i].IPAddressToString)-ne"::1"){
+                    [IPAddress]$AddressList=$($Results.AddressList[$i])
+                    $SubArray=New-Object PSObject
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "Address" -Value $AddressList.Address
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "AddressFamily" -Value $AddressList.AddressFamily
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "ScopeId" -Value $AddressList.ScopeId
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Multicast" -Value $AddressList.IsIPv6Multicast
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6LinkLocal" -Value $AddressList.IsIPv6LinkLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6SiteLocal" -Value $AddressList.IsIPv6SiteLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Teredo" -Value $AddressList.IsIPv6Teredo
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv4MappedToIPv6" -Value $AddressList.IsIPv4MappedToIPv6
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IPAddressToString" -Value $AddressList.IPAddressToString
+                }
+            }
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "AddressList" -Value $SubArray
+        }Else{
+            $ParseArray=New-Object PSObject
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $true
+            ForEach($RecordData In $Results){
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $RecordData.HostName
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Aliases" -Value $RecordData.Aliases
+                [IPAddress]$AddressList=$($RecordData.AddressList.IPAddressToString)
+                $SubArray=New-Object PSObject
+                ForEach($LineItem In $AddressList){
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "Address" -Value $LineItem.Address
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "AddressFamily" -Value $LineItem.AddressFamily
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "ScopeId" -Value $LineItem.ScopeId
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Multicast" -Value $LineItem.IsIPv6Multicast
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6LinkLocal" -Value $LineItem.IsIPv6LinkLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6SiteLocal" -Value $LineItem.IsIPv6SiteLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Teredo" -Value $LineItem.IsIPv6Teredo
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv4MappedToIPv6" -Value $LineItem.IsIPv4MappedToIPv6
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IPAddressToString" -Value $LineItem.IPAddressToString
+                }
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "AddressList" -Value $SubArray
+            }
+        }
+        Return $ParseArray
+    }Catch [Exception]{
+        If($($_.Exception.Message)-eq"No such host is known"){
+        }Else{
+            $Message="Error: [Get-SystemNetDNS]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+        Return $false
+    }
+}
+Function Get-TimeDiff{param([DateTime]$StartDate,[DateTime]$EndDate)
+    $ElapsedTime=(New-TimeSpan –Start $StartDate –End $EndDate)
+    Return $($ElapsedTime)
+}
+Function Get-VMComputerData{param([IPAddress]$VCMManagerIP,[String]$VMServer,[PSCredential]$AdminAccount,[String]$FileName)
+    NullVariables -ItemList 'Connected','Error','Message','NetworkCards','NtwkCard','ReportedVM','ReportedVMs','VM','VMs'
+    Try{
+        $VCMManagerIP=$VCMManagerIP.IPAddressToString
+        Write-debug "Connecting to vCenter using '$VCMManagerIP', please wait..."
+        $Connected=Connect-VIServer -Server $VCMManagerIP -Protocol https -Credential $AdminAccount -ErrorAction SilentlyContinue
+        Trap{
+            If($Error[0].exception-like"*incorrect user name or password*"){
+                $Message="Error: [Get-VMComputerData]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+                Return $null
+            }
+        }
+        If($Connected){
+            $ReportedVMs=New-Object System.Collections.ArrayList
+            $VMs=Get-View -ViewType VirtualMachine|Sort-Object -Property{$_.Config.Hardware.Device|Where{$_-is[VMware.Vim.VirtualEthernetCard]}|Measure-Object|select -ExpandProperty Count} -Descending
+            ForEach($VM in $VMs){
+                $ReportedVM=New-Object PSObject
+                Add-Member -Inputobject $ReportedVM -MemberType noteProperty -name Guest -value $VM.Name
+                Add-Member -InputObject $ReportedVM -MemberType noteProperty -name UUID -value $($VM.Config.Uuid)
+                $NetworkCards=$VM.guest.net| ?{$_.DeviceConfigId-ne-1}
+                $i=0
+                ForEach($NtwkCard in $NetworkCards){
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.Network" -Value $NtwkCard.Network
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.MacAddress" -Value $NtwkCard.Macaddress  
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.IPAddress" -Value $($NtwkCard.IPAddress|?{$_-like"*.*"})
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.Device" -Value $(($VM.Config.Hardware.Device|?{$_.key-eq$($NtwkCard.DeviceConfigId)}).GetType().Name)
+                    $i++
+                }
+                $ReportedVMs.add($ReportedVM)|Out-Null
+            }
+            $ReportedVMs|Export-CSV $FileName -NoTypeInformation -Encoding UTF8|Out-Null
+            $Message=Set-DisplayMessage -Description "Export complete!  Safe to disconnect from '$($VMServer) [$($VCMManagerIP)]' server."
+            Disconnect-VIServer -Server $Connected -Force -Confirm
+            Return $true
+        }Else{
+            $Message=Set-DisplayMessage -Description "Error: [Get-VMComputerData]: Failed to connect to vCenter using '$VCMManagerIP'.";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+            Return $false
+        }
+    }Catch [Exception]{
+        $Message="Error: [Get-VMComputerData]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+        Return $false
+    }
+}
+Function Get-VMExportedInfo{param([String]$MacAddress,[String]$GuestName,[Int]$Site)
+    NullVariables -ItemList 'ExportVMData','Left','NetworkMAC','SiteLabel','VMAdapter','VMComputerList','VMComputerName','VMGuest','VMIPAddress','VMNetwork','VMPowerState'
+    If($Site-eq0){
+        $MacAddress=""
+        $Left=$GuestName.Length-3
+        $SiteLabel=$GuestName.Substring($Left,1)
+        Switch($SiteLabel){
+            {($_-eq"b")-or($_-eq"y")}{$Site=2;Break}
+            Default{$Site=1;Break}
+        }
+    }Else{
+        $GuestName=""
+        Switch($Site){
+            "126"{$Site=2;Break}
+            Default{$Site=1;Break}
+        }
+    }
+    $VMPowerState="Off"
+    $VMComputerName=$null
+    $ExportVMData="VMComputerData-Site$Site.csv"
+    $VMComputerList=Import-Csv $ExportVMData|Sort -Property "Guest"
+    ForEach($VMGuest In $VMComputerList){
+        $VMComputerName=$VMGuest.Guest
+        For($i=0;$i-lt1;$i++){
+            $NetworkMAC=$VMGuest.$('networkcard'+$i+'.MacAddress')
+            If(($MacAddress-eq$NetworkMAC-and$MacAddress.Length-lt1)-or($VMComputerName-like"*$GuestName*"-and$GuestName.Length-lt1)){
+                $VMComputerName=$VMGuest.Guest
+                $VMNetwork=$VMGuest.$('networkcard'+$i+'.Network').ToString()
+                $VMIPAddress=$VMGuest.$('networkcard'+$i+'.IPAddress').ToString()
+                $VMAdapter=$VMGuest.$('networkcard'+$i+'.Device').ToString()
+                If($VMNetwork-ne$VMPoweredOffState){
+                    $VMPowerState="On"
+                }
+                $ParseArray=New-Object PSObject
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $true
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $VMComputerName
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Network" -Value $VMNetwork
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "IPAddress" -Value $VMIPAddress
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Device" -Value $VMAdapter
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "State" -Value $VMPowerState
+                Return $ParseArray
+                Break
+            }
+        }
+    }
+    Return $false
+}
+Function Get-ZoneName{param([Int]$Octate3)
+    Switch($Octate3){
+        {($_-eq0)-or($_-eq1)}{$SubDomain="inf";Break}
+        {($_-eq2)}{$SubDomain="mgt";Break}
+        {($_-ge4-and$_-le7)-or($_-ge20-and$_-le23)-or($_-ge36-and$_-le39)-or($_-ge52-and$_-le55)-or($_-ge68-and$_-le712)-or($_-ge84-and$_-le87)}{$SubDomain="prd";Break}
+        {($_-eq8)-or($_-eq24)-or($_-eq40)-or($_-eq56)-or($_-eq72)-or($_-eq88)}{$SubDomain="uat";Break}
+        {($_-eq9)-or($_-eq25)-or($_-eq41)-or($_-eq57)-or($_-eq73)-or($_-eq89)}{$SubDomain="fly";Break}
+        {($_-eq10)-or($_-eq26)-or($_-eq42)-or($_-eq58)-or($_-eq74)-or($_-eq90)}{$SubDomain="trn";Break}
+        {($_-eq11)-or($_-eq27)-or($_-eq43)-or($_-eq59)-or($_-eq75)-or($_-eq91)}{$SubDomain="sbx";Break}
+        {($_-eq12)-or($_-eq28)-or($_-eq44)-or($_-eq60)-or($_-eq76)-or($_-eq92)}{$SubDomain="tst";Break}
+        {($_-eq13)-or($_-eq29)-or($_-eq45)-or($_-eq61)-or($_-eq77)-or($_-eq93)}{$SubDomain="dev";Break}
+        {($_-eq14)-or($_-eq30)-or($_-eq46)-or($_-eq62)-or($_-eq78)-or($_-eq94)}{$SubDomain="dmo";Break}
+        {($_-eq18)-or($_-eq19)}{$SubDomain="vdi";Break}
+        {($_-eq64)-or($_-eq65)}{$SubDomain="bkp";Break}
+        Default{$SubDomain="all";Break}
+    }
+    Return $SubDomain
+}
+Function NullVariables{param([Parameter(Position=0,Mandatory=$true)]$ItemList=@())
+    Try{
+        ForEach($Item In $ItemList){
+            If($Item.Length-lt1){
+            }Else{
+                Clear-Variable -Name "$Item" -Scope Global -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }Catch [Exception]{
+        If($_.Exception.Message-eq"Cannot find a variable with the name '$Item'."){
+        }Else{
+            $Message="Error: [NullVariables]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+        }
+    }
+}
+Function Set-DisplayMessage{param([String]$Description,[String]$StatusMessage,$FontColor="Yellow",$Background="Black",$RightJustified=$true)
+    NullVariables -ItemList 'Height','Left','Message','Right','RightAlign','Width','WindowSize'
+    [Int]$RightAlign=$Buffer.Width
+    [Int]$WindowSize=$($RightAlign-$($Description.Length+1+$StatusMessage.Length+1))
+    If($Buffer.Width-le$WindowSize){
+        $Width=$WindowSize
+        For($Height=0;$Buffer.Width-le$Width;$Height++){
+            $Width=$Width-$Buffer.Width
+        }
+        $Buffer.Height=$Height
+        $WindowSize=$Width
+    }
+    If($RightJustified-eq$true){
+        For($Left=0;$Left-lt$WindowSize;$Left++){
+            $Description=" "+$Description
+        }
+    }ElseIf($RightJustified-eq$false){
+        For($Right=0;$Right-lt$WindowSize;$Right++){
+            $Description=$Description+" "
+        }
+    }ElseIf($StatusMessage.Length-gt0-or($Description.Length-lt1-and$StatusMessage.Length-lt1)){
+        For($Left=0;$Left-lt$WindowSize;$Left++){
+            $StatusMessage=$StatusMessage+" "
+        }
+    }
+    [String]$Message=$Description
+    If($FontColor[1].Length-gt1){
+        Write-Color "$Message"," $StatusMessage" -Color $FontColor[0],$FontColor[1]
+    }Else{
+        Write-Host $Message,$StatusMessage -ForegroundColor $FontColor -BackgroundColor $Background
+    }
+    If($Background-eq"DarkRed"){
+        Add-Content -Path $ResultFile -Value $($Message.Trim()) -PassThru
+    }
+}
+Function UnloadPowerCli{
+    $VMLoadOrder=@('VMware.VimAutomation.Core','VMware.VimAutomation.Vds','VMware.VimAutomation.Cloud','VMware.VimAutomation.PCloud','VMware.VimAutomation.Cis.Core','VMware.VimAutomation.Storage','VMware.VimAutomation.HorizonView','VMware.VimAutomation.HA','VMware.VimAutomation.vROps','VMware.VumAutomation','VMware.DeployAutomation','VMware.ImageBuilder','VMware.VimAutomation.License')
+    ForEach($ModuleName In $VMLoadOrder){
+        Remove-Module -Name $ModuleName -Force
+    }
+    $ListModules=Get-Module|Where-Object{$_.Name-like"*VMware*"}
+    ForEach($ModuleName In $ListModules){
+        Remove-Module -Name $ModuleName
+    }
+}
+Function Verify-IPAddress{[CmdletBinding()][Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true,Position=0)][ValidateScript({$_ -match [IPAddress]$_ })]
+Param([String]$IPAddress)
+    Begin{}
+    Process{
+        Try{
+            [IPAddress]$IPAddress
+        }Catch [Exception]{
+            $Message="Error: [Set-DisplayMessage]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+            Return $false
+        }
+    }
+    End{}
+}
+Add-StartupVariables -Location AllUsersAllHosts
+$Buffer=(Get-Host).UI.RawUI.BufferSize
+# Retrieving the Starting Date for calculating the computer password age from computer in the AD Export. #
+$ResetDate=(Get-Date).toString('M/d/yyyy')
+$ResetDate=[DateTime]::ParseExact($ResetDate,'M/d/yyyy',$null)
+$StartTime=(Get-Date).toString('yyyy/M/d H:mm:ss')
+$StartTime=[DateTime]::ParseExact($StartTime,'yyyy/M/d H:mm:ss',$null)
+Set-Location -Path "$($env:USERProfile)\Documents"
+Set-Variable -Name "AuthUser" -Value "bstobie@utsystem.edu"
+Set-Variable -Name "WorkingPath" -Value "$env:USERProfile\Documents\Passwords"
+Set-Variable -Name "SecureFile" -Value "$WorkingPath\Encrypted.pwd"
+$SearchDomain=$env:USERDNSDOMAIN.ToLower()
+$ResultFile="Results.log"
+$RootSystems="w16arootca01"
+$Encrypted=""
+$Site=0
+[Int]$i=0
+[Int]$Sites=2
+[Int]$Octate1=0
+[Int]$Octate2=0
+[Int]$Octate3=0
+[Int]$Octate4=0
+[Int]$NotLoggedOn=0
+[Int]$BadComputer=0
+[Int]$BadIPAddress=0
+[Int]$StaleConnection=0
+[Int]$ActiveConnection=0
+NullVariables -ItemList 'Encrypted'
+Do{
+    $i++
+    Switch($i){
+        "1"{$Prompt="Enter your search domain: [$SearchDomain]";Break}
+        Default{$Prompt="Enter the FQDN, please";Break}
+    }
+    $SearchDomain=Read-Host -Prompt $Prompt
+    If($SearchDomain.Length-lt1){$SearchDomain=$env:USERDNSDOMAIN}
+    $SearchDomain=$SearchDomain.ToLower()
+}Until($SearchDomain-like'*.*')
+NullVariables -ItemList 'i','Prompt'
+$UserDomain=$SearchDomain.Split(".")[0].ToUpper()
+$UserName=Read-Host -Prompt "Enter your credentials: [$env:USERNAME]"
+If($UserName.Length-lt1){
+    $UserName=$env:USERNAME
+}Else{
+    If($UserName-like"*\*"){
+        $UserDomain=$($UserName.Split("\")[0]).ToLower()
+        $UserName=$($UserName.Split("\")[1])
+    }
+}
+$UserName=$UserName.ToLower()
+$AuthUser=$UserDomain+"\"+$UserName
+# Retrieve and encrypt the users password to use when credentials are required to access network resources. #
+$SecureString=Read-Host -Prompt "Enter your [$AuthUser] credentials" -AsSecureString
+$BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+$Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+If($Encrypted.Length-lt1){
+    Set-Variable -Name "EncryptionKeyFile" -Value ""
+    Set-Variable -Name "Characters" -Value ""
+    Set-Variable -Name "PrivateKey" -Value ""
+    Set-Variable -Name "SecureKey" -Value ""
+    [String]$Key=0
+    [Int]$Min=8
+    [Int]$Max=1024
+    $Prompt="Enter the length you want to use for the security key: [up to 16 bytes]"
+    If($Prompt.Length-eq0){$Prompt=8}
+    [Int]$RandomKey=Read-Host -Prompt $Prompt
+    If(Test-Path $WorkingPath){
+        $Results=Get-ChildItem -Path $WorkingPath -File
+        ForEach($File In $Results){
+            $FileName=$($File.Name).Split(".")[0]
+            If($FileName.length-eq$RandomKey){
+                $KeyFile="$($File.Name)"
+                $Key=$($KeyFile).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                    $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                    Break
+                }
+            }
+        }
+    }Else{
+        $Dir=MkDir $WorkingPath
+    }
+    If($PrivateKey.length-lt1){
+        Do{
+            Switch($RandomKey){
+                {($_-eq8)}{
+                    $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    Break
+                }
+                {($_-eq12)}{
+                    $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    Break
+                }
+                {($_-eq16)}{
+                    $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    Break
+                }
+                {($Key.length-lt$RandomKey)}{
+                    $RandomKey+=1
+                    Break
+                }
+                {($Key.length-gt$RandomKey)}{
+                    $RandomKey-=1
+                    Break
+                }
+                Default{
+                    $RandomKey=16
+                    Break
+                }
+            }
+        }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+        $i=0
+        Do{
+            $i++
+            If(Test-Path -Path $SecureFile){
+                $SecureFile="$WorkingPath\Encrypted$i.pwd"
+            }
+        }While((Test-Path -Path $SecureFile)-eq$true)
+        $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+        Do{
+            [Int]$Characters=Read-Host -Prompt $Prompt
+            If(($Characters-ge$Min)-and($Characters-le$Max)){
+            }Else{
+                $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+            }
+        }Until(($Characters-ge$Min)-and($Characters-le$Max))
+        For($i=0;$i-le$Characters;$i++){
+            Switch($i){
+                {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                Default{$PrivateKey="";$Set="";Break}
+            }
+            $PrivateKey+=$Set
+        }
+        Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+        Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+        $Validate=Unprotect-String $PrivateKey $Key
+        If($Validate-ne$false){
+            $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        }
+        $SecureString=Read-Host -Prompt "Enter your [$AuthUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+    }
+    Try{
+        $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }Catch [Exception]{
+        $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+    }
+}
+$PassCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $AuthUser,$SecureString
+ClearVariables -VariableList 'AuthUser','BSTR','Characters','Encrypted','EncryptedString','EncryptionKeyFile','File','FileName','i','Key','Max','Message','Min','PrivateKey','Prompt','RandomKey','Results','SecureFile','SecureKey','SecureString','Set','Validate','WorkingPath'
+[Int]$i=0
+Do{
+    $i++
+    Switch($i){
+        "1"{$Prompt="Enter the name a domain controller for $($SearchDomain): [dca01]";Break}
+        Default{$DCServerName="dca01";Break}
+    }
+    $DCServerName=Read-Host -Prompt $Prompt
+    If($DCServerName.Length-lt1){$DCServerName="dca01."+$SearchDomain}
+}Until($DCServerName-like'*.*')
+NullVariables -ItemList 'i','Prompt'
+[Int]$Counter=0
+$VMServerIP=[System.Collections.ArrayList]@(0)
+Do{
+    $Counter++
+    Switch($Counter){
+        "1"{$Prompt="Enter the IP Address of the Virtual Platform management server: [10.118.0.4]";Break}
+        Default{$Prompt="Please enter a valid IP Address: [10.118.0.4]";Break}
+    }
+    $VMServerIP[0]=Read-Host -Prompt $Prompt
+    If($VMServerIP[0].Length-lt1){$VMServerIP[0]="10.118.0.4"}
+    $Results=Verify-IPAddress $VMServerIP[0]
+    If($Results-eq$false){$VMServerIP[0]=-1}
+}Until($VMServerIP[0]-gt0)
+NullVariables -ItemList 'Counter','i','Prompt','Results'
+$ValidCredentials=$true
+# Loading PowerCLI Modules for VMWare connection. #
+# Loading PowerCLI Modules for VMWare connection. #
+<#$ValidCredentials=$false
+Do{
+    [String]$CurrentIP=""
+    If($VMServerIP-like"*,*"){
+        $CurrentIP=$VMServerIP.ToString().Split(",")[$Site]
+    }Else{
+        $CurrentIP=$VMServerIP
+    }
+    For($o=0;$o-le3;$o++){
+        Switch($o){
+            "0"{[Int]$Octate1=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+            "1"{[Int]$Octate2=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+            "2"{[Int]$Octate3=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+            "3"{[Int]$Octate4=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+        }
+    }
+    If($Octate2-eq118){
+        $Octate2=126
+    }
+    $Site++
+    $ExportVMData="VMComputerData-Site$Site.csv"
+    If(Test-Path -Path $ExportVMData){Remove-Item -Path $ExportVMData}
+    $Results=Get-SystemNetDNS -IPAddress $CurrentIP
+    NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+    If($Results.Found-eq$true){
+        $VMServerDNS=$Results.HostName
+    }
+    For($l=0;$l-lt2;$l++){
+        Switch($l){
+            "1"{$Message="Beginning to export the current state of VMs to '$WorkingPath\$ExportVMData'.  Please wait, this export could take upto a few minutes to complete.";Break}
+            Default{$Message="";Break}
+        }
+        $Message=Set-DisplayMessage -Description $Message -FontColor White -Background Black -RightJustified $false
+    }
+    $Results=Get-VMComputerData -VCMManagerIP $CurrentIP -VMServer $VMServerDNS -AdminAccount $PassCredentials -FileName $ExportVMData
+    If($Results-eq$true){
+        $Results="Successfully completed exporting the current state of Virtual Machine's from '$VMServerDNS'.",'White','Black'
+        $ValidCredentials=$true
+    }ElseIf($Results-eq$false){
+        $Results="Wasn't able to retrieve the current state of Virtual Machine's from '$CurrentIP'.",'Yellow','DarkRed'
+    }Else{
+        Break
+    }
+    For($l=0;$l-le2;$l++){
+        Switch($l){
+            "1"{$Message=$Results[0],$Results[1],$Results[2];Break}
+            Default{$Message="","Yellow","Black";Break}
+        }
+        $Message=Set-DisplayMessage -Description $Message[0] -FontColor $Message[1] -Background $Message[2] -RightJustified $false
+    }
+    $VMServerIP="$VMServerIP,$Octate1.$Octate2.$Octate3.$Octate4"
+}While($Site-lt$Sites)#>
+# Loading PowerCLI Modules for VMWare connection. #
+# Loading PowerCLI Modules for VMWare connection. #
+NullVariables -ItemList 'CurrentIP','ExportVMData','l','Message','o','Octate1','Octate2','Octate3','Octate4','Prompt','Results','Site','Sites','VMServerDNS','VMServerIP'
+If($ValidCredentials-eq$true){
+    [String]$VMPoweredOffState="4f f8 01 50 ed 0b 98 8c-7a 70 b6 ff 16 54 8e d1"
+    $DCServerName=$DCServerName.Split(".")[0].ToLower()
+    $ExportFile="ExportList-$DCServerName.csv"
+    $DCServerName=$DCServerName+"."+$SearchDomain
+    $FilterBy='ObjectClass -eq "Computer"'
+    $StartVariables="StartVariablesList.csv"
+    $FinishVariables="FinishVariablesList.csv"
+    If(Test-Path -Path $ResultFile){Remove-Item -Path $ResultFile}
+    $Message=Set-DisplayMessage -Description "" -RightJustified $false
+    $Message=Set-DisplayMessage -Description "Retrieving list of domain computers for the '$SearchDomain' domain from $DCServerName, and exporting list of domain computers to '$WorkingPath\$ExportFile'." -FontColor White -RightJustified $false
+    $AdHeader='Name','LastLogonDate','PasswordLastSet','PasswordExpired','OperatingSystem','IPv4Address','DNSHostName','DistinguishedName','CanonicalName','whenChanged','whenCreated','LockedOut'
+    <# Beginning process of validating the computers from the AD Export against the Forward and Reverse Zones in DNS. #>
+    If(Test-Path -Path $ExportFile){Remove-Item -Path $ExportFile}
+    Get-ADComputer -Credential $PassCredentials -Server $DCServerName -Filter $FilterBy -Property $AdHeader|Select-Object $AdHeader|Sort-Object -Property Name|Export-CSV $ExportFile -NoTypeInformation -Encoding UTF8
+    If(Test-Path -Path $ExportFile){
+        $Message=Set-DisplayMessage -Description "Completed export of domain computers to '$ExportFile'." -FontColor Yellow -Background Black
+        For($i=0;$i-lt2;$i++){
+            $Message=Set-DisplayMessage -Description ""
+        }
+        $Message=Set-DisplayMessage -Description "Adding exported list of domain computers to memory.  Searching for other Domain Controllers..." -FontColor White -RightJustified $false
+        NullVariables -ItemList 'FocusDC','i','Message'
+        [Int]$Counter=0
+        $ZoneCount=0
+        $ComputerList=Import-Csv $ExportFile|Sort-Object Name
+        ForEach($Computer In $ComputerList){
+            If($Computer.CanonicalName-like"*Domain Controller*"){
+                If(($Computer.DNSHostName).ToLower()-eq$DCServerName){
+                    $RootSystems+=",$($Computer.Name.ToLower())"
+                    [String]$FocusDC=$DCServerName
+                    $ValidDCName=$true
+                }Else{
+                    $Counter++
+                    $RootSystems+=",$($Computer.Name.ToLower())"
+                    Switch($Counter){
+                        "1"{$DCList=($Computer.DNSHostName).ToLower();Break}
+                        Default{$DCList=$DCList+","+($Computer.DNSHostName).ToLower();Break}
+                    }
+                }
+            }
+        }
+        NullVariables -ItemList 'Computer','ComputerList'
+        If($ValidDCName-eq$true){
+            $ADServerList=[System.Collections.ArrayList]@(0..$Counter)
+            $Message=Set-DisplayMessage -Description ""
+            NullVariables -ItemList 'DCArray'
+            For($i=0;$i-lt$Counter;$i++){
+                $DC=$DCList.Split(",")[$i]
+                If($i-eq0){
+                    $DCArray=[System.Collections.ArrayList]@($FocusDC,$DC)
+                }Else{
+                    $DCArray+=[System.Collections.ArrayList]@(,$DC)
+                }
+                $DC=$DC.Replace("'","")
+                $NewDC=$DC.Split(".")[0]
+                $FileName=$ExportFile.Replace($FocusDC.Split(".")[0],$NewDC)
+                $Message=Set-DisplayMessage -Description "Retrieving list of domain computers from $NewDC.$SearchDomain and exporting list of domain computers to '$WorkingPath\$FileName'." -FontColor White -RightJustified $false
+                If(Test-Path -Path $FileName){Remove-Item -Path $FileName}
+                Get-ADComputer -Credential $PassCredentials -Server $DC -Filter $FilterBy -Property $AdHeader|Select-Object $AdHeader|Export-CSV $FileName -NoTypeInformation -Encoding UTF8
+                $Message=Set-DisplayMessage -Description "Completed export of domain computers to '$FileName'." -FontColor Yellow -Background Black
+                $ADServerList[$i]=Import-Csv $FileName
+                $ADServerList[$i]=$FileName,$ADServerList[$i]
+                For($j=0;$j-lt2;$j++){
+                    $Message=Set-DisplayMessage -Description ""
+                }
+            }
+            NullVariables -ItemList 'AdHeader','Counter','DC','DCList','DCServerName','FileName','i','j','Message','NewDC'
+            $DnsHeader='HostName','RecordType','Type','TimeStamp','TimeToLive','RecordData'
+            $Zones=@(Get-DnsServerZone -ComputerName $FocusDC)
+            $Message=Set-DisplayMessage -Description "Retrieving list of Forward and Reserve Zones from $FocusDC and exporting list to '$WorkingPath'." -FontColor White -RightJustified $false
+            ForEach($Zone In $Zones){
+	            $ZoneExport="$($Zone.ZoneName)"
+                If($ZoneExport.Substring(0,1)-eq"_"){
+                }Else{
+                    $ZoneExport="$WorkingPath\$($ZoneExport).csv"
+                    If(Test-Path -Path $ZoneExport){Remove-Item -Path $ZoneExport}
+                    If($ZoneExport-like"*$SearchDomain*"){
+	                    $Results=$Zone|Get-DnsServerResourceRecord -ComputerName $FocusDC|Where-Object{$_.RecordType-eq"A"}
+                        $Results|Select-Object $DnsHeader|Export-CSV $ZoneExport -NoTypeInformation -Encoding UTF8
+                        $ZoneCount++
+                    }ElseIf($ZoneExport-notlike"*$SearchDomain*"-and($ZoneExport-like"*11?.10*"-or$ZoneExport-like"*12?.10*")){
+	                    $Results=$Zone|Get-DnsServerResourceRecord -ComputerName $FocusDC|Where-Object{$_.RecordType-eq"PTR"}
+                        $Results|Select-Object $DnsHeader|Export-CSV $ZoneExport -NoTypeInformation -Encoding UTF8
+                        $ZoneCount++
+                    }
+                }
+            }
+            NullVariables -ItemList 'Headers','Message','Results','Zone','ZoneExport','Zones'
+            $Message=Set-DisplayMessage -Description "Completed exporting [$ZoneCount] lists of Forward and Reserve Zones for '$SearchDomain'." -FontColor Yellow -Background Black
+            For($j=0;$j-lt2;$j++){
+                $Message=Set-DisplayMessage -Description ""
+            }
+            NullVariables -ItemList 'j','Message','ZoneCount'
+        }
+        NullVariables -ItemList 'ValidDCName'
+        Clear-Host
+        $ComputerList=Import-Csv $ExportFile|Sort-Object Name
+        ForEach($Computer In $ComputerList){
+            NullVariables -ItemList 'Active','AddressList','ADHostName','Aliases','ForwardDNS','ResolvedIP','MatchIP','Message1','Message2','NetBIOS','OS','ResolvedDNS','Results','SubDomain'
+            [Int]$DaysPast=0
+            [Int]$DaysLogon=0
+            [Boolean]$MissingDNS=$false
+            [Boolean]$InvalidFQDN=$false
+            [Boolean]$MissingDate=$false
+            [Boolean]$InvalidIPAddress=$false
+            [Boolean]$MissingIPAddress=$false
+            $NetBIOS=$($Computer.Name).ToLower()
+            $OS=$($Computer.OperatingSystem).ToLower()
+            If(($OS-eq"Windows 8.1 Enterprise")-or($OS-eq"Windows 10 Enterprise")){
+            }ElseIf($RootSystems-like"*$NetBIOS*"){
+            }Else{
+                <# Beginning to process the computers in the AD Export to see if they are active or stale. #>
+                $ADHostName=$($Computer.Name).ToUpper()
+                For($l=0;$l-lt2;$l++){
+                    Switch($l){
+                        "1"{$Message1="Beginning to process information for";$Message2="'$ADHostName'";Break}
+                        Default{$Message1="";$Message2="";Break}
+                    }
+                    $Message=Set-DisplayMessage -Description $Message1 -StatusMessage $Message2 -FontColor White,Yellow -Background Black -RightJustified $null
+                }
+                NullVariables -ItemList 'l','Message','Message1','Message2'
+                $DateChanged=(@($($Computer.whenChanged).Split(" "))[0])
+                $DateCreated=(@($($Computer.whenCreated).Split(" "))[0])
+                $DateLastSet=(@($($Computer.PasswordLastSet).Split(" "))[0])
+                $DateLogonDate=(@($($Computer.LastLogonDate).Split(" "))[0])
+                If($($DateLogonDate).Length-lt1){
+                    $DateLogonDate=$DateCreated
+                    $MissingDate=$true
+                }
+                <# Checking the computer password age and last logon date to the domain. #>
+                $Counter=0
+                $Active=$false
+                $DaysPast=Get-DateDiff -StartDate $ResetDate -EndDate $DateLastSet
+                $DaysLogon=Get-DateDiff -StartDate $ResetDate -EndDate $DateLogonDate
+                ForEach($CurrentDC In $DCArray){
+                    If((($DaysPast-le30-and$DaysPast-ge0)-or($DaysLogon-le30-and$DaysLogon-ge0))-and($CurrentDC-eq$FocusDC)){
+                        $Active=$true
+                        $Message=Set-DisplayMessage -Description "$ADHostName changed it's password and/or logged into the '$SearchDomain' domain within 30 days" -FontColor Cyan -Background DarkBlue
+                        Break
+                    }Else{
+                        ForEach($CN In $($ADServerList[$Counter])[1]){
+                            If($CN.Name-eq$ADHostName){
+                                $DaysPast=Get-DateDiff -StartDate $ResetDate -EndDate $DateLastSet
+                                If($($CN.LastLogonDate).Lenght-lt1){
+                                    $DaysLogon=Get-DateDiff -StartDate $ResetDate -EndDate $DateLogonDate
+                                    If((0-lt$DaysPast)-or(0-lt$DaysLogon)){
+                                        $Message=Set-DisplayMessage -Description "$ADHostName changed it's password and/or logged into the '$SearchDomain' domain within 30 days" -FontColor Yellow -Background DarkBlue
+                                        $Active=$true
+                                        Break
+                                    }
+                                }
+                                Break
+                            }
+                        }
+                        $Counter++
+                    }
+                }
+                NullVariables -ItemList 'CN','Counter','CurrentDC','DaysLogon','DaysPast','DCArray'.'ADServerList'
+                If($Active-eq$false){
+                    $Message=Set-DisplayMessage -Description "$ADHostName last logon: '$($Computer.LastLogonDate)' and password was set on: '$($Computer.PasswordLastSet)'" -Background DarkRed
+                    $ADHostName|%{Get-ADComputer -Filter {Name -eq $_}}|Remove-ADObject -WhatIf
+                    $Results=Get-SystemNetDNS -ComputerName $Computer.Name
+                    NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+                    If($Results.Found-eq$true){
+                        If($Computer.IPv4Address.Length-gt1){
+                            [IPAddress]$AddressList=$Computer.IPv4Address
+                        }Else{
+                            [IPAddress]$AddressList=$null
+                        }
+                        $Results=Get-ForwardDnsData -WorkLocation $WorkingPath -DNSServer $FocusDC -SystemName $Computer.Name -IPAddress $AddressList
+                        NullVariables -ItemList 'Data','FileName','ForwardZoneInfo','Found','Record','RecordType','RRType','SubDomain','Zone','ZoneName','ZoneRecord','ZoneRecords','Zones'
+                        If($Results.Found-eq$true){
+                            $RRType=$Results.RRType
+                            $ZoneName=$Results.ZoneName
+                            $NetBIOS=$Results.HostName
+                            $IPv4Address=$Results.AddressList.IPAddressToString
+                            Remove-DnsServerResourceRecord -ZoneName "$ZoneName" -ComputerName $FocusDC -RRType "$RRType" -Name "$NetBIOS" -RecordData "$IPv4Address" -WhatIf
+                            NullVariables -ItemList 'IPv4Address','NetBIOS','RRType','ZoneName'
+                        }
+                    }
+                    If($Computer.IPv4Address.Length-gt1){
+                        $Results=Get-ReverseDnsData -WorkLocation $WorkingPath -DNSServer $FocusDC -SystemName $Computer.Name -IPAddress $Computer.IPv4Address
+                        NullVariables -ItemList 'Data','FileName','ReverseZoneInfo','Found','Record','RecordData','RecordType','RRType','Zone','ZoneName','ZoneRecord','ZoneRecords','Zones'
+                        If($Results.Found-eq$true){
+                            $RRType=$Results.RRType
+                            $ZoneName=$Results.ZoneName
+                            $Octate4=$Results.HostName
+                            $RecordData=$Results.PtrDomainName
+                            Remove-DnsServerResourceRecord -ZoneName "$ZoneName" -ComputerName $FocusDC -RRType "$RRType" -Name "$Octate4" -RecordData "$RecordData" -WhatIf
+                            NullVariables -ItemList 'ReverseDNS','Octate4','RRType','ZoneName'
+                        }
+                    }
+                }Else{
+                    <# Retrieving the Forward Lookup information of each system from DNS. #>
+                    $Results=Get-SystemNetDNS -ComputerName $Computer.Name
+                    NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+                    If($Results.Found-eq$true){
+                        $ForwardDNS=$Results.HostName
+                        $Aliases=$Results.Aliases
+                        [IPAddress]$AddressList=$Results.AddressList.IPAddressToString
+                        $Results=Get-ForwardDnsData -WorkLocation $WorkingPath -DNSServer $FocusDC -SystemName $Computer.Name -IPAddress $($AddressList.IPAddressToString)
+                        NullVariables -ItemList 'Data','FileName','ForwardZoneInfo','Found','Record','RecordType','SubArray','SubDomain','Zone','ZoneName','ZoneRecord','ZoneRecords','Zones'
+                        If($Results.Found-eq$true){
+                            $Message=Set-DisplayMessage -Description "The hostname '$($Results.HostName.ToLower())' has return the IP Address '$($Results.AddressList.IPAddressToString)' as it's Forward Lookup record." -FontColor Cyan -Background DarkBlue
+                        }Else{
+                            $Message=Set-DisplayMessage -Description "Didn't find the Forward Lookup record for '$($Results.HostName.ToLower())'." -FontColor Yellow -Background DarkRed
+                        }
+                    }Else{
+                        <# Check the exported DNS Records for the system using available information. #>
+                        $Message=Set-DisplayMessage -Description "Didn't find the Forward Lookup record for '$($Computer.Name.ToLower())'." -FontColor Cyan -Background DarkRed
+                        If($Computer.IPv4Address.Length-gt1){
+                            [IPAddress]$AddressList=$Computer.IPv4Address.IPAddressToString
+                        }Else{
+                            $Message=Set-DisplayMessage -Description "Didn't find the Reverse Lookup record for '$($Computer.Name.ToLower())'." -FontColor Cyan -Background DarkRed
+                            $MissingIPAddress=$true
+                            $AddressList=$null
+                        }
+                        $Results=Get-ForwardDnsData -WorkLocation $WorkingPath -DNSServer $FocusDC -SystemName $Computer.Name -IPAddress $AddressList
+                        NullVariables -ItemList 'Data','FileName','ForwardZoneInfo','Found','Record','RecordType','SubArray','SubDomain','Zone','ZoneName','ZoneRecord','ZoneRecords','Zones'
+                        If($Results.Found-eq$true){
+                            [IPAddress]$AddressList=$Results.AddressList.IPAddressToString
+                            If($($Results.AddressList.IPAddressToString).length-gt1){
+                                $MatchIP=$false
+                                $Results=Get-SystemNetDNS -IPAddress $AddressList.IPAddressToString
+                                NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+                                If($Results.Found-eq$true){
+                                    If($($Computer.Name).Substring(0,2)-eq"fs"){
+                                        ForEach($CurrentIP In $($Results).AddressList.IPAddressToString){
+                                            If($AddressList.IPAddressToString-eq$CurrentIP){$MatchIP=$true;Break}
+                                        }
+                                    }ElseIf($AddressList.IPAddressToString-eq$Results.AddressList.IPAddressToString){
+                                        $Message=Set-DisplayMessage -Description "The hostname '$($Results.HostName.ToLower())' has return the IP Address '$($Results.AddressList.IPAddressToString)' as it's Forward Lookup record." -FontColor Cyan -Background DarkBlue
+                                        $MatchIP=$true
+                                    }
+                                    If($MatchIP-eq$true){
+                                        $ForwardDNS=$($Results).HostName.Split(".")[0]
+                                        $Aliases=$Results.Aliases
+                                    }
+                                }
+                            }
+                        }Else{
+                            $MissingIPAddress=$true
+                            If($($Computer.DNSHostName).Split(".")[1]-ne$UserDomain){
+                                $Results=$($Computer.DNSHostName.Split(".")[1]),$Computer.Name.ToLower()
+                                $ForwardDNS="$($Results[1].SubString(0,4))$($Results[0])$($Results[1].Remove(0,4))"
+                                $Results=Get-SystemNetDNS -ComputerName $ForwardDNS
+                                NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+                                If($Results.Found-eq$true){
+                                    $ForwardDNS=$Results.HostName
+                                    $Aliases=$Results.Aliases
+                                    [IPAddress]$AddressList=$Results.AddressList.IPAddressToString
+                                    $Message=Set-DisplayMessage -Description "The hostname '$($Results.HostName.ToLower())' has return the IP Address '$($Results.AddressList.IPAddressToString)' as it's Forward Lookup record." -FontColor Cyan -Background DarkBlue
+                                }Else{
+                                    $Message=Set-DisplayMessage -Description "The hostname '$($ForwardDNS.ToLower())' isn't returning a Forward Lookup record." -FontColor Cyan -Background DarkRed
+                                }
+                            }
+
+                        }
+                    }
+                    NullVariables -ItemList 'CurrentIP','MatchIP','Message','Results'
+                    <# Retrieving the Reverse Lookup information of each system from DNS. #>
+                    If($Computer.IPv4Address.Length-lt1){
+                        [IPAddress]$ResolvedIP=$AddressList.IPAddressToString
+                        $MissingIPAddress=$true
+                    }Else{
+                        <# Comparing the IP Address from DNS against the data from the AD Export. #>
+                        If($Computer.IPv4Address-eq$AddressList.IPAddressToString){
+                            [IPAddress]$ResolvedIP=$Computer.IPv4Address
+                        }Else{
+                            $InvalidIPAddress=$true
+                            $Results=Get-SubDomain -NetBIOS $($Computer.Name).ToLower() -IPAddress $AddressList.IPAddressToString
+                            NullVariables -ItemList 'Campus','Left','Right','SubDomain'
+                            $SubDomain=$Results.SubDomain
+                        }
+                        <# Verify that system is configured for the correct Reverse Lookup Zone. #>
+                    }
+                    If($($ResolvedIP.IPAddressToString).length-gt1){
+                        $Results=Get-SystemNetDNS -IPAddress $ResolvedIP
+                        NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+                        If($Results.Found-eq$true){
+                            $ReverseDNS=$Results.HostName
+                            $Aliases=$Results.Aliases
+                            [IPAddress]$AddressList=$Results.AddressList.IPAddressToString
+                        }
+                    }
+                    If($Computer.DNSHostName.Length-lt1){
+                        $ResolvedDNS=$ReverseDNS
+                        $MissingDNS=$true
+                    }Else{
+                        <# Comparing the FQDN from DNS against the data from the AD Export. #>
+                        If($Computer.DNSHostName-eq$ReverseDNS){
+                            $ResolvedDNS=$Computer.DNSHostName
+                        }Else{
+                            $InvalidFQDN=$true
+                            If($ForwardDNS.Length-lt1){$ForwardDNS=$Computer.Name.ToLower()}
+                            $Results=Get-SubDomain -NetBIOS $ForwardDNS
+                            NullVariables -ItemList 'Campus','Left','Right','SubDomain'
+                            $SubDomain=$Results.SubDomain
+                            $ResolvedDNS="$($Results.HostName).$SubDomain.$SearchDomain"
+                        }
+                        <# Verify that system is configured for the correct Forward Lookup Zone. #>
+                    }
+                    NullVariables -ItemList 'AddressList','Aliases','ForwardDNS','IPAddress','ResolvedDNS','ResolvedIP','ReverseDNS','SubDomain'
+                    If(($MissingIPAddress-eq$true)-or($InvalidIPAddress-eq$true)){
+#                        Add-DnsServerResourceRecordPtr -ComputerName "$FocusDC" -Name "$ResolvedIP" -ZoneName "$ZoneName" -AllowUpdateAny -TimeToLive 00:05:00 -AgeRecord -PtrDomainName "$ModifiedDNS" -WhatIf
+                        $BadIPAddress++
+                    }
+                    If(($MissingDNS-eq$true)-or($InvalidFQDN-eq$true)){
+#                        Add-DnsServerResourceRecordA -ComputerName "$FocusDC" -Name "$ResolvedIP" -ZoneName "$ZoneName" -AllowUpdateAny -IPv4Address "$ResolvedIP" -TimeToLive 00:05:00 -WhatIf
+#                        Set-ADComputer -Identity $Computer.Name -DNSHostName "$ResolvedName" -WhatIf
+                        $BadComputer++
+                    }
+                }
+                NullVariables -ItemList 'ADHostName','Message'
+                <# Separating the list into active and stale computers for a running count. #>
+                If($Active-eq$true){
+                    $ActiveConnection++
+                }Else{
+                    $StaleConnection++
+                }
+                If($MissingDate-eq$true){
+                    $NotLoggedOn++
+                }
+                For($l=0;$l-lt3;$l++){
+                    $Message=Set-DisplayMessage -Description "" -Background Black
+                }
+                NullVariables -ItemList 'Active','DateChanged','DateCreated','DateLastSet','DateLogonDate','DaysLogon','DaysPast','l','Message'
+            }
+        }
+        NullVariables -ItemList 'Computer','ComputerList','NetBIOS','OS','RootSystems','Computer','ComputerList','DaysLogon','DaysPast','NetBIOS','OS','RootSystems'
+    }Else{
+        $Message=Set-DisplayMessage -Description "The AD-Export file is missing!" -StatusMessage "Not able to process file: '$ExportFile'" -FontColor Yellow -Background DarkRed
+    }
+    NullVariables -ItemList 'ExportFile','Message'
+    $Zones=@(Get-DnsServerZone -ComputerName $FocusDC)
+    $Message=Set-DisplayMessage -Description "Removing temporary files that were created on '$WorkingPath' for each DNS Forward and Reserve Zones from '$FocusDC'." -FontColor White -RightJustified $false
+    ForEach($Zone In $Zones){
+	    $ZoneExport="$($Zone.ZoneName)"
+        $ZoneExport="$WorkingPath\$($ZoneExport).csv"
+        If(Test-Path -Path $ZoneExport){Remove-Item -Path $ZoneExport}
+    }
+    NullVariables -ItemList 'FocusDC','Message','WorkingPath','Zone','ZoneExport','Zones'
+#    Clear-Host;Clear-History
+}
+$Message=Set-DisplayMessage -Description ""
+$FinishTime=(Get-Date).toString('yyyy/M/d H:mm:ss')
+$FinishTime=[DateTime]::ParseExact($FinishTime,'yyyy/M/d H:mm:ss',$null)
+$EndTime=Get-TimeDiff -StartDate $StartTime -EndDate $FinishTime
+$Message="Total time to process: [{0:c}|(H:mm:ss)]" -f $EndTime
+[Int]$TotalConnections=$ActiveConnection+$StaleConnection
+$Message+="; Active systems: [$ActiveConnection]"
+$Message+="; Systems to be removed from AD: [$StaleConnection]"
+$Message+="; Systems that haven't been logged into [$NotLoggedOn]"
+$Message+="; System that failed to respond to ping: [$BadIPAddress]"
+$Message+="; Systems not in DNS: [$BadComputer]"
+$Message+="; Total systems processed: [$TotalConnections]"
+$Message=Set-DisplayMessage -Description $Message -RightJustified $false
+$Message=Set-DisplayMessage -Description ""
+Set-Location -Path "$env:SystemRoot\System32"
\ No newline at end of file
diff --git a/PowerShell/General/Initialize-PowerCLIEnvironment.ps1 b/PowerShell/General/Initialize-PowerCLIEnvironment.ps1
new file mode 100644
index 0000000..a8eb581
--- /dev/null
+++ b/PowerShell/General/Initialize-PowerCLIEnvironment.ps1
@@ -0,0 +1,295 @@
+﻿#######################################################################################################################
+# This file will be removed when PowerCLI is uninstalled. To make your own scripts run when PowerCLI starts, create a
+# file named "Initialize-PowerCLIEnvironment_Custom.ps1" in the same directory as this file, and place your scripts in
+# it. The "Initialize-PowerCLIEnvironment_Custom.ps1" is not automatically deleted when PowerCLI is uninstalled.
+#######################################################################################################################
+param([bool]$promptForCEIP = $false)
+
+# List of modules to be loaded
+$moduleList = @(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+    )
+
+$productName = "PowerCLI"
+$productShortName = "PowerCLI"
+
+$loadingActivity = "Loading $productName"
+$script:completedActivities = 0
+$script:percentComplete = 0
+$script:currentActivity = ""
+$script:totalActivities = `
+   $moduleList.Count + 1
+
+function ReportStartOfActivity($activity) {
+   $script:currentActivity = $activity
+   Write-Progress -Activity $loadingActivity -CurrentOperation $script:currentActivity -PercentComplete $script:percentComplete
+}
+function ReportFinishedActivity() {
+   $script:completedActivities++
+   $script:percentComplete = (100.0 / $totalActivities) * $script:completedActivities
+   $script:percentComplete = [Math]::Min(99, $percentComplete)
+   
+   Write-Progress -Activity $loadingActivity -CurrentOperation $script:currentActivity -PercentComplete $script:percentComplete
+}
+
+# Load modules
+function LoadModules(){
+   ReportStartOfActivity "Searching for $productShortName module components..."
+   
+   $loaded = Get-Module -Name $moduleList -ErrorAction Ignore | % {$_.Name}
+   $registered = Get-Module -Name $moduleList -ListAvailable -ErrorAction Ignore | % {$_.Name}
+   $notLoaded = $registered | ? {$loaded -notcontains $_}
+   
+   ReportFinishedActivity
+   
+   foreach ($module in $registered) {
+      if ($loaded -notcontains $module) {
+		 ReportStartOfActivity "Loading module $module"
+         
+		 Import-Module $module
+		 
+		 ReportFinishedActivity
+      }
+   }
+}
+
+LoadModules
+
+# Update PowerCLI version after snap-in load
+$powerCliFriendlyVersion = [VMware.VimAutomation.Sdk.Util10.ProductInfo]::PowerCLIFriendlyVersion
+$host.ui.RawUI.WindowTitle = $powerCliFriendlyVersion
+
+# Launch text
+write-host "          Welcome to VMware $productName!"
+write-host ""
+write-host "Log in to a vCenter Server or ESX host:              " -NoNewLine
+write-host "Connect-VIServer" -foregroundcolor yellow
+write-host "To find out what commands are available, type:       " -NoNewLine
+write-host "Get-VICommand" -foregroundcolor yellow
+write-host "To show searchable help for all PowerCLI commands:   " -NoNewLine
+write-host "Get-PowerCLIHelp" -foregroundcolor yellow  
+write-host "Once you've connected, display all virtual machines: " -NoNewLine
+write-host "Get-VM" -foregroundcolor yellow
+write-host "If you need more help, visit the PowerCLI community: " -NoNewLine
+write-host "Get-PowerCLICommunity" -foregroundcolor yellow
+write-host ""
+write-host "       Copyright (C) VMware, Inc. All rights reserved."
+write-host ""
+write-host ""
+
+# CEIP
+Try	{
+	$configuration = Get-PowerCLIConfiguration -Scope Session
+
+	if ($promptForCEIP -and
+		$configuration.ParticipateInCEIP -eq $null -and `
+		[VMware.VimAutomation.Sdk.Util10Ps.CommonUtil]::InInteractiveMode($Host.UI)) {
+
+		# Prompt
+		$caption = "Participate in VMware Customer Experience Improvement Program (CEIP)"
+		$message = `
+			"VMware's Customer Experience Improvement Program (`"CEIP`") provides VMware with information " +
+			"that enables VMware to improve its products and services, to fix problems, and to advise you " +
+			"on how best to deploy and use our products.  As part of the CEIP, VMware collects technical information " +
+			"about your organization’s use of VMware products and services on a regular basis in association " +
+			"with your organization’s VMware license key(s).  This information does not personally identify " +
+			"any individual." +
+			"`n`nFor more details: press Ctrl+C to exit this prompt and type `"help about_ceip`" to see the related help article." +
+			"`n`nYou can join or leave the program at any time by executing: Set-PowerCLIConfiguration -Scope User -ParticipateInCEIP `$true or `$false. "
+
+		$acceptLabel = "&Join"
+		$choices = (
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList $acceptLabel,"Participate in the CEIP"),
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList "&Leave","Don't participate")
+		)
+		$userChoiceIndex = $Host.UI.PromptForChoice($caption, $message, $choices, 0)
+		
+		$participate = $choices[$userChoiceIndex].Label -eq $acceptLabel
+
+		if ($participate) {
+         [VMware.VimAutomation.Sdk.Interop.V1.CoreServiceFactory]::CoreService.CeipService.JoinCeipProgram();
+      } else {
+         Set-PowerCLIConfiguration -Scope User -ParticipateInCEIP $false -Confirm:$false | Out-Null
+      }
+	}
+} Catch {
+	# Fail silently
+}
+# end CEIP
+
+Write-Progress -Activity $loadingActivity -Completed
+
+cd \
+
+
+# SIG # Begin signature block
+# MIIdVgYJKoZIhvcNAQcCoIIdRzCCHUMCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
+# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
+# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUiFvjXECgR4ldsk28XP0tOTO0
+# eKigghhpMIID7jCCA1egAwIBAgIQfpPr+3zGTlnqS5p31Ab8OzANBgkqhkiG9w0B
+# AQUFADCBizELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTEUMBIG
+# A1UEBxMLRHVyYmFudmlsbGUxDzANBgNVBAoTBlRoYXd0ZTEdMBsGA1UECxMUVGhh
+# d3RlIENlcnRpZmljYXRpb24xHzAdBgNVBAMTFlRoYXd0ZSBUaW1lc3RhbXBpbmcg
+# Q0EwHhcNMTIxMjIxMDAwMDAwWhcNMjAxMjMwMjM1OTU5WjBeMQswCQYDVQQGEwJV
+# UzEdMBsGA1UEChMUU3ltYW50ZWMgQ29ycG9yYXRpb24xMDAuBgNVBAMTJ1N5bWFu
+# dGVjIFRpbWUgU3RhbXBpbmcgU2VydmljZXMgQ0EgLSBHMjCCASIwDQYJKoZIhvcN
+# AQEBBQADggEPADCCAQoCggEBALGss0lUS5ccEgrYJXmRIlcqb9y4JsRDc2vCvy5Q
+# WvsUwnaOQwElQ7Sh4kX06Ld7w3TMIte0lAAC903tv7S3RCRrzV9FO9FEzkMScxeC
+# i2m0K8uZHqxyGyZNcR+xMd37UWECU6aq9UksBXhFpS+JzueZ5/6M4lc/PcaS3Er4
+# ezPkeQr78HWIQZz/xQNRmarXbJ+TaYdlKYOFwmAUxMjJOxTawIHwHw103pIiq8r3
+# +3R8J+b3Sht/p8OeLa6K6qbmqicWfWH3mHERvOJQoUvlXfrlDqcsn6plINPYlujI
+# fKVOSET/GeJEB5IL12iEgF1qeGRFzWBGflTBE3zFefHJwXECAwEAAaOB+jCB9zAd
+# BgNVHQ4EFgQUX5r1blzMzHSa1N197z/b7EyALt0wMgYIKwYBBQUHAQEEJjAkMCIG
+# CCsGAQUFBzABhhZodHRwOi8vb2NzcC50aGF3dGUuY29tMBIGA1UdEwEB/wQIMAYB
+# Af8CAQAwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC50aGF3dGUuY29tL1Ro
+# YXd0ZVRpbWVzdGFtcGluZ0NBLmNybDATBgNVHSUEDDAKBggrBgEFBQcDCDAOBgNV
+# HQ8BAf8EBAMCAQYwKAYDVR0RBCEwH6QdMBsxGTAXBgNVBAMTEFRpbWVTdGFtcC0y
+# MDQ4LTEwDQYJKoZIhvcNAQEFBQADgYEAAwmbj3nvf1kwqu9otfrjCR27T4IGXTdf
+# plKfFo3qHJIJRG71betYfDDo+WmNI3MLEm9Hqa45EfgqsZuwGsOO61mWAK3ODE2y
+# 0DGmCFwqevzieh1XTKhlGOl5QGIllm7HxzdqgyEIjkHq3dlXPx13SYcqFgZepjhq
+# IhKjURmDfrYwggSjMIIDi6ADAgECAhAOz/Q4yP6/NW4E2GqYGxpQMA0GCSqGSIb3
+# DQEBBQUAMF4xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRTeW1hbnRlYyBDb3Jwb3Jh
+# dGlvbjEwMC4GA1UEAxMnU3ltYW50ZWMgVGltZSBTdGFtcGluZyBTZXJ2aWNlcyBD
+# QSAtIEcyMB4XDTEyMTAxODAwMDAwMFoXDTIwMTIyOTIzNTk1OVowYjELMAkGA1UE
+# BhMCVVMxHTAbBgNVBAoTFFN5bWFudGVjIENvcnBvcmF0aW9uMTQwMgYDVQQDEytT
+# eW1hbnRlYyBUaW1lIFN0YW1waW5nIFNlcnZpY2VzIFNpZ25lciAtIEc0MIIBIjAN
+# BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAomMLOUS4uyOnREm7Dv+h8GEKU5Ow
+# mNutLA9KxW7/hjxTVQ8VzgQ/K/2plpbZvmF5C1vJTIZ25eBDSyKV7sIrQ8Gf2Gi0
+# jkBP7oU4uRHFI/JkWPAVMm9OV6GuiKQC1yoezUvh3WPVF4kyW7BemVqonShQDhfu
+# ltthO0VRHc8SVguSR/yrrvZmPUescHLnkudfzRC5xINklBm9JYDh6NIipdC6Anqh
+# d5NbZcPuF3S8QYYq3AhMjJKMkS2ed0QfaNaodHfbDlsyi1aLM73ZY8hJnTrFxeoz
+# C9Lxoxv0i77Zs1eLO94Ep3oisiSuLsdwxb5OgyYI+wu9qU+ZCOEQKHKqzQIDAQAB
+# o4IBVzCCAVMwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCDAO
+# BgNVHQ8BAf8EBAMCB4AwcwYIKwYBBQUHAQEEZzBlMCoGCCsGAQUFBzABhh5odHRw
+# Oi8vdHMtb2NzcC53cy5zeW1hbnRlYy5jb20wNwYIKwYBBQUHMAKGK2h0dHA6Ly90
+# cy1haWEud3Muc3ltYW50ZWMuY29tL3Rzcy1jYS1nMi5jZXIwPAYDVR0fBDUwMzAx
+# oC+gLYYraHR0cDovL3RzLWNybC53cy5zeW1hbnRlYy5jb20vdHNzLWNhLWcyLmNy
+# bDAoBgNVHREEITAfpB0wGzEZMBcGA1UEAxMQVGltZVN0YW1wLTIwNDgtMjAdBgNV
+# HQ4EFgQURsZpow5KFB7VTNpSYxc/Xja8DeYwHwYDVR0jBBgwFoAUX5r1blzMzHSa
+# 1N197z/b7EyALt0wDQYJKoZIhvcNAQEFBQADggEBAHg7tJEqAEzwj2IwN3ijhCcH
+# bxiy3iXcoNSUA6qGTiWfmkADHN3O43nLIWgG2rYytG2/9CwmYzPkSWRtDebDZw73
+# BaQ1bHyJFsbpst+y6d0gxnEPzZV03LZc3r03H0N45ni1zSgEIKOq8UvEiCmRDoDR
+# EfzdXHZuT14ORUZBbg2w6jiasTraCXEQ/Bx5tIB7rGn0/Zy2DBYr8X9bCT2bW+IW
+# yhOBbQAuOA2oKY8s4bL0WqkBrxWcLC9JG9siu8P+eJRRw4axgohd8D20UaF5Mysu
+# e7ncIAkTcetqGVvP6KUwVyyJST+5z3/Jvz4iaGNTmr1pdKzFHTx/kuDDvBzYBHUw
+# ggTRMIIDuaADAgECAhBlO8IY/xbhmnONwPCxJt5hMA0GCSqGSIb3DQEBCwUAMH8x
+# CzAJBgNVBAYTAlVTMR0wGwYDVQQKExRTeW1hbnRlYyBDb3Jwb3JhdGlvbjEfMB0G
+# A1UECxMWU3ltYW50ZWMgVHJ1c3QgTmV0d29yazEwMC4GA1UEAxMnU3ltYW50ZWMg
+# Q2xhc3MgMyBTSEEyNTYgQ29kZSBTaWduaW5nIENBMB4XDTE1MDcyNDAwMDAwMFoX
+# DTE4MDgyMjIzNTk1OVowZDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3Ju
+# aWExEjAQBgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChQMVk13YXJlLCBJbmMuMRUw
+# EwYDVQQDFAxWTXdhcmUsIEluYy4wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
+# AoIBAQDCmS07ZAwM9eVLBDfxw1rKIge6PZwfP8Xh2YSsyjzRUzzBouY4j7GTjM2e
+# OZLiZhL+B32ps1BdfKJfSBaOein4ynaxVgCf9XuVWQKIZMzss+FJcf5gOk0dV/9t
+# CHzIfoC81H1/PrnkX0uXRHcuz22m9FH9ggA3CLJPQlumTcxtqftNFSJsX0BT3Afg
+# VDs/lsCEeY8VodT9AJzGGVGMz0YIB2J0gM8w9s9/1znjh4BFRp2AfrBk2Y0Ujoh2
+# gaZEoLMfX1mI+QJdsKRNRt+lBerbyH93DupYJPviUavYiEg/b3+4xsYmkjq7dcNc
+# ZTB93URHdg6ipSo3/R6B4PzUow5fAgMBAAGjggFiMIIBXjAJBgNVHRMEAjAAMA4G
+# A1UdDwEB/wQEAwIHgDArBgNVHR8EJDAiMCCgHqAchhpodHRwOi8vc3Yuc3ltY2Iu
+# Y29tL3N2LmNybDBmBgNVHSAEXzBdMFsGC2CGSAGG+EUBBxcDMEwwIwYIKwYBBQUH
+# AgEWF2h0dHBzOi8vZC5zeW1jYi5jb20vY3BzMCUGCCsGAQUFBwICMBkMF2h0dHBz
+# Oi8vZC5zeW1jYi5jb20vcnBhMBMGA1UdJQQMMAoGCCsGAQUFBwMDMFcGCCsGAQUF
+# BwEBBEswSTAfBggrBgEFBQcwAYYTaHR0cDovL3N2LnN5bWNkLmNvbTAmBggrBgEF
+# BQcwAoYaaHR0cDovL3N2LnN5bWNiLmNvbS9zdi5jcnQwHwYDVR0jBBgwFoAUljtT
+# 8Hkzl699g+8uK8zKt4YecmYwHQYDVR0OBBYEFGaw3m9kanGu85olA8OJIdV3JXR/
+# MA0GCSqGSIb3DQEBCwUAA4IBAQA27zm4ThfMqwr7AVYhk6efINp10t4N+ip4DxqQ
+# t8Z+SSnPUeO23MmoUHFVWhJS57lgx0FVdAcUBdSmh/N7YvtoGfTOr4Q6k6Z6bjmV
+# hUD3QIL77lGPGeotS8QIPeb9F5lX4Y/eiwRZ8254MFM0D2r+CgSVs123MS0zEZjF
+# r7ychqVu77UXEuaQFDHkS1fEsiaRqrEnu8pNhcFVwZCzLJnn9DYOfpfgG8s8pwCF
+# 2J6Cxs5MFPiO35OfZuXqRRx/7wlCIj6rcyb4sq62ksRA1On8OP6svY6AucSzTTFI
+# SYrHImOnHnffhNrBogdf5uuwEuom3KoKMOt/0QqAXDt4cO9fMIIFWTCCBEGgAwIB
+# AgIQPXjX+XZJYLJhffTwHsqGKjANBgkqhkiG9w0BAQsFADCByjELMAkGA1UEBhMC
+# VVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU
+# cnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2lnbiwgSW5jLiAt
+# IEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFz
+# cyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzUw
+# HhcNMTMxMjEwMDAwMDAwWhcNMjMxMjA5MjM1OTU5WjB/MQswCQYDVQQGEwJVUzEd
+# MBsGA1UEChMUU3ltYW50ZWMgQ29ycG9yYXRpb24xHzAdBgNVBAsTFlN5bWFudGVj
+# IFRydXN0IE5ldHdvcmsxMDAuBgNVBAMTJ1N5bWFudGVjIENsYXNzIDMgU0hBMjU2
+# IENvZGUgU2lnbmluZyBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
+# AJeDHgAWryyx0gjE12iTUWAecfbiR7TbWE0jYmq0v1obUfejDRh3aLvYNqsvIVDa
+# nvPnXydOC8KXyAlwk6naXA1OpA2RoLTsFM6RclQuzqPbROlSGz9BPMpK5KrA6Dmr
+# U8wh0MzPf5vmwsxYaoIV7j02zxzFlwckjvF7vjEtPW7ctZlCn0thlV8ccO4XfduL
+# 5WGJeMdoG68ReBqYrsRVR1PZszLWoQ5GQMWXkorRU6eZW4U1V9Pqk2JhIArHMHck
+# EU1ig7a6e2iCMe5lyt/51Y2yNdyMK29qclxghJzyDJRewFZSAEjM0/ilfd4v1xPk
+# OKiE1Ua4E4bCG53qWjjdm9sCAwEAAaOCAYMwggF/MC8GCCsGAQUFBwEBBCMwITAf
+# BggrBgEFBQcwAYYTaHR0cDovL3MyLnN5bWNiLmNvbTASBgNVHRMBAf8ECDAGAQH/
+# AgEAMGwGA1UdIARlMGMwYQYLYIZIAYb4RQEHFwMwUjAmBggrBgEFBQcCARYaaHR0
+# cDovL3d3dy5zeW1hdXRoLmNvbS9jcHMwKAYIKwYBBQUHAgIwHBoaaHR0cDovL3d3
+# dy5zeW1hdXRoLmNvbS9ycGEwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3MxLnN5
+# bWNiLmNvbS9wY2EzLWc1LmNybDAdBgNVHSUEFjAUBggrBgEFBQcDAgYIKwYBBQUH
+# AwMwDgYDVR0PAQH/BAQDAgEGMCkGA1UdEQQiMCCkHjAcMRowGAYDVQQDExFTeW1h
+# bnRlY1BLSS0xLTU2NzAdBgNVHQ4EFgQUljtT8Hkzl699g+8uK8zKt4YecmYwHwYD
+# VR0jBBgwFoAUf9Nlp8Ld7LvwMAnzQzn6Aq8zMTMwDQYJKoZIhvcNAQELBQADggEB
+# ABOFGh5pqTf3oL2kr34dYVP+nYxeDKZ1HngXI9397BoDVTn7cZXHZVqnjjDSRFph
+# 23Bv2iEFwi5zuknx0ZP+XcnNXgPgiZ4/dB7X9ziLqdbPuzUvM1ioklbRyE07guZ5
+# hBb8KLCxR/Mdoj7uh9mmf6RWpT+thC4p3ny8qKqjPQQB6rqTog5QIikXTIfkOhFf
+# 1qQliZsFay+0yQFMJ3sLrBkFIqBgFT/ayftNTI/7cmd3/SeUx7o1DohJ/o39KK9K
+# Er0Ns5cF3kQMFfo2KwPcwVAB8aERXRTl4r0nS1S+K4ReD6bDdAUK75fDiSKxH3fz
+# vc1D1PFMqT+1i4SvZPLQFCEwggWaMIIDgqADAgECAgphGZPkAAAAAAAcMA0GCSqG
+# SIb3DQEBBQUAMH8xCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAw
+# DgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24x
+# KTAnBgNVBAMTIE1pY3Jvc29mdCBDb2RlIFZlcmlmaWNhdGlvbiBSb290MB4XDTEx
+# MDIyMjE5MjUxN1oXDTIxMDIyMjE5MzUxN1owgcoxCzAJBgNVBAYTAlVTMRcwFQYD
+# VQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0
+# d29yazE6MDgGA1UECxMxKGMpIDIwMDYgVmVyaVNpZ24sIEluYy4gLSBGb3IgYXV0
+# aG9yaXplZCB1c2Ugb25seTFFMEMGA1UEAxM8VmVyaVNpZ24gQ2xhc3MgMyBQdWJs
+# aWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc1MIIBIjANBgkq
+# hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAryQICCl6NZ5gDKrnSztO3Hy8PEUcuyvg
+# /ikC+VcIo2SFFSf18a3IMYldIugqqqZCs4/4uVW3sbdLs/6PfgdX7O9D22ZiFWHP
+# YA2k2N744MNiCD1UE+tJyllUhSblK48bn+v1oZHCM0nYQ2NqUkvSj+hwUU3RiWl7
+# x3D2s9wSdNt7XUtW05a/FXehsPSiJfKvHJJnGOX0BgTvkLnkAOTdOrUZ/wK69Dzu
+# 4IvrN4vs9Nes8vbwPa/ddZEzGR0cQMt0JBkhk9kU/qwqUseP1QRJ5I1jR4g8aYPL
+# /ke9K35PxZWuDp3U0UPAZ3PjFAh+5T+fc7gzCs9dPzSHloruU+glFQIDAQABo4HL
+# MIHIMBEGA1UdIAQKMAgwBgYEVR0gADAPBgNVHRMBAf8EBTADAQH/MAsGA1UdDwQE
+# AwIBhjAdBgNVHQ4EFgQUf9Nlp8Ld7LvwMAnzQzn6Aq8zMTMwHwYDVR0jBBgwFoAU
+# YvsKIVt/Q24R2glUUGv10pZx8Z4wVQYDVR0fBE4wTDBKoEigRoZEaHR0cDovL2Ny
+# bC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljcm9zb2Z0Q29kZVZl
+# cmlmUm9vdC5jcmwwDQYJKoZIhvcNAQEFBQADggIBAIEqghaMNGcr5QPrNHuMoqNQ
+# ivRVhvEejI6ufe4DGc5ylRhIrWIR/SD9P0cGAVri4G+MFSxOPGpQbAs2o896DZxC
+# vFz4GdVg42nm4iNBZ4xog3Yrj5OjKrV/vln7qcmyJo/KovOCG5g+kZUnl4Zh7ltd
+# B2vNhqjiZYCo4hXisr4jBWq6DPNHk02spIwHeTnAYRI6BQ2Jo+yfV4mE++zKfEdm
+# FJHYtg8ZXea4Sqy8R8hxQ5bmMiCl3HeG/Tzji3Hbe5sD/LcdMmTrFlKgQ6P6Lq1Z
+# kk58x/IzQkg4UTp8OMcbJCIoQB4aRh8X2xj38Cc1bLhj2c25ZF0rpV7vxim08sf4
+# IcwEulf9Abarxmf559OZf/T1Ivpy9f3/OhxCOqH5gBil7o0c1GaeRQH+qu7/+xeP
+# MPfxzSnFney11UkAPYW4y7uTOidqScAwrmbJ9yMoMnb5pINWyEjOWpaqoMwMxH+0
+# jpevbeNUJ8OfhsDW5HMIlwXb0FRiXgNIwtWff6dmjNCdsE/U05hfS3rJf7IpUtAS
+# gMcPVLYeZ83GoGwRA4TTSHXnKv6wO24KOqZrdpkFo/F3aGEzFEcG/FN/Ur2SFFxK
+# JGpnjK+NkKrQ9nkhG5MmfMPOHr2IOJKuRcYZaklQswX4rlk3imolA5SxWYFQ6LqD
+# gLcjNfR2uWcdWRitII2UMYIEVzCCBFMCAQEwgZMwfzELMAkGA1UEBhMCVVMxHTAb
+# BgNVBAoTFFN5bWFudGVjIENvcnBvcmF0aW9uMR8wHQYDVQQLExZTeW1hbnRlYyBU
+# cnVzdCBOZXR3b3JrMTAwLgYDVQQDEydTeW1hbnRlYyBDbGFzcyAzIFNIQTI1NiBD
+# b2RlIFNpZ25pbmcgQ0ECEGU7whj/FuGac43A8LEm3mEwCQYFKw4DAhoFAKCBijAZ
+# BgkqhkiG9w0BCQMxDAYKKwYBBAGCNwIBBDAcBgorBgEEAYI3AgELMQ4wDAYKKwYB
+# BAGCNwIBFTAjBgkqhkiG9w0BCQQxFgQUR0eRMtpzL1P4NIKMD9ceTahG6XkwKgYK
+# KwYBBAGCNwIBDDEcMBqhGIAWaHR0cDovL3d3dy52bXdhcmUuY29tLzANBgkqhkiG
+# 9w0BAQEFAASCAQA4zN2wZqoR2TH+XtZdBfMePaaXAw33iZLj7Plr7E+zs7SaLV9x
+# CK3ikVAvLsOP4MsTb1SS6V8LaXRhAfnAApV8pdq/cN/zYai61stl4Z5rkUAzaxxf
+# rA7yrYb9yo/LczkfMiV8humy0G4ukjC0HbdmMcj4JzmUfQRgbjK38H+pBiIjBoRk
+# 31inqkCpCmMMJxpwRac5CYVtA/sqIq/KbZsgyZ911fkpe8x3uH5sWzdn6xvKmltA
+# htr86cq5dzbW4MjBEgmaHp7/lRMsTYQd4p5id7ITFlB68zK00zHQZXyHsQrQFN1u
+# UG/1RE9ibkWF9JH9JROvobriiI8dwmc0d+ACoYICCzCCAgcGCSqGSIb3DQEJBjGC
+# AfgwggH0AgEBMHIwXjELMAkGA1UEBhMCVVMxHTAbBgNVBAoTFFN5bWFudGVjIENv
+# cnBvcmF0aW9uMTAwLgYDVQQDEydTeW1hbnRlYyBUaW1lIFN0YW1waW5nIFNlcnZp
+# Y2VzIENBIC0gRzICEA7P9DjI/r81bgTYapgbGlAwCQYFKw4DAhoFAKBdMBgGCSqG
+# SIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTE2MTEwOTE0MzMy
+# MlowIwYJKoZIhvcNAQkEMRYEFPy1ZwpWpFCsbJirPmKIk7+xqHCVMA0GCSqGSIb3
+# DQEBAQUABIIBAJm9CFMYL3CoAelRbKss1q7U+Ku1sB3GlRPcsLvoNvieAAcHK4Oq
+# 9QJ8ZwLWLEip6DueL/dQpItXWUABh4nBvrEnKfzLxH2QSOG2iQzlJUjvIonGIf/2
+# FRUflwl+2GX0g5xgfOCWP08gzBtcdQ6GrU1yv1xpcwDit1TjqTCxgxIFusQCJ1vM
+# Un8WmzWIDSBvIf+zkn9We0aKkOZdadm1IBxIemfF3HeXWtGKtyoEimzyEjWkD86+
+# QwwPVGMqidP8EWoj7DT9Oh0GzmXSbfQyxUiXCiMwkTzK1vBsSiA0AIan6iiuVaUA
+# JSmVsSpWb4vlxA4t4w6yWPgyvKKG4Y2ahwY=
+# SIG # End signature block
diff --git a/PowerShell/General/MapNetworkDrives.ps1 b/PowerShell/General/MapNetworkDrives.ps1
new file mode 100644
index 0000000..fce9eb4
--- /dev/null
+++ b/PowerShell/General/MapNetworkDrives.ps1
@@ -0,0 +1,224 @@
+﻿PowerShell Set-ExecutionPolicy -ExecutionPolicy ByPass
+PowerShell Set-ExecutionPolicy Unrestricted
+Clear-Host;Clear-History
+Set-Location ($env:SystemRoot+"\System32")
+$CurrentLocation=Get-Location
+Set-Variable -Name SecureCredentials -Value $null
+If((!($env:USERDNSDOMAIN)-eq$null)-or($env:USERDNSDOMAIN)-eq"home.net"){
+    $Global:DomainA=($env:USERDNSDOMAIN.ToLower())
+}
+$Global:DomainB=("utshare.local")
+$Global:Validate=$null
+$Global:UserAccount="sy1000829946"
+$Global:SecureUserDA=($env:USERNAME+"@"+$DomainA)
+$Global:SecureUserDB=($UserAccount+"@"+$DomainB)
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$true)]$SecureUser="",[String][Parameter(Mandatory=$true)]$Domain="")
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Clear
+Set-Variable -Name Loops -Value 0
+Set-Variable -Name LoopCount -Value 0
+Do{
+    Set-Variable -Name utsis -Value ("grey."+$DomainA)
+    Set-Variable -Name utshare -Value ($DomainB+"\replication")
+    If(($DomainA-eq$DomainB)-or($DomainA-eq$null)){
+        Set-Variable -Name Drives -Value @("S","W")
+    }Else{
+        Set-Variable -Name Drives -Value @("G","S","W")
+    }
+    $Domain=($DomainB).split(".")[0]
+    ForEach($Drive In $Drives){
+        Set-Variable -Name ShareName -Value $null
+        Switch ($Drive){
+            "G"{$Validate=SetCredentials -SecureUser $SecureUserDA -Domain ($DomainA).split(".")[0]
+                $SecureUser=($env:USERNAME+"@"+$DomainA)
+                $ShareName=("\\"+$utsis+"\apps")
+                Break}
+            "S"{$Validate=SetCredentials -SecureUser $SecureUserDB -Domain ($DomainB).split(".")[0]
+                $SecureUser=($Domain+"\"+$UserAccount)
+                $ShareName=("\\"+$utshare+"\SysAdmins")
+                Break}
+            "W"{$Validate=SetCredentials -SecureUser $SecureUserDB -Domain ($DomainB).split(".")[0]
+                $SecureUser=($Domain+"\"+$UserAccount)
+                $UserShare=($SecureUserDB.SubString(0,2)+"\"+$SecureUserDB.Substring(0,12))
+                $ShareName=("\\"+$utshare+"\Users\"+$UserShare)
+                Break}
+        }
+        $NetName=$ShareName.Replace("\","\\")
+        $NetDrive = Get-WmiObject -Class Win32_mappedLogicalDisk -filter ("ProviderName='"+$NetName+"'")
+        If($NetDrive.Name-ne$null){net use $NetDrive.Name /delete}
+        Net Use ($Drive+":") $ShareName /user:$SecureUser $Validate /Persistent:NO;$Validate=$null
+    }
+    $LoopCount++
+}While($LoopCount-le$Loops)
+Set-Location -Path $CurrentLocation
diff --git a/PowerShell/General/PrintServiceStatus.ps1 b/PowerShell/General/PrintServiceStatus.ps1
new file mode 100644
index 0000000..1eddfab
--- /dev/null
+++ b/PowerShell/General/PrintServiceStatus.ps1
@@ -0,0 +1,112 @@
+﻿Clear-Host;Clear-History
+Set-Variable -Name LoopTimer -Value 500
+Set-Variable -Name LoopCounter -Value 0
+Set-Variable -Name ComputerName -Value ($env:COMPUTERNAME).ToLower()
+Set-Variable -Name SmbShare -Value "\\utshare.local\departments\sysadm\PrintServer\Logs\$ComputerName"
+If((Test-Path $SmbShare)-eq$false){
+    New-Item -ItemType Directory -Force -Path $SmbShare > $null
+}
+Do{
+    Set-Variable -Name Counter -Value 1
+    Set-Variable -Name Aging -Value "-90"
+    Set-Variable -Name WriteLog -Value $false
+    Set-Variable -Name Extensions -Value "bak","prn","txt"
+    Set-Variable -Name StartTime -Value (Get-Date).AddMinutes(-5)
+    Set-Variable -Name FileName -Value (Get-Date -UFormat "%Y-%m%d_%H%M")
+    Set-Variable -Name LogFile -Value "$SmbShare\PrintService_$FileName.log"
+    Set-Variable -Name ProcessList -Value "svchost","spoolsv","TroyPortMonitorService"
+    Set-Variable -Name FreeDiskSpace -Value (Get-WmiObject Win32_LogicalDisk|Where-Object{$_.DriveType-eq3}|Where-Object{$_.DeviceID-eq"E:"}|Select @{Name="GB";Expression={[math]::round($_.FreeSpace/1GB,2)}}).GB
+    Set-Variable -Name TotalSpace -Value (Get-WmiObject Win32_LogicalDisk|Where-Object{$_.DriveType-eq3}|Where-Object{$_.DeviceID-eq"E:"}|Select @{Name="GB";Expression={[math]::round($_.Size/1GB,2)}}).GB
+    Set-Variable -Name Percentage -Value ([math]::Truncate(($FreeDiskSpace/$TotalSpace)*100))
+    Date;"Freespace on 'Disk [E:]' $Percentage%";
+    If(($Percentage-gt30)-and($Percentage-lt40)){
+        $Aging="-60"
+    }ElseIf(($Percentage-gt20)-and($Percentage-lt30)){
+        $Aging="-45"
+    }ElseIf(($Percentage-gt10)-and($Percentage-lt20)){
+        $Aging="-30"
+    }
+    Do{
+        ForEach($Ext In $Extensions){
+            If($Ext-ne"txt"){
+                $SubFolder="$Counter\Backup\"
+            }Else{
+                $SubFolder="$Counter\"
+            }
+            Set-Variable -Name FilePattern -Value "E:\TROY Group\Port Monitor\PrintPort$SubFolder*.$Ext"
+            Get-ChildItem -Path "$FilePattern" -Recurse -Force -ErrorAction SilentlyContinue|
+            Where-Object{($_.CreationTime-le$(Get-Date).AddDays($Aging))}|
+            Remove-Item -Force -Verbose -Recurse -ErrorAction SilentlyContinue
+        }
+        $Counter++
+        $Ext=$null
+        $SubFolder=$null
+        $FilePattern=$null
+    }Until($Counter-gt20)
+    ForEach($Proces In $ProcessList){
+        If($Proces -eq "svchost"){
+            Set-Variable -Name Found -Value $false
+            Set-Variable -Name ServiceName -Value "LPDSVC"
+            Set-Variable -Name OutputFile -Value "$env:TEMP\Output.txt"
+            Set-Variable -Name RunningSvcs -Value "/SVC /FI ""imagename eq svchost.exe"""
+            Start-Process tasklist -ArgumentList $RunningSvcs -RedirectStandardOutput $OutputFile -WindowStyle Hidden
+            ForEach($line In Get-Content $OutputFile){
+                If($line -match $ServiceName){
+                    $Found=$true;Break
+                }
+            }
+            If(Test-Path -Path $OutputFile){
+                Start-Sleep -Milliseconds $LoopTimer
+                Remove-Item -Path $OutputFile -Force
+            }
+            If($Found-eq$false){
+                Set-Variable -Name ServiceName -Value "LPD Service"
+                Start-Process cmd -ArgumentList "/c net start |find ""$ServiceName""" -RedirectStandardOutput $OutputFile -WindowStyle Hidden
+                ForEach($line In Get-Content $OutputFile){
+                    If($line -match $ServiceName){
+                        Break
+                    }
+                    Echo "Attempting to start '$ServiceName'."
+                    Start-Process svchost -ArgumentList "-k LPDService" -ErrorAction SilentlyContinue
+                    $WriteLog=$true
+               }
+                If(Test-Path -Path $OutputFile){
+                    Start-Sleep -Milliseconds $LoopTimer
+                    Remove-Item -Path $OutputFile -Force
+                }
+            }
+            $Found=$null
+            $ServiceName=$null
+            $OutputFile=$null
+            $RunningSvcs=$null
+        }ElseIf((Get-Process -Name "$Proces" -ErrorAction SilentlyContinue) -eq $null){
+            Echo "Attempting to start '$Proces'."
+            Start-Process $Proces -ErrorAction SilentlyContinue
+            $WriteLog=$true
+        }
+    }
+    If($WriteLog-eq$true){
+        Set-Variable -Name CurrentLog -Value (Get-WinEvent -LogName Microsoft-Windows-PrintService/*|Where-Object{$_.TimeCreated-ge$Starttime}|Out-File -FilePath $LogFile)
+    }
+    $Aging=$null
+    $Proces=$null
+    $LoopCounter++
+    $Counter=$null
+    $LogFile=$null
+    $FileName=$null
+    $Starttime=$null
+    $CurrentLog=$null
+    $TotalSpace=$null
+    $Percentage=$null
+    $Extensions=$null
+    $FreeDiskSpace=$null
+    $Pause=$LoopTimer*598
+    Start-Sleep -Milliseconds $Pause
+}Until($LoopCounter-ge12)
+$ComputerName=$null
+$ProcessList=$null
+$LoopCounter=$null
+$LoopTimer=$null
+$SmbShare=$null
+$WriteLog=$null
+$Pause=$null
\ No newline at end of file
diff --git a/PowerShell/General/PrivilegedUsers.ps1 b/PowerShell/General/PrivilegedUsers.ps1
new file mode 100644
index 0000000..b730d6a
--- /dev/null
+++ b/PowerShell/General/PrivilegedUsers.ps1
@@ -0,0 +1,10 @@
+﻿<#
+Get-ADGroupMember "administrators" -Recursive|Where-Object {$_.Name -Like "*"}|%{$group=$_;get-aduser $_ -Properties Name|Select @{n="Group";e={$group}},Name,SurName,GivenName,ObjectClass}|Out-File 'E:\Results\administrators.log'
+Get-ADGroupMember "Backup Operators" -Recursive|Where-Object {$_.Name -Like "*"}|%{$group=$_;get-aduser $_ -Properties Name|Select @{n="Group";e={$group}},Name,SurName,GivenName,ObjectClass}|Out-File 'E:\Results\BackupOperators.log'
+Get-ADGroupMember "Enterprise Admins" -Recursive|Where-Object {$_.Name -Like "*"}|%{$group=$_;get-aduser $_ -Properties Name|Select @{n="Group";e={$group}},Name,SurName,GivenName,ObjectClass}|Out-File 'E:\Results\EnterpriseAdmins.log'
+Get-ADGroupMember "Domain Admins" -Recursive|Where-Object {$_.Name -Like "*"}|%{$group=$_;get-aduser $_ -Properties Name|Select @{n="Group";e={$group}},Name,SurName,GivenName,ObjectClass}|Out-File 'E:\Results\DomainAdmins.log'
+#Get-ADGroupMember "utshare" -Recursive|Where-Object {$_.Name -Like "*"}|%{$group=$_;get-aduser $_ -Properties Name|Select @{n="Group";e={$group}},Name,SurName,GivenName,ObjectClass}|Out-File 'E:\Results\utshare.log'
+#>
+$TestAcct="sy1000829946"
+#Get-ADComputer -Filter {name -like $TestAcct} -Properties *
+Get-ADUser -Filter {name -like $TestAcct} -Properties *
\ No newline at end of file
diff --git a/PowerShell/General/RenHostName.ps1 b/PowerShell/General/RenHostName.ps1
new file mode 100644
index 0000000..3f25353
--- /dev/null
+++ b/PowerShell/General/RenHostName.ps1
@@ -0,0 +1,600 @@
+Clear-Host;Clear-History
+Import-Module ActiveDirectory
+$moduleList = @(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+    )
+$productName = "PowerCLI"
+$productShortName = "PowerCLI"
+$loadingActivity = "Loading $productName"
+$script:completedActivities = 0
+$script:percentComplete = 0
+$script:currentActivity = ""
+$script:totalActivities = $moduleList.Count + 1
+Function Get-SystemNetDNS{param([IPAddress]$IPAddress=$null,[String]$ComputerName=$null)
+    NullVariables -ItemList 'AddressList','LineItem','RecordData','Results','SearchType','SearchValue','SubArray','ValueCheck'
+    Try{
+        $Results=$null
+        $ValueCheck=""
+        $SearchType="IPAddress"
+        If(!$($ComputerName).Length-lt1){
+            $ValueCheck=$($ComputerName.Split(" "))
+            Switch($ValueCheck[1].Length-gt1){
+                {($_-eq$true)}{$ComputerName=$ValueCheck[1];Break}
+                Default{Break}
+            }
+            $SearchValue=$ComputerName;$SearchType="HostName"
+        }
+        If($($IPAddress.AddressFamily)-eq"InterNetwork"){$SearchValue=$IPAddress.IPAddressToString}
+        Switch($SearchType){
+            Default{$Results=[System.Net.Dns]::GetHostEntry($SearchValue);Break}
+        }
+        If($ComputerName-eq$env:COMPUTERNAME){
+            $ParseArray=New-Object PSObject
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $true
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $($Results.HostName)
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "Aliases" -Value $($Results.Aliases)
+            For($i=0;$($Results.AddressList[$i])-ne$null;$i++){
+                If($($Results.AddressList[$i].IPAddressToString)-ne"::1"){
+                    [IPAddress]$AddressList=$($Results.AddressList[$i])
+                    $SubArray=New-Object PSObject
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "Address" -Value $AddressList.Address
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "AddressFamily" -Value $AddressList.AddressFamily
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "ScopeId" -Value $AddressList.ScopeId
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Multicast" -Value $AddressList.IsIPv6Multicast
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6LinkLocal" -Value $AddressList.IsIPv6LinkLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6SiteLocal" -Value $AddressList.IsIPv6SiteLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Teredo" -Value $AddressList.IsIPv6Teredo
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv4MappedToIPv6" -Value $AddressList.IsIPv4MappedToIPv6
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IPAddressToString" -Value $AddressList.IPAddressToString
+                }
+            }
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "AddressList" -Value $SubArray
+        }Else{
+            $ParseArray=New-Object PSObject
+            $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $true
+            ForEach($RecordData In $Results){
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $RecordData.HostName
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Aliases" -Value $RecordData.Aliases
+                [IPAddress]$AddressList=$($RecordData.AddressList.IPAddressToString)
+                $SubArray=New-Object PSObject
+                ForEach($LineItem In $AddressList){
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "Address" -Value $LineItem.Address
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "AddressFamily" -Value $LineItem.AddressFamily
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "ScopeId" -Value $LineItem.ScopeId
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Multicast" -Value $LineItem.IsIPv6Multicast
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6LinkLocal" -Value $LineItem.IsIPv6LinkLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6SiteLocal" -Value $LineItem.IsIPv6SiteLocal
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv6Teredo" -Value $LineItem.IsIPv6Teredo
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IsIPv4MappedToIPv6" -Value $LineItem.IsIPv4MappedToIPv6
+                    $SubArray|Add-Member -MemberType NoteProperty -Name "IPAddressToString" -Value $LineItem.IPAddressToString
+                }
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "AddressList" -Value $SubArray
+            }
+        }
+        Return $ParseArray
+    }Catch [Exception]{
+        If($($_.Exception.Message)-eq"No such host is known"){
+        }Else{
+            $Message="Error: [Get-SystemNetDNS]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+        Return $false
+    }
+}
+Function Get-VMComputerData{param([IPAddress]$VCMManagerIP,[String]$VMServer,[PSCredential]$AdminAccount,[String]$FileName)
+    NullVariables -ItemList 'Connected','Error','Message','NetworkCards','NtwkCard','ReportedVM','ReportedVMs','VM','VMs'
+    Try{
+        $VMServerIP=$VCMManagerIP.IPAddressToString
+        Write-debug "Connecting to vCenter using '$VMServerIP', please wait..."
+#        $Connected=Connect-VIServer -Server $VCMManagerIP -Protocol https -Credential $AdminAccount -ErrorAction SilentlyContinue
+        $Connected=Connect-VIServer -Server $VMServerIP -Credential $AdminAccount -ErrorAction SilentlyContinue
+        Trap{
+            If($Error[0].exception-like"*incorrect user name or password*"){
+                $Message="Error: [Get-VMComputerData]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+                Return $null
+            }
+        }
+        If($Connected){
+            $ReportedVMs=New-Object System.Collections.ArrayList
+            $VMs=Get-View -ViewType VirtualMachine|Sort-Object -Property{$_.Config.Hardware.Device|Where{$_-is[VMware.Vim.VirtualEthernetCard]}|Measure-Object|select -ExpandProperty Count} -Descending
+            ForEach($VM in $VMs){
+                $ReportedVM=New-Object PSObject
+                Add-Member -Inputobject $ReportedVM -MemberType noteProperty -name Guest -value $VM.Name
+                Add-Member -InputObject $ReportedVM -MemberType noteProperty -name UUID -value $($VM.Config.Uuid)
+                $NetworkCards=$VM.guest.net| ?{$_.DeviceConfigId-ne-1}
+                $i=0
+                ForEach($NtwkCard in $NetworkCards){
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.Network" -Value $NtwkCard.Network
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.MacAddress" -Value $NtwkCard.Macaddress  
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.IPAddress" -Value $($NtwkCard.IPAddress|?{$_-like"*.*"})
+                    Add-Member -InputObject $ReportedVM -MemberType NoteProperty -Name "networkcard${i}.Device" -Value $(($VM.Config.Hardware.Device|?{$_.key-eq$($NtwkCard.DeviceConfigId)}).GetType().Name)
+                    $i++
+                }
+                $ReportedVMs.add($ReportedVM)|Out-Null
+            }
+            $ReportedVMs|Export-CSV $FileName -NoTypeInformation -Encoding UTF8|Out-Null
+            $Message=Set-DisplayMessage -Description "Export complete!  Safe to disconnect from '$($VMServer) [$($VMServerIP)]' server."
+#            Disconnect-VIServer -Server $Connected -Force
+            Return $true
+        }Else{
+            $Message=Set-DisplayMessage -Description "Error: [Get-VMComputerData]: Failed to connect to vCenter using '$VMServerIP'.";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+            Return $false
+        }
+    }Catch [Exception]{
+        $Message="Error: [Get-VMComputerData]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+        Return $false
+    }
+}
+Function Get-VMExportedInfo{param([String]$MacAddress,[String]$GuestName,[Int]$Site)
+    NullVariables -ItemList 'ExportVMData','Left','NetworkMAC','SiteLabel','VMAdapter','VMComputerList','VMComputerName','VMGuest','VMIPAddress','VMNetwork','VMPowerState'
+    If($Site-eq0){
+        $MacAddress=""
+        $Left=$GuestName.Length-3
+        $SiteLabel=$GuestName.Substring($Left,1)
+        Switch($SiteLabel){
+            {($_-eq"b")-or($_-eq"y")}{$Site=2;Break}
+            Default{$Site=1;Break}
+        }
+    }Else{
+        $GuestName=""
+        Switch($Site){
+            "126"{$Site=2;Break}
+            Default{$Site=1;Break}
+        }
+    }
+    $VMPowerState="Off"
+    $VMComputerName=$null
+    $ExportVMData="VMComputerData-Site$Site.csv"
+    $VMComputerList=Import-Csv $ExportVMData|Sort -Property "Guest"
+    ForEach($VMGuest In $VMComputerList){
+        $VMComputerName=$VMGuest.Guest
+        For($i=0;$i-lt1;$i++){
+            $NetworkMAC=$VMGuest.$('networkcard'+$i+'.MacAddress')
+            If(($MacAddress-eq$NetworkMAC-and$MacAddress.Length-lt1)-or($VMComputerName-like"*$GuestName*"-and$GuestName.Length-lt1)){
+                $VMComputerName=$VMGuest.Guest
+                $VMNetwork=$VMGuest.$('networkcard'+$i+'.Network').ToString()
+                $VMIPAddress=$VMGuest.$('networkcard'+$i+'.IPAddress').ToString()
+                $VMAdapter=$VMGuest.$('networkcard'+$i+'.Device').ToString()
+                If($VMNetwork-ne$VMPoweredOffState){
+                    $VMPowerState="On"
+                }
+                $ParseArray=New-Object PSObject
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Found" -Value $true
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "HostName" -Value $VMComputerName
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Network" -Value $VMNetwork
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "IPAddress" -Value $VMIPAddress
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "Device" -Value $VMAdapter
+                $ParseArray|Add-Member -MemberType NoteProperty -Name "State" -Value $VMPowerState
+                Return $ParseArray
+                Break
+            }
+        }
+    }
+    Return $false
+}
+Function LoadModules(){
+   ReportStartOfActivity "Searching for $productShortName module components..."
+   
+   $loaded = Get-Module -Name $moduleList -ErrorAction Ignore | % {$_.Name}
+   $registered = Get-Module -Name $moduleList -ListAvailable -ErrorAction Ignore | % {$_.Name}
+   $notLoaded = $registered | ? {$loaded -notcontains $_}
+   
+   ReportFinishedActivity
+   
+   foreach ($module in $registered) {
+      if ($loaded -notcontains $module) {
+		 ReportStartOfActivity "Loading module $module"
+         
+		 Import-Module $module
+		 
+		 ReportFinishedActivity
+      }
+   }
+}
+Function LocateHostAD{param([string]$ComputerName)
+    Try{
+        $GetHostInfo=Get-ADComputer -Server $DNSHost -Identity "$ComputerName" -Properties SID -Credential $DomainAuth
+        $ADHostSID=$GetHostInfo.SID.value
+        $ps=new-object System.Diagnostics.Process
+        $ps.StartInfo.Filename=$PsGetSid
+        $ps.StartInfo.RedirectStandardOutput=$True
+        $ps.StartInfo.UseShellExecute=$false
+        $ps.start()
+        $ps.WaitForExit()
+        [string]$Out=$ps.StandardOutput.ReadToEnd()
+        ForEach($Line in $Out){
+            If($Line -ccontains $ADHostSID){
+                Return "";Break
+            }
+        }
+        Return $ComputerName
+    }
+    Catch{
+        Return "False"
+    }
+}
+Function NullVariables{param([Parameter(Position=0,Mandatory=$true)]$ItemList=@())
+    Try{
+        ForEach($Item In $ItemList){
+            If($Item.Length-lt1){
+            }Else{
+                Clear-Variable -Name "$Item" -Scope Global -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }Catch [Exception]{
+        If($_.Exception.Message-eq"Cannot find a variable with the name '$Item'."){
+        }Else{
+            $Message="Error: [NullVariables]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+        }
+    }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function ReportFinishedActivity() {
+   $script:completedActivities++
+   $script:percentComplete = (100.0 / $totalActivities) * $script:completedActivities
+   $script:percentComplete = [Math]::Min(99, $percentComplete)
+   
+   Write-Progress -Activity $loadingActivity -CurrentOperation $script:currentActivity -PercentComplete $script:percentComplete
+}
+Function ReportStartOfActivity($activity) {
+   $script:currentActivity = $activity
+   Write-Progress -Activity $loadingActivity -CurrentOperation $script:currentActivity -PercentComplete $script:percentComplete
+}
+Function Set-DisplayMessage{param([String]$Description,[String]$StatusMessage,$FontColor="Yellow",$Background="Black",$RightJustified=$true)
+    NullVariables -ItemList 'Height','Left','Message','Right','RightAlign','Width','WindowSize'
+    [Int]$RightAlign=$Buffer.Width
+    [Int]$WindowSize=$($RightAlign-$($Description.Length+1+$StatusMessage.Length+1))
+    If($Buffer.Width-le$WindowSize){
+        $Width=$WindowSize
+        For($Height=0;$Buffer.Width-le$Width;$Height++){
+            $Width=$Width-$Buffer.Width
+        }
+        $Buffer.Height=$Height
+        $WindowSize=$Width
+    }
+    If($RightJustified-eq$true){
+        For($Left=0;$Left-lt$WindowSize;$Left++){
+            $Description=" "+$Description
+        }
+    }ElseIf($RightJustified-eq$false){
+        For($Right=0;$Right-lt$WindowSize;$Right++){
+            $Description=$Description+" "
+        }
+    }ElseIf($StatusMessage.Length-gt0-or($Description.Length-lt1-and$StatusMessage.Length-lt1)){
+        For($Left=0;$Left-lt$WindowSize;$Left++){
+            $StatusMessage=$StatusMessage+" "
+        }
+    }
+    [String]$Message=$Description
+    If($FontColor[1].Length-gt1){
+        Write-Color "$Message"," $StatusMessage" -Color $FontColor[0],$FontColor[1]
+    }Else{
+        Write-Host $Message,$StatusMessage -ForegroundColor $FontColor -BackgroundColor $Background
+    }
+    If($Background-eq"DarkRed"){
+        Add-Content -Path $ResultFile -Value $($Message.Trim()) -PassThru
+    }
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Function Verify-IPAddress{[CmdletBinding()][Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true,Position=0)][ValidateScript({$_ -match [IPAddress]$_ })]
+Param([String]$IPAddress)
+    Begin{}
+    Process{
+        Try{
+            [IPAddress]$IPAddress
+        }Catch [Exception]{
+            $Message="Error: [Set-DisplayMessage]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Magenta -BackgroundColor Black
+            Return $false
+        }
+    }
+    End{}
+}
+LoadModules
+Write-Progress -Activity $loadingActivity -Completed
+Set-Location -Path "$($env:USERProfile)\Documents"
+Set-Variable -Name Counter -Value 0
+Set-Variable -Name LAcct -Value Admin
+Set-Variable -Name HostFQDN -Value $null
+Set-Variable -Name LSecure -Value 'd1$c0v3ry'
+Set-Variable -Name DNSHost -Value 10.118.0.10
+Set-Variable -Name Domain -Value utshare.local
+Set-Variable -Name VIServer -Value 10.118.1.77
+Set-Variable -Name RootDrive -Value $env:SystemRoot
+Set-Variable -Name DSecure -Value 'h$@.z2;6ym,gKpAP'
+Set-Variable -Name VMAuthAcct -Value sy1000829946@$Domain
+Set-Variable -Name SvcAcctCred -Value zasvcvdiauthacct@$Domain
+Set-Variable -Name HostName -Value $env:COMPUTERNAME.ToLower()
+Set-Variable -Name DNSDomain -Value $env:USERDOMAIN.ToLower()
+Set-Variable -Name WorkingPath -Value "$env:USERProfile\Documents\Passwords"
+Set-Variable -Name SecureFile -Value "$WorkingPath\Encrypted.pwd"
+If(Test-Path -Path $SecureFile){
+    Set-Variable -Name Extensions -Value 'pwd','key'
+    Set-Variable -Name KeyDate -Value $null
+    Set-Variable -Name PwdDate -Value $null
+    ForEach($FileType In $Extensions){
+        $Results=Get-ChildItem -Path $WorkingPath
+        $Extension=$($Results.Name).Split(".")[1]
+        If($Extension-eq$FileType){
+            $PwdDate=$($Results.CreationTime)[1]
+            If($KeyDate.Date-ne$PwdDate.Date){
+                Set-Variable -Name SecureString -Value 0
+            }Else{
+                $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            }
+        }Else{
+            $KeyDate=$($Results.CreationTime)[0]
+            $KeyName=$($Results.Name).Split(".")[0]
+            If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            }
+        }
+    }
+}Else{
+    $SecureString=Read-Host -Prompt "Enter your [$VMAuthAcct] credentials" -AsSecureString
+    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+    $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    Set-Variable -Name "EncryptionKeyFile" -Value ""
+    Set-Variable -Name "Characters" -Value ""
+    Set-Variable -Name "PrivateKey" -Value ""
+    Set-Variable -Name "SecureKey" -Value ""
+    [String]$Key=0
+    [Int]$Min=8
+    [Int]$Max=1024
+    $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+    If($Prompt.Length-eq0){$Prompt=8}
+    [Int]$RandomKey=Read-Host -Prompt $Prompt
+    If(Test-Path $WorkingPath){
+        $Results=Get-ChildItem -Path $WorkingPath -File
+        ForEach($File In $Results){
+            $FileName=$($File.Name).Split(".")[0]
+            If($FileName.length-eq$RandomKey){
+                $KeyFile="$($File.Name)"
+                $Key=$($KeyFile).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                    $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                    Break
+                }
+            }
+        }
+    }Else{
+        $Dir=MkDir $WorkingPath
+    }
+    If($PrivateKey.length-lt1){
+        Do{
+            Switch($RandomKey){
+                {($_-eq8)}{
+                    $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    Break
+                }
+                {($_-eq12)}{
+                    $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    Break
+                }
+                {($_-eq16)}{
+                    $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                    Break
+                }
+                {($Key.length-lt$RandomKey)}{
+                    $RandomKey+=1
+                    Break
+                }
+                {($Key.length-gt$RandomKey)}{
+                    $RandomKey-=1
+                    Break
+                }
+                Default{
+                    $RandomKey=16
+                    Break
+                }
+            }
+        }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+        $i=0
+        Do{
+            $i++
+            If(Test-Path -Path $SecureFile){
+                $SecureFile="$WorkingPath\Encrypted$i.pwd"
+            }
+        }While((Test-Path -Path $SecureFile)-eq$true)
+        $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+        Do{
+            [Int]$Characters=Read-Host -Prompt $Prompt
+            If(($Characters-ge$Min)-and($Characters-le$Max)){
+            }Else{
+                $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+            }
+        }Until(($Characters-ge$Min)-and($Characters-le$Max))
+        For($i=0;$i-le$Characters;$i++){
+            Switch($i){
+                {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                Default{$PrivateKey="";$Set="";Break}
+            }
+            $PrivateKey+=$Set
+        }
+        Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+        Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+        $Validate=Unprotect-String $PrivateKey $Key
+        If($Validate-ne$false){
+            $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        }
+        $SecureString=Read-Host -Prompt "Enter your [$VMAuthAcct] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+    }
+    Try{
+        $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        If($EncryptedString-ceq$Validate){}
+    }Catch [Exception]{
+        $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+    }
+}
+Set-Variable -Name HostLen -Value $HostName.Length
+Set-Variable -Name HostTrim -Value $HostName.Substring(0,$HostLen -3)
+Set-Variable -Name RegPath -Value 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce'
+Set-Variable -Name RegName -Value 'Customization'
+Set-Variable -Name RegValue -Value 'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -noe -c ". \"C:\scripts\RenHostName.ps1\" $true"'
+$PsGetSid=$RootDrive+'\System32\PsGetsid64.exe'
+$LSecure=ConvertTo-SecureString $LSecure -AsPlainText -Force
+$DSecure=ConvertTo-SecureString $DSecure -AsPlainText -Force
+$LocalAuth=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $LAcct,$LSecure
+$DomainAuth=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SvcAcctCred,$DSecure
+$VMWareAuth=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $VMAuthAcct,$SecureString
+If($Domain-ne$DNSDomain){
+    $Site=0
+    $Sites=1
+    [Int]$Counter=0
+    $VMServerIP=[System.Collections.ArrayList]@(0)
+    Do{
+        $Counter++
+        Switch($Counter){
+            "1"{$Prompt="Enter the IP Address of the Virtual Platform management server: ['$VIServer']";Break}
+            Default{$Prompt="Please enter a valid IP Address: ['$VIServer']";Break}
+        }
+    #    $VMServerIP[0]=Read-Host -Prompt $Prompt
+        If($VMServerIP[0].Length-le1){$VMServerIP[0]=$VIServer}
+        $Results=Verify-IPAddress $VMServerIP[0]
+        If($Results-eq$false){$VMServerIP[0]=-1}
+    }Until($VMServerIP[0]-gt0)
+    $ValidCredentials=$false
+    Do{
+        [String]$CurrentIP=""
+        If($VMServerIP-like"*,*"){
+            $CurrentIP=$VMServerIP.ToString().Split(",")[$Site]
+        }Else{
+            $CurrentIP=$VMServerIP
+        }
+        For($o=0;$o-le3;$o++){
+            Switch($o){
+                "0"{[Int]$Octate1=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+                "1"{[Int]$Octate2=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+                "2"{[Int]$Octate3=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+                "3"{[Int]$Octate4=$VMServerIP[$Site].ToString().Split(".")[$o];Break}
+            }
+        }
+        If($Octate2-eq118){
+            $Octate2=126
+        }
+        $Site++
+        $ExportVMData="VMComputerData-Site$Site.csv"
+        If(Test-Path -Path $ExportVMData){Remove-Item -Path $ExportVMData}
+        $Results=Get-SystemNetDNS -IPAddress $CurrentIP
+        NullVariables -ItemList 'AddressList','LineItem','RecordData','SearchType','SearchValue','SubArray','ValueCheck'
+        If($Results.Found-eq$true){
+            $VMServerDNS=$Results.HostName
+        }
+        For($l=0;$l-lt2;$l++){
+            Switch($l){
+                "1"{$Message="Beginning to export the current state of VMs to '.\$ExportVMData'.  Please wait, this export could take upto a few minutes to complete.";Break}
+                Default{$Message="";Break}
+            }
+            $Message=Set-DisplayMessage -Description $Message -FontColor White -Background Black -RightJustified $false
+        }
+        $Results=Get-VMComputerData -VCMManagerIP $CurrentIP -VMServer $VMServerDNS -AdminAccount $VMWareAuth -FileName $ExportVMData
+        If($Results-eq$true){
+            $Results="Successfully completed exporting the current state of Virtual Machine's from '$VMServerDNS'.",'White','Black'
+            $ValidCredentials=$true
+        }ElseIf($Results-eq$false){
+            $Results="Wasn't able to retrieve the current state of Virtual Machine's from '$CurrentIP'.",'Yellow','DarkRed'
+        }Else{
+            Break
+        }
+        For($l=0;$l-le2;$l++){
+            Switch($l){
+                "1"{$Message=$Results[0],$Results[1],$Results[2];Break}
+                Default{$Message="","Yellow","Black";Break}
+            }
+            $Message=Set-DisplayMessage -Description $Message[0] -FontColor $Message[1] -Background $Message[2] -RightJustified $false
+        }
+        $VMServerIP="$VMServerIP,$Octate1.$Octate2.$Octate3.$Octate4"
+    }While($Site-lt$Sites)
+    CLS
+    [Int]$Counter=0
+    Do{
+
+
+        Start-Process -FilePath $PsGetSid -WindowStyle Hidden
+        $GetSID=Get-Process|Where-Object{$_.WorkingSet-gt20000000}
+
+
+        $Counter+=1
+        If($Counter-eq1000){Break}
+        If($Counter-le9){$TestName=$HostTrim+"00"+$Counter}
+        If($Counter-ge10){$TestName=$HostTrim+"0"+$Counter}
+        If($Counter-ge100){$TestName=$HostTrim+$Counter}
+        $ComputerName=LocateHostAD($TestName)
+        $Report = @()
+        $VMs=Get-VM
+        $Invalid=0
+        Foreach($Server In $TestName){
+            $VMs|Where-Object{$_.ExtensionData.Guest.Hostname-like"*$($Server)*"}|%{
+                $Report+=New-Object PSObject -Property @{
+                   VM_Name=$_.Name
+                   DNS_Name=$_.ExtensionData.Guest.Hostname
+                }
+                $Invalid=+1;Break
+            }
+        }
+        If($Invalid-eq0-and($HostName-ne$TestName-and$HostName.Length-eq$TestName.ToString().Length)){
+            Set-ItemProperty -Path $RegPath -Name $RegName -Value $RegValue
+            Rename-Computer $TestName -LocalCredential $LocalAuth -Restart;Break
+        }
+        Set-ItemProperty -Path $RegPath -Name $RegName -Value $RegValue
+        Remove-ADComputer -Identity $HostName -Server $DNSHost -Credential $DomainAuth
+        Start-Sleep 5000 
+        Add-Computer -DomainName $Domain -NewName $HostName -Credential $DomainAuth -Restart -Force
+    }
+    Until($ComputerName-eq"True"-or$Counter-gt51)
+    Move-ADObject -Identity "CN='$HostName',CN=Computers,DC=utshare,DC=local" -TargetPath "OU=vdi-ardc,OU=AllWrkstns,DC=utshare,DC=local"
+}
\ No newline at end of file
diff --git a/PowerShell/General/RepairWMI.ps1 b/PowerShell/General/RepairWMI.ps1
new file mode 100644
index 0000000..a661ef7
--- /dev/null
+++ b/PowerShell/General/RepairWMI.ps1
@@ -0,0 +1,183 @@
+﻿Set-ExecutionPolicy -ExecutionPolicy ByPass
+Set-ExecutionPolicy Unrestricted
+Set-Variable -Name DomainName -Value $("$env:USERDNSDOMAIN").ToLower()
+Net Time /DOMAIN:$DomainName /SET /Y
+Clear-History;Clear-Host
+Set-Variable -Name CurrentLocation -Value $env:SystemRoot\System32
+Function PauseForCompletion($ProcessName){
+    $ProcessID=(Get-Process -Name $ProcessName).Id
+    Wait-Process -Id $ProcessID
+}
+Set-Variable -Name Remove_Account -Value "sy1000829946"
+Set-Variable -Name Profile_Path -Value "$env:SystemDrive\Users"
+$Remove_Account=$Profile_Path+"\"+$Remove_Account
+If(Test-Path $Remove_Account){sysdm.cpl}
+Function TimeStamp{$(Get-Date -UFormat "%D %T")}
+$logfile="$env:temp\LocalPolicyCheck.log"
+Function Test-IsRegistryPOLGood{
+    $PathToMachineRegistryPOLFile="$env:SytemRoot\System32\GroupPolicy\Machine\Registry.pol"
+    $PathToUserRegistryPOLFile="$env:SytemRoot\System32\GroupPolicy\User\Registry.pol"
+    If(!(Test-Path -Path $PathToMachineRegistryPOLFile -PathType Leaf)){}
+    Else{
+        If(((Get-Content -Encoding Byte -Path $PathToMachineRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+            If(Test-Path -Path $PathToMachineRegistryPOLFile){
+                Remove-Item $PathToMachineRegistryPOLFile -Force -Verbose
+                Return $False
+            }
+        }
+    }
+    If(!(Test-Path -Path $PathToUserRegistryPOLFile -PathType Leaf)){}
+    Else{
+        If(((Get-Content -Encoding Byte -Path $PathToUserRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+            If(Test-Path -Path $PathToUserRegistryPOLFile){
+                Remove-Item $PathToUserRegistryPOLFile -Force -Verbose
+                Return $False
+            }
+        }
+    }
+    Return $true
+}
+$Compliance="Compliant"
+If((Test-IsRegistryPOLGood)-eq$true){
+    $Compliance="Compliant"
+}Else{
+    $Compliance="Non-Compliant"
+}
+$(TimeStamp)+" Local Policy Check Returned: "+$Compliance | Out-File -FilePath $Logfile -Append -Encoding ascii
+$Compliance
+If($Compliance-eq"Non-Compliant"){
+    $Logfile="$PSScriptRoot\PolicyRemediator.log"
+    $(TimeStamp)+" Checking local policy integrity" | Out-File -FilePath $Logfile -Append -Encoding ascii
+    If(!(Test-Path -Path $PathToMachineRegistryPOLFile -PathType Leaf)){}
+    Else{
+        If(((Get-Content -Encoding Byte -Path $PathToMachineRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+            $(TimeStamp)+" Removing corrupt Machine Policy file" | Out-File -FilePath $Logfile -Append -Encoding ascii
+            Try{
+                ri $PathToMachineRegistryPOLFile -Confirm:$false -ErrorAction SilentlyContinue
+            }
+            Catch{
+                $(TimeStamp)+" Failed to remove policy file - Exiting"+(Write-Error -Message $_) | Out-File -FilePath $Logfile -Append -Encoding ascii
+                Exit 1
+            }
+        }
+    }
+    If(!(Test-Path -Path $PathToUserRegistryPOLFile -PathType Leaf)){}
+    Else{
+        If(((Get-Content -Encoding Byte -Path $PathToUserRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+            $(TimeStamp)+" Removing corrupt User Policy file" | Out-File -FilePath $Logfile -Append -Encoding ascii
+            Try {
+                ri $PathToUserRegistryPOLFile -Confirm:$false -ErrorAction SilentlyContinue
+            }
+            Catch {
+                $(TimeStamp)+" Failed to remove user policy file - Exiting"+(Write-Error -Message $_) | Out-File -FilePath $Logfile -Append -Encoding ascii
+                Exit 1
+            }
+        }
+    }
+}
+For($Count=0;$Count-le1;$Count++){
+    Switch($Count){
+        0{$CertType="Root";Break}
+        1{$CertType="CA";Break}
+    }
+    Set-Location Cert:\LocalMachine\$CertType;$CurrentPath=dir
+    ForEach($Certificate in $CurrentPath){
+        If($Certificate.Subject-like"*, DC=utshare, DC=local"){
+            $CurrentThumb=$Certificate.Thumbprint
+            Remove-Item -Path Cert:\LocalMachine\$CertType\$CurrentThumb -Verbose
+        }
+    }
+}
+Set-Location $CurrentLocation;gpupdate /force
+Set-Variable -Name WMI_Path -Value "$env:SystemRoot\System32\wbem\repository"
+Set-Variable -Name WMI_Path_Old -Value "$WMI_Path-old"
+Set-Variable -Name SCCM_ARDC_Server -Value "w16asccmdb01.inf.utshare.local"
+Set-Variable -Name SCCM_UDCC_Server -Value "w16bsccmdb01.inf.utshare.local"
+Set-Variable -Name SCCM_ARDC_Share -Value "SMS_DFW"
+Set-Variable -Name SCCM_UDCC_Share -Value "SMS_AUS"
+Set-Variable -Name SCCM_APPS -Value "sources\apps"
+Set-Variable -Name SCCM_Client -Value "Client\ccmsetup.exe"
+Set-Variable -Name IP_Address -Value $null
+Set-Variable -Name Octet_1 -Value $null
+Set-Variable -Name Octet_2 -Value $null
+Set-Variable -Name Octet_3 -Value $null
+Set-Variable -Name Octet_4 -Value $null
+Set-Variable -Name ByPass -Value $false
+Set-Variable -Name Primary_Site -Value $null
+Set-Variable -Name SCCM_Client_Install -Value $null
+Stop-Service -Name "Winmgmt" -Force
+$Services=Get-Service|Where-Object{($_.Status-eq'Running')}
+ForEach($Service In $Services){
+    Switch($Service.Name){
+        "Winmgmt"{$ByPass=$true;Break}
+        Default{Break}
+    }
+}
+If($ByPass-eq$false){
+    If(Test-Path $WMI_Path_Old){Remove-Item $WMI_Path_Old -Recurse -Force -Verbose}
+    Rename-Item -Path $WMI_Path -NewName $WMI_Path_Old
+    Start-Service -Name "Winmgmt"
+}
+$IP_Address=Get-NetIpAddress|Where-Object{$_.AddressFamily-eq"IPv4"}
+If($IP_Address-eq$null){
+    $IP_Address=((ipconfig|findstr [0-9].\.)[0]).Split()[-1]
+}Else{
+    $IP_Address=$IP_Address.IPAddress
+}
+ForEach($IPv4 In $IP_Address){
+    $Parser=$IPv4.Split(".")
+    For($O=0;$O-le3;$O++){
+        Switch($O){
+            0{$Octet_1=$Parser[$O];Break}
+            1{$Octet_2=$Parser[$O];Break}
+            2{$Octet_3=$Parser[$O];Break}
+            3{$Octet_4=$Parser[$O];Break}
+        }
+    }
+    If($Octet_1-eq10){
+        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+            $Primary_Site="\\$SCCM_ARDC_Server\$SCCM_ARDC_Share"
+        }
+        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+            $Primary_Site="\\$SCCM_UDCC_Server\$SCCM_UDCC_Share"
+        }
+        $SCCM_Client_Install="$Primary_Site\$SCCM_CLient";Break
+    }
+}
+Set-Variable -Name LocalInstall -Value "$env:USERPROFILE\Downloads\ccmsetup.exe"
+Set-Location -Path "$env:SystemRoot\System32"
+If(!(Test-Path "$env:SystemRoot\System32\cmtrace.exe")){
+    If(($Octet_2-eq118)-or($Octet_2-eq119)){
+        Copy-Item -Path "\\$SCCM_ARDC_Server\$SCCM_APPS\cmtrace.exe"
+    }
+    If(($Octet_2-eq126)-or($Octet_2-eq127)){
+        Copy-Item -Path "\\$SCCM_UDCC_Server\$SCCM_APPS\cmtrace.exe"
+    }
+}
+If(!(Test-Path "$env:SystemRoot\System32\reboot.cmd")){
+    If(($Octet_2-eq118)-or($Octet_2-eq119)){
+        Copy-Item -Path "\\$SCCM_ARDC_Server\$SCCM_APPS\reboot.cmd"
+    }
+    If(($Octet_2-eq126)-or($Octet_2-eq127)){
+        Copy-Item -Path "\\$SCCM_UDCC_Server\$SCCM_APPS\reboot.cmd"
+    }
+}
+If(!($Primary_Site-eq$null)){
+    If(!(Test-Path $LocalInstall)){
+        Copy-Item -Path "$SCCM_Client_Install" -Destination $LocalInstall
+    }
+    For($L=0;$L-le2;$L++){
+        Switch($L){
+            0{
+                Start-Process -FilePath $LocalInstall -ArgumentList "/uninstall"
+                PauseForCompletion("ccmsetup");Break}
+            1{
+                Remove-Item "$env:systemroot\ccm*" -Recurse -Force -Verbose;Break}
+            2{
+                Start-Process -FilePath $LocalInstall
+                PauseForCompletion("ccmsetup");Break}
+        }
+    }
+}
+Set-ExecutionPolicy Restricted
+Logoff
diff --git a/PowerShell/General/RepairWMI_failed.ps1 b/PowerShell/General/RepairWMI_failed.ps1
new file mode 100644
index 0000000..1ac60fa
--- /dev/null
+++ b/PowerShell/General/RepairWMI_failed.ps1
@@ -0,0 +1,220 @@
+﻿Set-ExecutionPolicy -ExecutionPolicy ByPass
+Set-ExecutionPolicy Unrestricted
+Set-Variable -Name DomainName -Value $("$env:USERDNSDOMAIN").ToLower()
+Set-Variable -Name WMI_Path -Value "$env:SystemRoot\System32\wbem\repository"
+Set-Variable -Name WMI_Path_Old -Value "$WMI_Path-old"
+Set-Variable -Name SCCM_ARDC_Server -Value "w16asccmdb01.inf.utshare.local"
+Set-Variable -Name SCCM_UDCC_Server -Value "w16bsccmdb01.inf.utshare.local"
+Set-Variable -Name SCCM_ARDC_Share -Value "SMS_DFW"
+Set-Variable -Name SCCM_UDCC_Share -Value "SMS_AUS"
+Set-Variable -Name SCCM_APPS -Value "sources\apps"
+Set-Variable -Name SCCM_Client -Value "Client\ccmsetup.exe"
+Set-Variable -Name IP_Address -Value $null
+Set-Variable -Name Octet_1 -Value $null
+Set-Variable -Name Octet_2 -Value $null
+Set-Variable -Name Octet_3 -Value $null
+Set-Variable -Name Octet_4 -Value $null
+Set-Variable -Name Environment -Value $null
+Set-Variable -Name Primary_Site -Value $null
+Set-Variable -Name SCCM_Client_Install -Value $null
+Set-Variable -Name CurrentLocation -Value $env:SystemRoot\System32
+Set-Variable -Name Remove_Account -Value "sy1000829946"
+Set-Variable -Name Profile_Path -Value "$env:SystemDrive\Users"
+Net Time /DOMAIN:$DomainName /SET /Y
+Clear-History;Clear-Host
+Function PauseForCompletion($ProcessName){
+    $ProcessID=(Get-Process -Name $ProcessName).Id
+    Wait-Process -Id $ProcessID
+}
+Function Test-IsRegistryPOLGood{
+    $PathToMachineRegistryPOLFile="$env:SytemRoot\System32\GroupPolicy\Machine\Registry.pol"
+    $PathToUserRegistryPOLFile="$env:SytemRoot\System32\GroupPolicy\User\Registry.pol"
+    If(!(Test-Path -Path $PathToMachineRegistryPOLFile -PathType Leaf)){}
+    Else{
+        If(((Get-Content -Encoding Byte -Path $PathToMachineRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+            If(Test-Path -Path $PathToMachineRegistryPOLFile){
+                Remove-Item $PathToMachineRegistryPOLFile -Force
+                Return $False
+            }
+        }
+    }
+    If(!(Test-Path -Path $PathToUserRegistryPOLFile -PathType Leaf)){}
+    Else{
+        If(((Get-Content -Encoding Byte -Path $PathToUserRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+            If(Test-Path -Path $PathToUserRegistryPOLFile){
+                Remove-Item $PathToUserRegistryPOLFile -Force
+                Return $False
+            }
+        }
+    }
+    Return $true
+}
+Function TimeStamp{$(Get-Date -UFormat "%D %T")}
+For($Count=0;$Count-le1;$Count++){
+    Switch($Count){
+        0{$CertType="Root";Break}
+        1{$CertType="CA";Break}
+    }
+    Set-Location Cert:\LocalMachine\$CertType;$CurrentPath=dir
+    ForEach($Certificate in $CurrentPath){
+        If($Certificate.Subject-like"*, DC=utshare, DC=local"){
+            $CurrentThumb=$Certificate.Thumbprint
+            Remove-Item -Path Cert:\LocalMachine\$CertType\$CurrentThumb
+        }
+    }
+}
+Set-Location $CurrentLocation
+$IP_Address=Get-NetIpAddress|Where-Object{$_.AddressFamily-eq"IPv4"}
+If(!($IP_Address-eq$null)){
+    ForEach($IPv4 In $IP_Address.IPAddress){
+        $Parser=$IPv4.Split(".")
+        For($O=0;$O-le3;$O++){
+            Switch($O){
+                0{$Octet_1=$Parser[$O];Break}
+                1{
+                    $Octet_2=$Parser[$O]
+                    If($Octet_1-eq10){
+                        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+                            $Primary_Site="\\$SCCM_ARDC_Server\$SCCM_ARDC_Share"
+                        }
+                        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+                            $Primary_Site="\\$SCCM_UDCC_Server\$SCCM_UDCC_Share"
+                        }
+                        $SCCM_Client_Install="$Primary_Site\$SCCM_CLient"
+                    };Break}
+                2{
+                    $Octet_3=$Parser[$O]
+                    Switch($Octet_3){
+                        {($_-eq0)-or($_-eq1)}{$Environment="inf";Break}
+                        {($_-ge4)-and($_-le7)-or
+                            ($_-ge20)-and($_-le23)-or
+                            ($_-ge36)-and($_-le39)-or
+                            ($_-ge52)-and($_-le55)-or
+                            ($_-ge68)-and($_-le71)-or
+                            ($_-ge84)-and($_-le87)}{$Environment="prd";Break}
+                        {($_-ge8)-and($_-le11)-or
+                            ($_-ge24)-and($_-le27)-or
+                            ($_-ge40)-and($_-le43)-or
+                            ($_-ge56)-and($_-le59)-or
+                            ($_-ge72)-and($_-le75)-or
+                            ($_-ge88)-and($_-le91)}{$Environment="nrp";Break}
+                        {($_-ge12)-and($_-le15)-or
+                            ($_-ge28)-and($_-le31)-or
+                            ($_-ge44)-and($_-le47)-or
+                            ($_-ge60)-and($_-le63)-or
+                            ($_-ge76)-and($_-le79)-or
+                            ($_-ge92)-and($_-le95)}{$Environment="non";Break}
+                        {($_-eq18)-or($_-eq19)}{$Environment="vdi";Break}
+                    };Break}
+                3{$Octet_4=$Parser[$O];Break}
+            }
+            If($Octet_1-eq127){Break}
+        }
+    }
+    Set-Variable -Name Counter -Value 0
+    Set-Variable -Name Service -Value $null
+    Set-Variable -Name ThisComputer -Value $("$env:COMPUTERNAME.$Environment.$env:USERDNSDOMAIN").ToLower()
+    $Remove_Account=$Profile_Path+"\"+$Remove_Account
+    If(Test-Path $Remove_Account){
+        explorer $Remove_Account
+        sysdm.cpl
+    }
+    $logfile="$env:temp\LocalPolicyCheck.log"
+    $Compliance="Compliant"
+    If((Test-IsRegistryPOLGood)-eq$true){
+        $Compliance="Compliant"
+    }Else{
+        $Compliance="Non-Compliant"
+    }
+    $(TimeStamp)+" Local Policy Check Returned: "+$Compliance | Out-File -FilePath $Logfile -Append -Encoding ascii
+    If($Compliance-eq"Non-Compliant"){
+        $Logfile="$PSScriptRoot\PolicyRemediator.log"
+        $(TimeStamp)+" Checking local policy integrity" | Out-File -FilePath $Logfile -Append -Encoding ascii
+        If(!(Test-Path -Path $PathToMachineRegistryPOLFile -PathType Leaf)){}
+        Else{
+            If(((Get-Content -Encoding Byte -Path $PathToMachineRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+                $(TimeStamp)+" Removing corrupt Machine Policy file" | Out-File -FilePath $Logfile -Append -Encoding ascii
+                Try{
+                    ri $PathToMachineRegistryPOLFile -Confirm:$false -ErrorAction SilentlyContinue
+                }
+                Catch{
+                    $(TimeStamp)+" Failed to remove policy file - Exiting"+(Write-Error -Message $_) | Out-File -FilePath $Logfile -Append -Encoding ascii
+                    Exit 1
+                }
+            }
+        }
+        If(!(Test-Path -Path $PathToUserRegistryPOLFile -PathType Leaf)){}
+        Else{
+            If(((Get-Content -Encoding Byte -Path $PathToUserRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+                $(TimeStamp)+" Removing corrupt User Policy file" | Out-File -FilePath $Logfile -Append -Encoding ascii
+                Try {
+                    ri $PathToUserRegistryPOLFile -Confirm:$false -ErrorAction SilentlyContinue
+                }
+                Catch {
+                    $(TimeStamp)+" Failed to remove user policy file - Exiting"+(Write-Error -Message $_) | Out-File -FilePath $Logfile -Append -Encoding ascii
+                    Exit 1
+                }
+            }
+        }
+    }
+    gpupdate /force
+    Do{
+        $Counter++
+        $Service=Get-Service -Name "CcmExec"
+        If($Service-eq$null){Break}
+        Switch($Service.Status){
+            'Starting'{Break}
+            'Running'{$Service=Stop-Service -Name "CcmExec" -Force;Break}
+            'StopPending'{
+                If($Counter-ge500){
+                    (Get-WmiObject -ComputerName $ThisComputer -Class Win32_Process -Filter "name like 'CcmExe%'").terminate()
+                };Break}
+        }
+    }Until($Service.Status-eq'Stopped')
+    $Service=Stop-Service -Name "Winmgmt" -Force
+    Do{
+        $Service=Get-Service -Name "Winmgmt"
+        If($Service.Status-eq'Stopped'){
+            If(Test-Path $WMI_Path_Old){Remove-Item $WMI_Path_Old -Recurse -Force}
+            Rename-Item -Path $WMI_Path -NewName $WMI_Path_Old
+            $Service=Start-Service -Name "Winmgmt"
+        }
+    }While(($Service.Status-eq'Stopped')-or($Service.Status-eq'Stopping'))
+    Set-Variable -Name LocalInstall -Value "$env:USERPROFILE\Downloads\ccmsetup.exe"
+    Set-Location -Path "$env:SystemRoot\System32"
+    If(!(Test-Path "$env:SystemRoot\System32\cmtrace.exe")){
+        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+            Copy-Item -Path "\\$SCCM_ARDC_Server\$SCCM_APPS\cmtrace.exe"
+        }
+        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+            Copy-Item -Path "\\$SCCM_UDCC_Server\$SCCM_APPS\cmtrace.exe"
+        }
+    }
+    If(!(Test-Path "$env:SystemRoot\System32\reboot.cmd")){
+        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+            Copy-Item -Path "\\$SCCM_ARDC_Server\$SCCM_APPS\reboot.cmd"
+        }
+        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+            Copy-Item -Path "\\$SCCM_UDCC_Server\$SCCM_APPS\reboot.cmd"
+        }
+    }
+    If(!($Primary_Site-eq$null)){
+        If(!(Test-Path $LocalInstall)){
+            Copy-Item -Path "$SCCM_Client_Install" -Destination $LocalInstall
+        }
+        For($L=0;$L-le2;$L++){
+            Switch($L){
+                0{
+                    Start-Process -FilePath $LocalInstall -ArgumentList "/uninstall"
+                    PauseForCompletion("ccmsetup");Break}
+                1{
+                    Remove-Item "$env:systemroot\ccm*" -Recurse -Force;Break}
+                2{
+                    Start-Process -FilePath $LocalInstall
+                    PauseForCompletion("ccmsetup");Break}
+            }
+        }
+    }
+}
+Set-ExecutionPolicy Restricted
+Logoff
diff --git a/PowerShell/General/Reset-LocalAdminPassword.ps1 b/PowerShell/General/Reset-LocalAdminPassword.ps1
new file mode 100644
index 0000000..d8a46af
--- /dev/null
+++ b/PowerShell/General/Reset-LocalAdminPassword.ps1
@@ -0,0 +1,94 @@
+﻿Function Test-ADCredential{[CmdletBinding()]Param($UserName,$Password,$HostName)
+    if(!($UserName)-or!($Password)){
+        Write-Warning 'Test-ADCredential: Please specify both user name and password'
+    }else{
+        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
+        $DS=New-Object System.DirectoryServices.AccountManagement.PrincipalContext('machine',$HostName)
+        $DS.ValidateCredentials($UserName,$Password)
+    }
+}
+Function Write-CustomError{param([System.Exception]$exception,$targetObject,[String]$errorID,[System.Management.Automation.ErrorCategory]$errorCategory="NotSpecified")
+    $errorRecord=new-object System.Management.Automation.ErrorRecord($exception,$errorID,$errorCategory,$targetObject)
+    $PSCmdlet.WriteError($errorRecord)
+}
+Clear
+$ScriptName=$MyInvocation.MyCommand.Name
+Write-Host "Beginning '$ScriptName' to reset the local administrator's account password."
+Set-Location -Path "C:\Users\Public\Documents"
+$ExportFile="ExportList.csv"
+$ImportForPMP="ImportForPMP.csv"
+If(Test-Path $ExportFile){Remove-Item -Path $ExportFile}
+Write-Host "Exporting list of domain computers to '$ExportFile'."
+Get-ADComputer -Filter * -Property * | Select-Object Name,OperatingSystem,DNSHostName,DistinguishedName | Export-CSV $ExportFile -NoTypeInformation -Encoding UTF8
+Write-Host "Completed export of domain computers to '$ExportFile'."
+Write-Host "Adding exported list of domain computers to memory."
+$ComputerList=Import-Csv $ExportFile
+$ResultFile="Results.log"
+$ErrorSettingPWD=$true
+$DCCounter=0
+$ImportOS="Windows"
+Write-Host "Completed import of domain computers to memory."
+If(Test-Path $ResultFile){Remove-Item -Path $ResultFile}
+If(Test-Path $ImportForPMP){Remove-Item -Path $ImportForPMP}
+#Add-Content -Path $ImportForPMP -Value 'ResourceName,DNSName,Description,Department,Location,ResourceType,ResourceURL,UserAccount,Password,Notes,DistinguishedName'
+Write-Host "Starting to process imported list of domain computers."
+Write-Host ""
+ForEach($Computer In $ComputerList){
+    If($($Computer.OperatingSystem)-like"Windows Server*"){
+        $ErrorSettingPWD=$true
+        $OnlineStatus="Offline"
+        $DomainController=$false
+        $DNSHostName=@($($Computer.DNSHostName))
+        Write-Host "Working on current computer:                     $DNSHostName"
+        If(@($($Computer.DistinguishedName))-like"*OU=Domain Controllers*"){
+            $DCCounter++;$DomainController=$true
+        }
+        If(($DCCounter-le1-and$DomainController-eq$true)-or($DomainController-eq$false)){
+            $AdminPassword='y&8RA!u*6ZC2-%zh'
+            $HostName=@($($Computer.Name))
+            $ComputerADSI=[ADSI] "WinNT://$($Computer.DNSHostName),Computer"
+            foreach($childObject in $ComputerADSI.Children){
+                if($childObject.Class-ne"User"){
+                    continue
+                }
+                $type="System.Security.Principal.SecurityIdentifier"
+                $childObjectSID=new-object $type($childObject.objectSid[0],0)
+                if($childObjectSID.Value.EndsWith("-500")){
+                    $UserName=@($($childObject.Name[0]))
+                    Write-Host "Local Administrator account name:                $UserName"
+                    Write-Host "Local Administrator account SID:                 $($childObjectSID.Value)"
+                    try{
+                        Write-Host "Attempting to change password on                 '$HostName'."
+                        ([ADSI] "WinNT://$HostName/$UserName").SetPassword($AdminPassword)
+                        $Resource="$HostName,$DNSHostName,,,,$ImportOS,,$UserName,$AdminPassword,,"
+                        $Resource | foreach{Add-Content -Path $ImportForPMP -Value $_}
+                        $ErrorSettingPWD=$false
+                    }catch [System.Management.Automation.MethodInvocationException]{
+                        $message="Cannot reset password for '$HostName\$UserName' due the following error: '$($_.Exception.InnerException.Message)'"
+                        $exception=new-object ($_.Exception.GetType().FullName)($message,$_.Exception.InnerException)
+                        Write-CustomError $exception "$HostName\$UserName" $ScriptName
+                    }
+                    Write-Host "Verifying the password was changed on            '$HostName'."
+                    If(Test-ADCredential($UserName)($AdminPassword)($HostName)){
+                        $OnlineStatus="Online"
+                        Write-Host "Successfully changed the password on             '$HostName'."
+                    }
+                    break
+                }
+            }
+            If($ErrorSettingPWD-eq$true){
+                $Message="Wasn't able to set the password for $UserName on server: $DNSHostName."
+                Add-Content -Path $ResultFile -Value $Message -PassThru
+            }ElseIf($OnlineStatus-eq"Offline"){
+                $Message="Server: $DNSHostName is not accessible."
+                Add-Content -Path $ResultFile -Value $Message -PassThru
+            }
+        }
+        Write-Host ""
+    }
+}
+Write-Host ""
+Write-Host "Completed processing imported list of local administrator's account password."
+If(Test-Path $ExportFile){Remove-Item -Path $ExportFile -Force}
+Write-Host "Deleted the temporary file '$ExportFile'."
+Set-Location -Path "C:\Windows\System32"
\ No newline at end of file
diff --git a/PowerShell/General/ResetFailedVM.ps1 b/PowerShell/General/ResetFailedVM.ps1
new file mode 100644
index 0000000..c0dcfd2
--- /dev/null
+++ b/PowerShell/General/ResetFailedVM.ps1
@@ -0,0 +1,421 @@
+﻿Clear-Host;Clear-History
+$Global:Validate=$null
+$Global:Domain=("utshare.local")
+$Global:DomainUser=(($env:USERNAME+"@"+$Domain).ToLower())
+$Global:DnsServer=("dca01."+$Domain)
+$ScriptPath=$MyInvocation.MyCommand.Definition
+$ScriptName=$MyInvocation.MyCommand.Name
+Set-Location ($ScriptPath.Replace($ScriptName,""))
+Set-Variable -Name DateTime -Value (Get-Date)
+Set-Variable -Name SecureCredentials -Value $null
+Set-Variable -Name vSphere -Value ("vcmgr01a.inf."+$Domain)
+Set-Variable -Name LogFile -Value ($ScriptName.Replace("ps1","log"))
+Set-Variable -Name LogFile -Value ($env:USERPROFILE+"\Desktop\"+$LogFile)
+Set-Variable -Name SendTo -Value ("GRP-SIS_SysAdmin@utsystem.edu")
+Set-Variable -Name MailServer -Value ("mail.utshare.utsystem.edu")
+Set-Variable -Name EndTime -Value $null
+Set-Variable -Name Sender -Value $null
+Function LoadModules(){
+   ReportStartOfActivity "Searching for $ProductShortName module components..."
+   $Loaded=Get-Module -Name $ModuleList -ErrorAction Ignore|% {$_.Name}
+   $Registered=Get-Module -Name $ModuleList -ListAvailable -ErrorAction Ignore|% {$_.Name}
+   $NotLoaded=$Registered|? {$Loaded -notcontains $_}
+   ReportFinishedActivity
+   Foreach($Module In $Registered){
+      If($Loaded -notcontains $Module){
+		 ReportStartOfActivity "Loading module $Module"
+		 Import-Module $Module
+		 ReportFinishedActivity
+      }
+   }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function ReportStartOfActivity($Activity){
+   $Script:CurrentActivity=$Activity
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ReportFinishedActivity(){
+   $Script:CompletedActivities++
+   $Script:PercentComplete=(100.0/$TotalActivities)*$Script:CompletedActivities
+   $Script:PercentComplete=[Math]::Min(99,$PercentComplete)
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ResolveIPAddress{Param([String][Parameter(Mandatory=$true)]$IP="",[Parameter(Mandatory=$true)]$NetBIOS="",$Environment="")
+    $ErrorActionPreference='ContinueSilently'
+    Try{
+        If($IP-eq"0.0.0.0"){
+            $FQDN=($NetBIOS+"."+$Environment+"."+$Domain)
+            $AddressList=([System.Net.Dns]::GetHostByName($FQDN).AddressList)
+            $IP=$AddressList.IPAddressToString
+            $1st=($IP.Split(".")[0]);$2nd=($IP.Split(".")[1]);$3rd=($IP.Split(".")[2]);$4th=($IP.Split(".")[3])
+            $ZoneName=($3rd+"."+$2nd+"."+$1st+".in-addr.arpa")
+            Add-DnsServerResourceRecordPtr -Name ($4th) -ZoneName $ZoneName -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $FQDN
+            Return $AddressList
+        }Else{
+            $FQDN=[System.Net.Dns]::GetHostByAddress($IP).HostName
+            Return ($FQDN.ToLower())
+        }
+    }Catch{
+        $1st=($IP.Split(".")[0]);$2nd=($IP.Split(".")[1]);$3rd=($IP.Split(".")[2]);$4th=($IP.Split(".")[3])
+        $env=VerifyEnvironment -3rdOctate '$3rd'
+        $FQDN=($NetBIOS+"."+$env+"."+$Domain).ToLower()
+        If($_.Exception.Message-eq'Exception calling "GetHostByAddress" with "1" argument(s): "The requested name is valid, but no data of the requested type was found"'){
+            Add-DnsServerResourceRecordPtr -Name ($4th) -ZoneName ($3rd+"."+$2nd+"."+$1st+".in-addr.arpa") -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $FQDN
+        }ElseIf($_.Exception.Message-eq'Exception calling "GetHostByName" with "1" argument(s): "No such host is known"'){
+            Add-DnsServerResourceRecordA -Name $NetBIOS -ZoneName ($env+"."+$Domain).ToLower() -AllowUpdateAny -IPv4Address $IP -TimeToLive 01:00:00 -CreatePtr
+        }Else{
+            Write-Host $_.Exception.Message -ForegroundColor Green
+        }
+    }
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$true)]$SecureUser="",[String][Parameter(Mandatory=$true)]$Domain="")
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $Script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Function VerifyEnvironment{Param([String][Parameter(Mandatory=$true)]$3rdOctate="")
+    $SubDomain=$null
+    Switch($3rdOctate){
+        {($_-ge4-and$_-le7)-or($_-ge20-and$_-le23)-or($_-ge36-and$_-le39)-or($_-ge52-and$_-le55)-or($_-ge68-and$_-le712)-or($_-ge84-and$_-le87)}{$SubDomain="prd";Break}
+        {($_-eq10)-or($_-eq26)-or($_-eq42)-or($_-eq58)-or($_-eq74)-or($_-eq90)}{$SubDomain="trn";Break}
+        {($_-eq11)-or($_-eq27)-or($_-eq43)-or($_-eq59)-or($_-eq75)-or($_-eq91)}{$SubDomain="sbx";Break}
+        {($_-eq12)-or($_-eq28)-or($_-eq44)-or($_-eq60)-or($_-eq76)-or($_-eq92)}{$SubDomain="tst";Break}
+        {($_-eq13)-or($_-eq29)-or($_-eq45)-or($_-eq61)-or($_-eq77)-or($_-eq93)}{$SubDomain="dev";Break}
+        {($_-eq14)-or($_-eq30)-or($_-eq46)-or($_-eq62)-or($_-eq78)-or($_-eq94)}{$SubDomain="dmo";Break}
+        {($_-eq8)-or($_-eq24)-or($_-eq40)-or($_-eq56)-or($_-eq72)-or($_-eq88)}{$SubDomain="uat";Break}
+        {($_-eq9)-or($_-eq25)-or($_-eq41)-or($_-eq57)-or($_-eq73)-or($_-eq89)}{$SubDomain="fly";Break}
+        {($_-eq64)-or($_-eq65)}{$SubDomain="bkp";Break}
+        {($_-eq18)-or($_-eq19)}{$SubDomain="vdi";Break}
+        {($_-eq0)-or($_-eq1)}{$SubDomain="inf";Break}
+        {($_-eq2)}{$SubDomain="mgt";Break}
+        Default{$SubDomain="all";Break}
+    }Return $SubDomain
+}
+Switch($DomainUser){
+    {($_-like"sy10*")-or($_-like"sy60*")}{Break}
+    Default{$DomainUser=(("sy1000829946@"+$Domain).ToLower());Break}
+}
+$Validate=SetCredentials -SecureUser $DomainUser -Domain ($Domain).Split(".")[0]
+If($SecureCredentials-eq$null){$SecureCredentials=get-credential};$Validate=$null
+
+#Load PowerCli Context
+$Script:PromptForCEIP=$false
+$ModuleList=@(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+)
+$ProductName="PowerCli"
+$ProductShortName="PowerCli"
+$LoadingActivity="Loading $ProductName"
+$Script:CompletedActivities=0
+$Script:PercentComplete=0
+$Script:CurrentActivity=""
+$Script:totalActivities=$ModuleList.Count+1
+LoadModules
+$PowerCliFriendlyVersion=[VMware.VimAutomation.Sdk.Util10.ProductInfo]::PowerCliFriendlyVersion
+$Host.ui.RawUI.WindowTitle=$PowerCliFriendlyVersion
+Try{
+	$configuration=Get-PowerCliConfiguration -Scope Session
+	If($PromptForCEIP-and$configuration.ParticipateInCEIP-eq$null-and[VMware.VimAutomation.Sdk.Util10Ps.CommonUtil]::InInteractiveMode($Host.UI)){
+		$caption="Participate in VMware Customer Experience Improvement Program (CEIP)"
+		$message=`
+			"VMware's Customer Experience Improvement Program (`"CEIP`") provides VMware with information "+
+			"that enables VMware to improve its Products and services, to fix problems, and to advise you "+
+			"on how best to deploy and use our Products.  As part of the CEIP, VMware collects technical information "+
+			"about your organization’s use of VMware Products and services on a regular basis in association "+
+			"with your organization’s VMware license key(s).  This information does not personally identify "+
+			"any individual."+
+			"`n`nFor more details: press Ctrl+C to exit this prompt and type `"help about_ceip`" to see the related help article."+
+			"`n`nYou can join or leave the program at any time by executing: Set-PowerCliConfiguration -Scope User -ParticipateInCEIP `$true or `$false."
+		$AcceptLabel="&Join"
+		$choices=(
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList $AcceptLabel,"Participate in the CEIP"),
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList "&Leave","Don't participate")
+		)
+		$userChoiceIndex = $Host.UI.PromptForChoice($caption, $message, $choices, 0)
+		$participate = $choices[$userChoiceIndex].Label -eq $AcceptLabel
+		If($participate){
+            [VMware.VimAutomation.Sdk.Interop.V1.CoreServiceFactory]::CoreService.CeipService.JoinCeipProgram();
+        }Else{
+            Set-PowerCliConfiguration -Scope User -ParticipateInCEIP $false -Confirm:$false | Out-Null
+        }
+    }
+}Catch{}
+Write-Progress -Activity $LoadingActivity -Completed
+
+#Connect vSphere
+$Validate=Connect-VIServer -Server $vSphere -credential $SecureCredentials;Clear
+If($Validate-ne$null){
+    If(!(Test-Path -Path ($env:USERPROFILE+"\Desktop\ServerList.txt"))){
+        (Get-VM).Name|Sort|Out-File ($env:USERPROFILE+"\Desktop\ServerList.txt")
+    }
+    If(Test-Path -Path $LogFile){Remove-Item $LogFile -ErrorAction SilentlyContinue}
+    #Health Check
+    Foreach($Server In [System.IO.File]::ReadLines($env:USERPROFILE+"\Desktop\ServerList.txt")){
+        $Bypass=$true
+        $NetBIOS=$null
+        $VMStatus=$null
+        $HostName=$null
+        $SubDomain="inf"
+        $IPAddress=$null
+        $ServerName=$null
+        $FolderName=$null
+        $DateTime=Get-Date
+        $PowerState="PoweredOff"
+        $IPAddressToString=$null
+        If($Server-like"*.*"){
+            $Server=(($Server).Split(("."))[0])
+        }
+        $Sender=($Server+"@utsystem.edu")
+        $VMStatus=Get-VM|Where-Object{$_.Name-like($Server+"*")}|Select *
+        If($VMStatus-ne$null){
+            $Hostname=$VMStatus.Name
+            $PowerState=$VMStatus.PowerState
+            $FolderName=($VMStatus.Folder).Name
+            If($FolderName-eq"UTD IaaS (Root)"){
+                $Reason=("host VM is not being managed by our team")
+            }Else{
+                If(($PowerState-eq"PoweredOn")-and($PowerState-ne$null)){
+                    If($Hostname-like"*.*"){
+                        $NetBIOS=($Hostname.Split(".")[0])
+                        $SubDomain=($Hostname.Split(".")[1])
+                    }Else{
+                        $NetBIOS=$Hostname
+                    }
+                    $ErrorActionPreference='Continue'
+                    Try{
+                        $IPAddressToString=([System.Net.Dns]::GetHostByName($NetBIOS).AddressList).IPAddressToString
+                    }Catch{
+                        $IPAddressToString=(ResolveIPAddress -IP "0.0.0.0" -NetBIOS $NetBIOS -Environment $SubDomain).IPAddressToString
+                    }
+                    If($IPAddressToString-ne$null){
+                        ForEach($IP In $IPAddressToString){
+                            If(($IP-ne$null)-and($IP.Split(".")[0]-eq"10")-and{($IP.Split(".")[1]-eq"118")-or($IP.Split(".")[1]-eq"126")}){
+                                $ServerName=ResolveIPAddress -IP $IP -NetBIOS $NetBIOS -Environment $SubDomain
+                                If($ServerName-ne$null){
+                                    $Bypass=$false
+                                }Else{
+                                    $Bypass=$true
+                                }
+                            }Else{
+                                $Reason=("host VM has an invalid IP Address: ["+$IP+"]")
+                            }
+                        }
+                    }Else{
+                        $Reason=("host VM isn't registered in DNS")
+                    }
+                }Else{
+                    $Reason=("host VM is currently powered off")
+                }
+            }
+        }
+        Write-Host ("Currently working on hostname(VM): '"+$Hostname+"' and is currently: "+$PowerState)
+        If(($PowerState-eq"PoweredOn")-and($Bypass-eq$false)){
+            ("Currently working on hostname(VM): ["+$Hostname+"] and is currently: powered on.")|Out-File $LogFile -Append
+            If(Test-Connection -ComputerName $ServerName -Count 3 -BufferSize 256 -ThrottleLimit 32){
+                (“`tTesting connection to $ServerName is successful”)|Out-File $LogFile -Append
+#                Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" is responding") -Body ($ServerName+" is responding again.") -SmtpServer $MailServer
+            }Else{
+                $EndTime=Get-Date
+                "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" not responding") -Body ($ServerName+" not responding, waiting 10 seconds and will try again.") -SmtpServer $MailServer
+                "Waiting 10 seconds"
+                Start-Sleep 10
+                If(!(Test-Connection -ComputerName $ServerName -Count 3 -BufferSize 256 -ThrottleLimit 32)){
+                    $EndTime=Get-Date
+                    "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                    (Get-VM -Name $Hostname).ExtensionData.ResetVM() 
+#                    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ("Server: '"+$ServerName+"' crashed!") -Body ($ServerName+" must have crashed and was reset.") -SmtpServer $MailServer
+                    Start-Sleep 30
+                }Else{
+                    $EndTime=Get-Date
+                    “Successful `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" is responding") -Body ($ServerName+" is responding again and was not reset.") -SmtpServer $MailServer
+                }
+            }
+        }Else{
+            ("Bypassing ["+$Server+"] because "+$Reason+".")|Out-File $LogFile -Append
+        }
+        ("----------------------------------------------------------------------------------------------------")|Out-File $LogFile -Append
+    }
+}
+Rename-Item -Path ($env:USERPROFILE+"\Desktop\ServerList.txt") -NewName "ProcessedList.txt" -Force
+Set-Location ($env:SystemRoot+"\System32")
\ No newline at end of file
diff --git a/PowerShell/General/RunningProcess-Test.ps1 b/PowerShell/General/RunningProcess-Test.ps1
new file mode 100644
index 0000000..7bffcfc
--- /dev/null
+++ b/PowerShell/General/RunningProcess-Test.ps1
@@ -0,0 +1,33 @@
+﻿Clear-Host
+Set-Variable -Name ProcessList -Value "LPD Service","Print Spooler","Troy Port Monitor Service"
+ForEach($Proces In $ProcessList){
+    If($Proces -eq "svchost"){
+        Set-Variable -Name Found -Value $false
+        Set-Variable -Name ServiceName -Value "LPD Service"
+        Set-Variable -Name OutputFile -Value "$env:TEMP\Output.txt"
+        Set-Variable -Name RunningSvcs -Value "/SVC /FI ""imagename eq svchost.exe"""
+        Start-Process tasklist -ArgumentList $RunningSvcs -RedirectStandardOutput $OutputFile -WindowStyle Hidden
+        ForEach($line In Get-Content $OutputFile){
+            If($line -match $ServiceName){
+                $Found=$true;Break
+            }
+        }
+        If($Found-eq$false){
+            Echo "'$ServiceName' is not running."
+            Start-Process $ServiceName -ErrorAction SilentlyContinue
+        }
+        If(Test-Path -Path $OutputFile){
+            sleep -Milliseconds 350
+            Remove-Item -Path $OutputFile -Force
+        }
+        $Found=$null
+        $ServiceName=$null
+        $OutputFile=$null
+        $RunningSvcs=$null
+    }
+    If((Get-Process -Name "$Proces" -ErrorAction SilentlyContinue) -eq $null){
+        Echo "'$Proces' is not running."
+        Start-Process $Proces -ErrorAction SilentlyContinue
+    }
+}
+$ProcessList=$null
\ No newline at end of file
diff --git a/PowerShell/General/Set-UserStatus.ps1 b/PowerShell/General/Set-UserStatus.ps1
new file mode 100644
index 0000000..c0fd154
--- /dev/null
+++ b/PowerShell/General/Set-UserStatus.ps1
@@ -0,0 +1,19 @@
+﻿Param(
+[Parameter(Position=0)]
+[ValidateSet("Logon","Logoff","Unknown")]
+[string]$Status="Unknown"
+)
+Clear-History;Clear-Host
+
+#no spaces in the filter
+[adsisearcher]$searcher="samaccountname=$env:username"
+#find the current user
+$find = $searcher.FindOne()
+#get the user object
+[adsi]$user = $find.Path
+#define a string to indicate status
+$note = "{0} {1} to {2}" -f (Get-Date),$status.ToUpper(),$env:computername
+#update the Info user property
+$user.Info=$note
+#commit the change
+$user.SetInfo()
\ No newline at end of file
diff --git a/PowerShell/General/Test.ps1 b/PowerShell/General/Test.ps1
new file mode 100644
index 0000000..f213a1f
--- /dev/null
+++ b/PowerShell/General/Test.ps1
@@ -0,0 +1,366 @@
+﻿Function ClearVariables{[CmdletBinding()]param([Parameter(Mandatory=$true)]$VariableList=@())
+    Try{
+        ForEach($Item In $VariableList){
+            If($Item.length-lt1){
+            }Else{
+                Set-Variable -Name $Item -Value $null
+                Clear-Variable -Name $Item -Scope Global -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }Catch [Exception]{
+        If($_.Exception.Message-eq"Cannot find a variable with the name '$Item'."){
+        }Else{
+            $Message=$_.Exception.Message
+            Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+    }
+}
+Function Get-ExistingFile{
+    $Results=Get-ChildItem -Path $WorkingPath -File
+    ForEach($File In $Results){
+        $Properties=Get-ItemProperty "$File"
+        $CreationDate=(Get-ChildItem $Properties.Name).CreationTime
+        $KeyDate=(Get-Date $CreationDate -Format g).Split(" ")[0]
+        $KeyTime=(Get-Date $CreationDate -Format g).Split(" ")[1]
+        $KeyDays=(Get-Date $CreationDate).DayOfYear
+        $KeyYear=$KeyDate.Split("/")[2]
+        $KeyDate=[Int]$KeyYear+$KeyDays
+        $KeyTime=$KeyTime.Split(":")
+        $KeyTime=$KeyTime[0]+$KeyTime[1]
+        [Int]$KeyPair=$KeyTime+$KeyDate
+        $KeyPair=$KeyPair/2
+        $FileName=$($File.Name).Split(".")[0]
+        If($FileName.length-notin"8,12,16"){
+            $KeyFile="$($File.Name)"
+            $Key=$($KeyFile).Split(".")[0]
+            $KeyCode=$Key-$KeyPair
+            If(([System.Text.Encoding]::Unicode).GetByteCount($KeyCode)*8-notin"128,192,256"){
+                Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$KeyFile"
+                $SecureKey=ConvertTo-SecureString -String $KeyCode -AsPlainText -Force
+                $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                $Mask=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                Break
+            }
+        }
+    }
+}
+Function Process-SecureString{[CmdletBinding()]param([String][Parameter(Position=0,Mandatory=$true)]$Key,[String][Parameter(Position=1,Mandatory=$true)]$Password)
+}
+Function Process-String{[CmdletBinding()]param([String][Parameter(Position=0,Mandatory=$true)]$Key,[String][Parameter(Position=1,Mandatory=$true)]$PassPhrase,[String][Parameter(Position=2,Mandatory=$true)]$Password)
+    $Base=$PassPhrase.Length/$Key.Length
+    $Base=[Math]::Truncate($Base)
+    $PassPhrase=$PassPhrase.Substring(0,($PassPhrase.Length-$Key.Length))
+    $PassPhrase=$PassPhrase.Substring(0,($PassPhrase.Length-$Password.Length))
+    $Mask=$PassPhrase.Length/8
+    $Mask=[Math]::Truncate($Mask)
+    [Int]$a=0;[Int]$b=0;[Int]$c=0;[Int]$d=0;[Int]$e=0;[Int]$f=0;[Int]$g=0
+    Try{
+        Do{
+            ForEach($Char In $PassPhrase.Substring($a,1)){
+                Switch($b){
+                    {($_-in0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248)}{
+                        $Part1+=$Char;Break}
+                    {($_-in1,9,17,25,33,41,49,57,65,73,81,89,97,105,113,121,129,137,145,153,161,169,177,185,193,201,209,217,225,233,241,249)}{
+                        $Part2+=$Char;Break}
+                    {($_-in2,10,18,26,34,42,50,58,66,74,82,90,98,106,114,122,130,138,146,154,162,170,178,186,194,202,210,218,226,234,242,250)}{
+                        $Part3+=$Char;Break}
+                    {($_-in3,11,19,27,35,43,51,59,67,75,83,91,99,107,115,123,131,139,147,155,163,171,179,187,195,203,211,219,227,235,243,251)}{
+                        $Part4+=$Char;Break}
+                    {($_-in4,12,20,28,36,44,52,60,68,76,84,92,100,108,116,124,132,140,148,156,164,172,180,188,196,204,212,220,228,236,244,252)}{
+                        $Part5+=$Char;Break}
+                    {($_-in5,13,21,29,37,45,53,61,69,77,85,93,101,109,117,125,133,141,149,157,165,173,181,189,197,205,213,221,229,237,245,253)}{
+                        $Part6+=$Char;Break}
+                    {($_-in6,14,22,30,38,46,54,62,70,78,86,94,102,110,118,126,134,142,150,158,166,174,182,190,198,206,214,222,230,238,246,254)}{
+                        $Part7+=$Char;Break}
+                    {($_-in7,15,23,31,39,47,55,63,71,79,87,95,103,111,119,127,135,143,151,159,167,175,183,191,199,207,215,223,231,239,247,255)}{
+                        $Part8+=$Char;Break}
+                }
+                $a++;$b++
+                If($b-eq$Base){
+                    $b=0
+                }
+            }
+        }Until($a-eq$PassPhrase.Length)
+        Do{
+            Switch($c){
+                {($_-in0,8)}{
+                    $e=((1..$Part1.Length)|Get-Random -Count 1)
+                    [char]$Key1=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part1.Substring(0,$e)
+                    $r=$Part1.Substring($e,($Part1.Length-$l.Length))
+                    $Part1=$l+$Key1+$r
+                    Break
+                }
+                {($_-in1,9)}{
+                    $e=((1..$Part2.Length)|Get-Random -Count 1)
+                    [char]$Key2=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part2.Substring(0,$e)
+                    $r=$Part2.Substring($e,($Part2.Length-$l.Length))
+                    $Part2=$l+$Key2+$r
+                    Break
+                }
+                {($_-in2,10)}{
+                    $e=((1..$Part3.Length)|Get-Random -Count 1)
+                    [char]$Key3=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part3.Substring(0,$e)
+                    $r=$Part3.Substring($e,($Part3.Length-$l.Length))
+                    $Part3=$l+$Key3+$r
+                    Break
+                }
+                {($_-in3,11)}{
+                    $e=((1..$Part4.Length)|Get-Random -Count 1)
+                    [char]$Key4=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part4.Substring(0,$e)
+                    $r=$Part4.Substring($e,($Part4.Length-$l.Length))
+                    $Part4=$l+$Key4+$r
+                    Break
+                }
+                {($_-in4,12)}{
+                    $e=((1..$Part5.Length)|Get-Random -Count 1)
+                    [char]$Key5=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part5.Substring(0,$e)
+                    $r=$Part5.Substring($e,($Part5.Length-$l.Length))
+                    $Part5=$l+$Key5+$r
+                    Break
+                }
+                {($_-in5,13)}{
+                    $e=((1..$Part6.Length)|Get-Random -Count 1)
+                    [char]$Key6=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part6.Substring(0,$e)
+                    $r=$Part6.Substring($e,($Part6.Length-$l.Length))
+                    $Part6=$l+$Key6+$r
+                    Break
+                }
+                {($_-in6,14)}{
+                    $e=((1..$Part7.Length)|Get-Random -Count 1)
+                    [char]$Key7=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part7.Substring(0,$e)
+                    $r=$Part7.Substring($e,($Part7.Length-$l.Length))
+                    $Part7=$l+$Key7+$r
+                    Break
+                }
+                {($_-in7,15)}{
+                    $e=((1..$Part8.Length)|Get-Random -Count 1)
+                    [char]$Key8=($ExtAskii+$Key.Substring($_,1))
+                    $l=$Part8.Substring(0,$e)
+                    $r=$Part8.Substring($e,($Part8.Length-$l.Length))
+                    $Part8=$l+$Key8+$r
+                    Break
+                }
+            }
+            $c++
+        }Until($c-eq$Key.Length)
+        Do{
+            Switch($d){
+                {($_-in0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key1=($ExtAspii+$f)
+                    $l=$Part1.Substring(0,$e);$r=$Part1.Substring($e,($Part1.Length-$l.Length))
+                    $Part1=$l+$Key1+$r
+                    Break
+                }
+                {($_-in1,9,17,25,33,41,49,57,65,73,81,89,97,105,113,121,129,137,145,153,161,169,177,185,193,201,209,217,225,233,241,249)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key2=($ExtAspii+$f)
+                    $l=$Part2.Substring(0,$e);$r=$Part2.Substring($e,($Part2.Length-$l.Length))
+                    $Part2=$l+$Key2+$r
+                    Break
+                }
+                {($_-in2,10,18,26,34,42,50,58,66,74,82,90,98,106,114,122,130,138,146,154,162,170,178,186,194,202,210,218,226,234,242,250)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key3=($ExtAspii+$f)
+                    $l=$Part3.Substring(0,$e);$r=$Part3.Substring($e,($Part3.Length-$l.Length))
+                    $Part3=$l+$Key3+$r
+                    Break
+                }
+                {($_-in3,11,19,27,35,43,51,59,67,75,83,91,99,107,115,123,131,139,147,155,163,171,179,187,195,203,211,219,227,235,243,251)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key4=($ExtAspii+$f)
+                    $l=$Part4.Substring(0,$e);$r=$Part4.Substring($e,($Part4.Length-$l.Length))
+                    $Part4=$l+$Key4+$r
+                    Break
+                }
+                {($_-in4,12,20,28,36,44,52,60,68,76,84,92,100,108,116,124,132,140,148,156,164,172,180,188,196,204,212,220,228,236,244,252)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key5=($ExtAspii+$f)
+                    $l=$Part5.Substring(0,$e);$r=$Part5.Substring($e,($Part5.Length-$l.Length))
+                    $Part5=$l+$Key5+$r
+                    Break
+                }
+                {($_-in5,13,21,29,37,45,53,61,69,77,85,93,101,109,117,125,133,141,149,157,165,173,181,189,197,205,213,221,229,237,245,253)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key6=($ExtAspii+$f)
+                    $l=$Part6.Substring(0,$e);$r=$Part6.Substring($e,($Part6.Length-$l.Length))
+                    $Part6=$l+$Key6+$r
+                    Break
+                }
+                {($_-in6,14,22,30,38,46,54,62,70,78,86,94,102,110,118,126,134,142,150,158,166,174,182,190,198,206,214,222,230,238,246,254)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key7=($ExtAspii+$f)
+                    $l=$Part7.Substring(0,$e);$r=$Part7.Substring($e,($Part7.Length-$l.Length))
+                    $Part7=$l+$Key7+$r
+                    Break
+                }
+                {($_-in7,15,23,31,39,47,55,63,71,79,87,95,103,111,119,127,135,143,151,159,167,175,183,191,199,207,215,223,231,239,247,255)}{
+                    $e=(($g..($g+7))|Get-Random -Count 1)
+                    [int][char]$f=$Password.Substring($_,1);[char]$Key8=($ExtAspii+$f)
+                    $l=$Part8.Substring(0,$e);$r=$Part8.Substring($e,($Part8.Length-$l.Length))
+                    $Part8=$l+$Key8+$r
+                    Break
+                }
+            }
+            $d++
+            Switch($d){
+                {($_-in8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248)}
+                    {$g+=$d;Break}
+            }
+        }Until($d-eq$Password.Length)
+        Return $Part1+$Part2+$Part3+$Part4+$Part5+$Part6+$Part7+$Part8
+    }Catch [Exception]{
+        If($_.Exception.Message-eq"Cannot find a variable with the name '$Item'."){
+        }Else{
+            $Message=$_.Exception.Message
+            Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+        }
+    }Finally{
+        ClearVariables -VariableList 'Part1','Part2','Part3','Part4','Part5','Part6','Part7','Part8'
+    }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Clear-Host;Clear-History
+ClearVariables -VariableList 'KeyDate','KeyDays','KeyTime','KeyYear''Part1','Part2','Part3','Part4','Part5','Part6','Part7','Part8'
+Set-Location -Path "$($env:USERProfile)\Documents"
+Set-Variable -Name "AuthUser" -Value "stobib@hotmail.com"
+Set-Variable -Name "WorkingPath" -Value "$env:USERProfile\Documents\Passwords"
+Set-Variable -Name "SecureFile" -Value "$WorkingPath\Encrypted.pwd"
+Set-Variable -Name "Characters" -Value ""
+Set-Variable -Name "PrivateKey" -Value ""
+Set-Variable -Name "SecureKey" -Value ""
+Set-Location -Path $WorkingPath
+[Int]$ExtAskii=48
+[Int]$ExtAspii=130
+[String]$Key=0
+[Int]$Min=128
+[Int]$Max=2048
+$Results=
+If(Test-Path -Path $SecureFile){
+    $Results=Get-ExistingFile
+}Else{
+    Do{
+        $Prompt="Enter the length you want to use for the security key: [8,12,16]"
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If($RandomKey-notin8,12,16){
+            $Valid=$false
+        }Else{
+            $Valid=$true
+        }
+        Clear
+    }While($Valid-eq$false)
+    Do{
+        Switch($RandomKey){
+            {($_-eq8)}{
+                $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                Break
+            }
+            {($_-eq12)}{
+                $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                Break
+            }
+            {($_-eq16)}{
+                $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                Break
+            }
+            {($Key.length-lt$RandomKey)}{
+                $RandomKey+=1
+                Break
+            }
+            {($Key.length-gt$RandomKey)}{
+                $RandomKey-=1
+                Break
+            }
+            Default{
+                $RandomKey=16
+                Break
+            }
+        }
+    }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+    [Int]$KeyCode=$Key
+    $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+    Do{
+        [Int]$Characters=Read-Host -Prompt $Prompt
+        If(($Characters-ge$Min)-and($Characters-le$Max)){
+        }Else{
+            $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+        }
+        Clear
+    }Until(($Characters-ge$Min)-and($Characters-le$Max))
+    For($i=0;$i-le$Characters;$i++){
+        Switch($i){
+            {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+            Default{$PrivateKey="";$Set="";Break}
+        }
+        $PrivateKey+=$Set
+    }
+    $KeyDate=(Get-Date -Format g).Split(" ")[0]
+    $KeyTime=(Get-Date -Format g).Split(" ")[1]
+    $KeyDays=(Get-Date).DayOfYear
+    $KeyYear=$KeyDate.Split("/")[2]
+    $KeyDate=[Int]$KeyYear+$KeyDays
+    $KeyTime=$KeyTime.Split(":")
+    $KeyTime=$KeyTime[0]+$KeyTime[1]
+    [Int]$KeyPair=$KeyTime+$KeyDate
+    $KeyPair=($KeyPair/2)+$KeyCode
+    Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$KeyPair.key"
+    $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+    ConvertTo-SecureString $PrivateKey -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+    $Prompt="Enter the password that you want to set for account: [$AuthUser]"
+    $SecureString=Read-Host -Prompt "Enter your [$AuthUser] credentials" -AsSecureString
+    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+    $UnSecureString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    $PrivateWord=Process-String $Key $PrivateKey $UnSecureString
+    Protect-String $PrivateWord $Key|Out-File -Filepath $SecureFile
+}
+Clear-Host
+$UnEncrypted=Process-SecureString $KeyPair $PrivateWord
+Try{
+    $Validate=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Validate)
+    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+}Catch [Exception]{
+    $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+}Finally{
+    ClearVariables -VariableList 'AuthUser','BSTR','Characters','EncryptedString','EncryptionKeyFile','File','FileName','i','Key','Mask','Max','Message','Min','PrivateKey','Prompt','RandomKey','Results','SecureFile','SecureKey','SecureString','Set','Validate','WorkingPath'
+    Set-Location -Path "$env:SystemRoot\System32"
+}
\ No newline at end of file
diff --git a/PowerShell/General/UTA-sftpadmingrp.ps1 b/PowerShell/General/UTA-sftpadmingrp.ps1
new file mode 100644
index 0000000..0a042c3
--- /dev/null
+++ b/PowerShell/General/UTA-sftpadmingrp.ps1
@@ -0,0 +1 @@
+﻿Get-ADGroupMember "sftpadmingrp" -Recursive|Where-Object {$_.Name -Like "ar*"}|%{$group=$_;get-aduser $_ -Properties Name|Select @{n="Group";e={$group}},Name,SurName,GivenName,ObjectClass}|Out-File 'E:\Results-sftpadmingrp.log'
\ No newline at end of file
diff --git a/PowerShell/General/VerifyDNS-old.ps1 b/PowerShell/General/VerifyDNS-old.ps1
new file mode 100644
index 0000000..521eae1
--- /dev/null
+++ b/PowerShell/General/VerifyDNS-old.ps1
@@ -0,0 +1,264 @@
+﻿Function DateDiff{param([datetime]$StartDate,$EndDate)
+    $LastPass=[datetime]::ParseExact($EndDate,'M/d/yyyy',$null)
+    $Days=(New-TimeSpan –Start $ResetDate –End $LastPass).Days
+    Return $($Days)
+}
+Function DisplayMessage{param([string]$Description,[string]$StatusMessage,$FontColor="Yellow",$Background="Black")
+    [int]$Buffer=$RightAlign-$Description.Length
+    Write-Host @($($Description)) @($($StatusMessage).PadLeft($Buffer)) -ForegroundColor $FontColor -BackgroundColor $Background
+    Return $($Description)
+}
+Function DNSLookup{param([string]$ObjectValue,[string]$SearchValue)
+    Start-Process -FilePath "$env:comspec" -ArgumentList "/c nslookup $ObjectValue" -RedirectStandardOutput $NSLookupData -WindowStyle Hidden -Wait
+    If(Test-Path $NSLookupData){
+        ForEach($CurrentLine In Get-Content $NSLookupData){
+            If($CurrentLine-like$SearchValue){
+                If(Test-Path $NSLookupData){Remove-Item -Path $NSLookupData -Force}
+                Return $true
+                Break
+            }
+        }Return $false
+    }
+}
+Function ProcessPing{param([string]$ObjectValue,[string]$SearchValue)
+    Start-Process -FilePath "$env:comspec" -ArgumentList "/c ping $ObjectValue" -RedirectStandardOutput $PingResults -WindowStyle Hidden -Wait
+    If(Test-Path $PingResults){
+        ForEach($CurrentLine In Get-Content $PingResults){
+            If($CurrentLine-like$SearchValue){
+                If(Test-Path $PingResults){Remove-Item -Path $PingResults -Force}
+                Return $true
+                Break
+            }ElseIf($ObjectValue-like"-a *"){
+                If($CurrentLine-like"*$ForwardDNS*"){$ForwardLookup=$true}
+            }
+        }Return $false
+    }
+}
+Function VerifyIPv4Address{
+    Switch(@($($Computer.IPv4Address).Split("."))[2]){
+        {($_-ge4-and$_-le7)-or($_-ge20-and$_-le23)-or($_-ge36-and$_-le39)-or($_-ge52-and$_-le55)-or($_-ge68-and$_-le712)-or($_-ge84-and$_-le87)}{$SubDomain="prd";Break}
+        {($_-eq10)-or($_-eq26)-or($_-eq42)-or($_-eq58)-or($_-eq74)-or($_-eq90)}{$SubDomain="trn";Break}
+        {($_-eq11)-or($_-eq27)-or($_-eq43)-or($_-eq59)-or($_-eq75)-or($_-eq91)}{$SubDomain="sbx";Break}
+        {($_-eq12)-or($_-eq28)-or($_-eq44)-or($_-eq60)-or($_-eq76)-or($_-eq92)}{$SubDomain="tst";Break}
+        {($_-eq13)-or($_-eq29)-or($_-eq45)-or($_-eq61)-or($_-eq77)-or($_-eq93)}{$SubDomain="dev";Break}
+        {($_-eq14)-or($_-eq30)-or($_-eq46)-or($_-eq62)-or($_-eq78)-or($_-eq94)}{$SubDomain="dmo";Break}
+        {($_-eq8)-or($_-eq24)-or($_-eq40)-or($_-eq56)-or($_-eq72)-or($_-eq88)}{$SubDomain="uat";Break}
+        {($_-eq9)-or($_-eq25)-or($_-eq41)-or($_-eq57)-or($_-eq73)-or($_-eq89)}{$SubDomain="fly";Break}
+        {($_-eq64)-or($_-eq65)}{$SubDomain="bkp";Break}
+        {($_-eq18)-or($_-eq19)}{$SubDomain="vdi";Break}
+        {($_-eq0)-or($_-eq1)}{$SubDomain="inf";Break}
+        {($_-eq2)}{$SubDomain="mgt";Break}
+        Default{$SubDomain="all";Break}
+    }Return $SubDomain
+}
+Clear-Host;Clear-History
+$StartTime=(Get-Date).AddDays(-30).toString('yyyy/M/d H:mm:ss')
+$StartTime=[datetime]::ParseExact($StartTime,'yyyy/M/d H:mm:ss',$null)
+$ResetDate=(Get-Date).AddDays(-30).toString('M/d/yyyy')
+$ResetDate=[datetime]::ParseExact($ResetDate,'M/d/yyyy',$null)
+$BGC=(Get-Host).UI.RawUI.BackgroundColor
+$FGC=(Get-Host).UI.RawUI.ForegroundColor
+$Buffer=(Get-Host).UI.RawUI.BufferSize
+$WorkingPath="C:\Users\Public\Documents"
+[int]$RightAlign=$Buffer.Width-2
+Set-Location -Path $WorkingPath
+$ForwardLookup=$false
+$ReverseLookup=$false
+$GoodIPAddress=$null
+$ValidDCName=$false
+$SearchDomain=$null
+$BadIPAddress=$null
+$BadComputer=$null
+$UserDomain=$null
+$ForwardDNS=$null
+$HostName=$null
+$UserName=$null
+$AuthUser=$null
+$Active=$false
+$Counter=$null
+$Message=$null
+$FocusDC=$null
+$DCCount=$null
+$DCList=$null
+$SystemList=@(0,1,2,3,4,5)
+Do{
+    $Counter++
+    Switch($Counter){
+        "1"{$Prompt="Enter your search domain";Break}
+        Default{$Prompt="Enter the FQDN, please";Break}
+    }
+    $SearchDomain=Read-Host -Prompt $Prompt
+    $SearchDomain=$SearchDomain.ToLower()
+    If($SearchDomain-eq$null){$SearchDomain=$env:USERDOMAIN}
+}Until($SearchDomain-like'*.*')
+$UserDomain=$SearchDomain.Split(".")[0].ToUpper()
+$UserName=Read-Host -Prompt 'Enter your credentials[username]'
+If($UserName-eq$null){$UserName=$env:USERNAME}
+$UserName=$UserName.ToLower()
+$AuthUser=$UserDomain+"\"+$UserName
+$Counter=$null
+Do{
+    $Counter++
+    Switch($Counter){
+        "1"{$DomainController=Read-Host -Prompt "Enter the name a domain controller for $SearchDomain";Break}
+        Default{$DomainController=$DomainController+"."+$SearchDomain;Break}
+    }
+    If($DomainController-eq""){$DomainController="dca01."+$SearchDomain}
+}Until($DomainController-like'*.*')
+$DomainController=$DomainController.Split(".")[0].ToLower()
+$ExportFile="ExportList-$DomainController.csv"
+$DomainController=$DomainController+"."+$SearchDomain
+$FilterBy='ObjectClass -eq "Computer"'
+$Message=DisplayMessage -Description ""
+$Message=DisplayMessage -Description "Retrieving list of domain computers for the'$SearchDomain' domain from $DomainController,"
+$Message=DisplayMessage -Description "and exporting list of domain computers to '$WorkingPath\$ExportFile'."
+$Headers='Name','LastLogonDate','PasswordLastSet','OperatingSystem','IPv4Address','DNSHostName','DistinguishedName','CanonicalName'
+#If(Test-Path $ExportFile){Remove-Item -Path $ExportFile}
+#Get-ADComputer -Credential $AuthUser -Server $DomainController -Filter $FilterBy -Property $Headers | Select-Object $Headers | Sort-Object -Property Name | Export-CSV $ExportFile -NoTypeInformation -Encoding UTF8
+If(Test-Path $ExportFile){
+    $Message=DisplayMessage -Description "Completed export of domain computers to '$ExportFile'."
+    $Message=DisplayMessage -Description "Adding exported list of domain computers to memory.  Searching for other Domain Controllers..."
+    $ComputerList=Import-Csv $ExportFile
+    $Counter=$null
+    ForEach($Computer In $ComputerList){
+        If($Computer.CanonicalName-like"*Domain Controller*"){
+            If(($Computer.DNSHostName).ToLower()-eq$DomainController){
+                $FocusDC=$Computer.Name
+                $ValidDCName=$true
+            }Else{
+                $Counter++
+                Switch($Counter){
+                    "1"{$DCList=($Computer.DNSHostName).ToLower();Break}
+                    Default{$DCList=$DCList+","+($Computer.DNSHostName).ToLower();Break}
+                }
+            }
+        }
+    }
+    If($ValidDCName-eq$true){
+        $Counter=$null
+        $DCCount=0
+        ForEach($DC in $DCList.Split(",")){
+            $NewDC=$DC.Split(".")[0]
+            $FileName=$ExportFile.Replace($FocusDC.ToLower(),$NewDC)
+            $Message=DisplayMessage -Description ""
+            $Message=DisplayMessage -Description "Retrieving list of domain computers from $NewDC.$SearchDomain,"
+            $Message=DisplayMessage -Description "and exporting list of domain computers to '$WorkingPath\$FileName'."
+#            If(Test-Path $FileName){Remove-Item -Path $FileName}
+#            Get-ADComputer -Credential $AuthUser -Server $DC -Filter $FilterBy -Property $Headers | Select-Object $Headers | Sort-Object -Property Name | Export-CSV $FileName -NoTypeInformation -Encoding UTF8
+            $Message=DisplayMessage -Description "Completed export of domain computers to '$FileName'."
+            $SystemList[$DCCount]=Import-Csv $FileName
+            $DCCount++
+        }
+        $ImportForPMP="ImportForPMP.csv"
+        $NSLookupData="nslookup.txt"
+        $PingResults="PingData.txt"
+        $ResultFile="Results.log"
+        $AliasesFound=$true
+        $Message=DisplayMessage -Description "Completed import of domain computers to memory."
+        If(Test-Path $ResultFile){Remove-Item -Path $ResultFile}
+        If(Test-Path $ImportForPMP){Remove-Item -Path $ImportForPMP}
+        $Message=DisplayMessage -Description "Starting to process imported list of domain computers." -FontColor "Cyan"
+        For($Loop=0;$Loop-le2;$Loop++){
+            $Message=DisplayMessage -Description "" -Background "Black"
+        }
+        ForEach($Computer In $ComputerList){
+            $ForwardDNS=$($Computer.DNSHostName).ToLower()
+            $ForwardLookup=$false
+            $OS=$Computer.OperatingSystem.ToLower()
+            If(($OS-like"*8*")-or($OS-like"*10*")){$OS="workstation"}Else{$OS=$null}
+            $Active=$false
+            If(!$OS-eq"workstation"){
+                $HostName=$($Computer.Name).ToUpper()
+                $DaysPast=DateDiff -StartDate $ResetDate -EndDate (@($($Computer.PasswordLastSet).Split(" "))[0])
+                If(!$($Computer.LastLogonDate)-eq""){
+                    $DaysLogon=DateDiff -StartDate $ResetDate -EndDate (@($($Computer.LastLogonDate).Split(" "))[0])
+                    If((0-lt$DaysPast)-or(0-lt$DaysLogon)){
+                        $Active=$true
+                        $Message=DisplayMessage -Description "$($HostName.ToLower()) changed it's password and/or logged into the '$SearchDomain' domain within 30 days" -FontColor "White" -Background "DarkMagenta"
+                    }Else{
+                        For($Counter=0;$Counter-le$DCCount;$Counter++){
+                            ForEach($CN In $SystemList[$Counter]){
+                                If($CN.Name-eq$HostName){
+                                    $DaysPast=DateDiff -StartDate $ResetDate -EndDate (@($($CN.PasswordLastSet).Split(" "))[0])
+                                    If(!$($CN.LastLogonDate)-eq""){
+                                        $DaysLogon=DateDiff -StartDate $ResetDate -EndDate (@($($CN.LastLogonDate).Split(" "))[0])
+                                        If((0-lt$DaysPast)-or(0-lt$DaysLogon)){
+                                            $Message=DisplayMessage -Description "$($HostName.ToLower()) changed it's password and/or logged into the '$SearchDomain' domain within 30 days" -FontColor "Yellow" -Background "DarkGray"
+                                            $Active=$true
+                                        }
+                                    }
+                                    Break
+                                }
+                            }
+                        }
+                        If($Active-eq$false){$Message=DisplayMessage -Description "$HostName last logon: '$($Computer.LastLogonDate)' and password was set on: '$($Computer.PasswordLastSet)'" -Background "DarkRed"}
+                    }
+                }
+            If($Active-eq$true){
+                If(@($($Computer.IPv4Address).Split("."))[1]-like"118"){
+                    $Message=DisplayMessage -Description "$ForwardDNS is located at ARDC" -FontColor "Cyan" -Background "DarkBlue"
+                    $IPv4Address=$($Computer.IPv4Address).ToString()
+                    $Message=DisplayMessage -Description "Beginning process to ping $IPv4Address" -FontColor "Cyan" -Background "DarkBlue"
+                    $AbleToPing=ProcessPing -ObjectValue "-a $IPv4Address" -SearchValue "Reply from*$bytes=*"
+                    If($AbleToPing-eq$true){
+                        $Message=DisplayMessage -Description "Was able to successfully ping $ForwardDNS using the IP Address: $IPv4Address" -FontColor "Cyan" -Background "DarkBlue"
+                    }Else{
+                        $Message=DisplayMessage -Description "Failed to ping '$HostName' using the IP Address: $IPv4Address" -FontColor "Red"
+                    }
+                }ElseIf(@($($Computer.IPv4Address).Split("."))[1]-like"126"){
+                    $Message=DisplayMessage -Description "$ForwardDNS is located at UDCC" -FontColor "Green" -Background "DarkBlue"
+                    $IPv4Address=$($Computer.IPv4Address).ToString()
+                    $Message=DisplayMessage -Description "Beginning process to ping $IPv4Address" -FontColor "Green" -Background "DarkBlue"
+                    $AbleToPing=ProcessPing -ObjectValue "-a $IPv4Address" -SearchValue "Reply from*bytes=*"
+                    If($AbleToPing-eq$true){
+                        $Message=DisplayMessage -Description "Was able to successfully ping $ForwardDNS using the IP Address: $IPv4Address" -FontColor "Green" -Background "DarkBlue"
+                    }Else{
+                        $Message=DisplayMessage -Description "Failed to ping '$HostName' using the IP Address: $IPv4Address" -FontColor "Red"
+                    }
+                }Else{
+                    If($($Computer.IPv4Address)-eq""){
+                        $AbleToPing=DNSLookup -ObjectValue $ForwardDNS -SearchValue "Addresses:*"
+                        If($AbleToPing-eq$false){$Message=DisplayMessage -Description "$HostName is not in DNS." -Background "DarkRed"}
+                    }
+                }
+            }
+                For($Loop=0;$Loop-le2;$Loop++){
+                    $Message=DisplayMessage -Description "" -Background "Black"
+                }
+            }
+            If($AbleToPing=$true){$GoodIPAddress++}
+            If($AbleToPing=$false){$BadIPAddress++}
+            If($Active=$false){$BadComputer++}
+            $LastLogon=$null
+            $DaysLogon=$null
+            $LastPass=$null
+            $DaysPast=$null
+        }
+    }Else{$Message=DisplayMessage -Description "$DomainController IS NOT a valid domain controller for the $SearchDomain domain." -Background "DarkRed"}
+}
+$BGC=(Get-Host).UI.RawUI.BackgroundColor=$BGC
+$FGC=(Get-Host).UI.RawUI.ForegroundColor=$FGC
+$EndTime=(Get-Date).AddDays(-30).toString('yyyy/M/d H:mm:ss')
+$EndTime=[datetime]::ParseExact($EndTime,'yyyy/M/d H:mm:ss',$null)
+Set-Location -Path "C:\Windows\System32"
+$DomainController=$null
+$GoodIPAddress=$null
+$BadIPAddress=$null
+$BadComputer=$null
+$WorkingPath=$null
+$ValidDCName=$null
+$UserDomain=$null
+$UserName=$null
+$AuthUser=$null
+$Counter=$null
+$Message=$null
+$FocusDC=$null
+$DCCount=$null
+$Active=$null
+$DCList=$null
+$LastPass=$null
+$DaysPast=$null
+$LastLogon=$null
+$DaysLogon=$null
+$SystemList=$null
+$SearchDomain=$null
\ No newline at end of file
diff --git a/PowerShell/General/VerifyDNS.ps1 b/PowerShell/General/VerifyDNS.ps1
new file mode 100644
index 0000000..a80b6f4
--- /dev/null
+++ b/PowerShell/General/VerifyDNS.ps1
@@ -0,0 +1,296 @@
+﻿Function DateDiff{param([datetime]$StartDate,$EndDate)
+    $LastPass=[datetime]::ParseExact($EndDate,'M/d/yyyy',$null)
+    $Days=(New-TimeSpan –Start $ResetDate –End $LastPass).Days
+    Return $($Days)
+}
+Function DisplayMessage{param([string]$Description,[string]$StatusMessage,$FontColor="Yellow",$Background="Black")
+    [int]$Buffer=$RightAlign-$Description.Length
+    $Message=$Description+" "+$StatusMessage.PadLeft($Buffer)
+    Write-Host $Message -ForegroundColor $FontColor -BackgroundColor $Background
+#    Add-Content -Path $ResultFile -Value $Message -PassThru
+    Return $($Description)
+}
+Function DNSLookup{param([string]$ObjectValue,[string]$SearchValue)
+    If(Test-Path $NSLookupData){Remove-Item -Path $NSLookupData -Force}
+    Start-Process -FilePath "$env:comspec" -ArgumentList "/c nslookup $ObjectValue" -RedirectStandardOutput $NSLookupData -WindowStyle Hidden -Wait
+    If(Test-Path $NSLookupData){
+        ForEach($CurrentLine In Get-Content $NSLookupData){
+            If($CurrentLine-like$SearchValue){
+                Return $true,$ResolvedIP
+                If($SearchValue-like"Name*"){
+                    $SearchValue="Address*"
+                }Else{
+                    $ResolvedIP=@($CurrentLine).ToString().Split(":")[1]
+                    Break
+                }
+            }
+        }Return $false,$ResolvedIP
+    }
+}
+Function ProcessPing{param([string]$ObjectValue,[string]$SearchValue)
+    If(Test-Path $PingResults){Remove-Item -Path $PingResults -Force}
+    Start-Process -FilePath "$env:comspec" -ArgumentList "/c ping $ObjectValue" -RedirectStandardOutput $PingResults -WindowStyle Hidden -Wait
+    If(Test-Path $PingResults){
+        ForEach($CurrentLine In Get-Content $PingResults){
+            If($CurrentLine-like$SearchValue){
+                Return $true,$ResolvedIP
+                Break
+            }ElseIf($ObjectValue-like"-a *"){
+                If($CurrentLine-like"*$ForwardDNS*"){
+                    $ResolvedIP=$CurrentLine.Split(" ")[2]
+                    $ResolvedIP=$ResolvedIP.Remove(0,1)
+                    $Len=$ResolvedIP.Length
+                    $ResolvedIP=$ResolvedIP.Remove($Len-1,1)
+                    $ForwardLookup=$true
+                }
+            }
+        }Return $false,$ResolvedIP
+    }
+}
+Function TimeDiff{param([datetime]$StartDate,$EndDate)
+    $MinsPast=[datetime]::ParseExact($EndDate,'H:mm:ss-M/d/yyyy',$null)
+    $Minutes=(New-TimeSpan –Start $StartDate –End $MinsPast).Minutes
+    Return $($Minutes)
+}
+Function ZoneName{param([int]$Octate3)
+    Switch($Octate3){
+        {($_-ge4-and$_-le7)-or($_-ge20-and$_-le23)-or($_-ge36-and$_-le39)-or($_-ge52-and$_-le55)-or($_-ge68-and$_-le712)-or($_-ge84-and$_-le87)}{$SubDomain="prd";Break}
+        {($_-eq10)-or($_-eq26)-or($_-eq42)-or($_-eq58)-or($_-eq74)-or($_-eq90)}{$SubDomain="trn";Break}
+        {($_-eq11)-or($_-eq27)-or($_-eq43)-or($_-eq59)-or($_-eq75)-or($_-eq91)}{$SubDomain="sbx";Break}
+        {($_-eq12)-or($_-eq28)-or($_-eq44)-or($_-eq60)-or($_-eq76)-or($_-eq92)}{$SubDomain="tst";Break}
+        {($_-eq13)-or($_-eq29)-or($_-eq45)-or($_-eq61)-or($_-eq77)-or($_-eq93)}{$SubDomain="dev";Break}
+        {($_-eq14)-or($_-eq30)-or($_-eq46)-or($_-eq62)-or($_-eq78)-or($_-eq94)}{$SubDomain="dmo";Break}
+        {($_-eq8)-or($_-eq24)-or($_-eq40)-or($_-eq56)-or($_-eq72)-or($_-eq88)}{$SubDomain="uat";Break}
+        {($_-eq9)-or($_-eq25)-or($_-eq41)-or($_-eq57)-or($_-eq73)-or($_-eq89)}{$SubDomain="fly";Break}
+        {($_-eq64)-or($_-eq65)}{$SubDomain="bkp";Break}
+        {($_-eq18)-or($_-eq19)}{$SubDomain="vdi";Break}
+        {($_-eq0)-or($_-eq1)}{$SubDomain="inf";Break}
+        {($_-eq2)}{$SubDomain="mgt";Break}
+        Default{$SubDomain="all";Break}
+    }Return $SubDomain
+}
+Clear-Host;Clear-History
+$ResetDate=(Get-Date).AddDays(-30).toString('M/d/yyyy')
+$ResetDate=[datetime]::ParseExact($ResetDate,'M/d/yyyy',$null)
+$BGC=(Get-Host).UI.RawUI.BackgroundColor
+$FGC=(Get-Host).UI.RawUI.ForegroundColor
+$Buffer=(Get-Host).UI.RawUI.BufferSize
+$WorkingPath="C:\Users\Public\Documents"
+[int]$RightAlign=$Buffer.Width-2
+Set-Location -Path $WorkingPath
+$ResultFile="Results.log"
+$ForwardLookup=$false;$ReverseLookup=$false;$GoodIPAddress=$null;$ValidDCName=$false;$SearchDomain=$null;$BadIPAddress=$null
+$BadComputer=$null;$UserDomain=$null;$ForwardDNS=$null;$HostName=$null;$UserName=$null;$AuthUser=$null;$Active=$false;$ResolvedIP=$null
+$Counter=$null;$Message=$null;$FocusDC=$null;$DCCount=$null;$DCList=$null;$SystemList=@(0,1,2,3,4,5);$CorrectZone=$false
+Do{
+    $Counter++
+    Switch($Counter){
+        "1"{$Prompt="Enter your search domain";Break}
+        Default{$Prompt="Enter the FQDN, please";Break}
+    }
+    $SearchDomain=Read-Host -Prompt $Prompt
+    $SearchDomain=$SearchDomain.ToLower()
+    If(($SearchDomain-eq"")-or($SearchDomain-eq$null)){$SearchDomain=$env:USERDOMAIN}
+}Until($SearchDomain-like'*.*')
+$UserDomain=$SearchDomain.Split(".")[0].ToUpper()
+$UserName=Read-Host -Prompt 'Enter your credentials[username]'
+If($UserName-eq$null){$UserName=$env:USERNAME}
+$UserName=$UserName.ToLower()
+$AuthUser=$UserDomain+"\"+$UserName
+$Counter=$null
+Do{
+    $Counter++
+    Switch($Counter){
+        "1"{$DomainController=Read-Host -Prompt "Enter the name a domain controller for $SearchDomain";Break}
+        Default{$DomainController=$DomainController+"."+$SearchDomain;Break}
+    }
+    If($DomainController-eq""){$DomainController="dca01."+$SearchDomain}
+}Until($DomainController-like'*.*')
+$DomainController=$DomainController.Split(".")[0].ToLower()
+$ExportFile="ExportList-$DomainController.csv"
+$DomainController=$DomainController+"."+$SearchDomain
+$FilterBy='ObjectClass -eq "Computer"'
+$StartTime=(Get-Date).AddDays(-30).toString('yyyy/M/d H:mm:ss')
+$StartTime=[datetime]::ParseExact($StartTime,'yyyy/M/d H:mm:ss',$null)
+If(Test-Path $ResultFile){Remove-Item -Path $ResultFile}
+$Message=DisplayMessage -Description ""
+$Message=DisplayMessage -Description "Retrieving list of domain computers for the'$SearchDomain' domain from $DomainController,"
+$Message=DisplayMessage -Description "and exporting list of domain computers to '$WorkingPath\$ExportFile'."
+$Headers='Name','LastLogonDate','PasswordLastSet','OperatingSystem','IPv4Address','DNSHostName','DistinguishedName','CanonicalName'
+#If(Test-Path $ExportFile){Remove-Item -Path $ExportFile}
+#Get-ADComputer -Credential $AuthUser -Server $DomainController -Filter $FilterBy -Property $Headers | Select-Object $Headers | Sort-Object -Property Name | Export-CSV $ExportFile -NoTypeInformation -Encoding UTF8
+If(Test-Path $ExportFile){
+    $Message=DisplayMessage -Description "Completed export of domain computers to '$ExportFile'."
+    $Message=DisplayMessage -Description "Adding exported list of domain computers to memory.  Searching for other Domain Controllers..."
+    $ComputerList=Import-Csv $ExportFile
+    $Counter=$null
+    ForEach($Computer In $ComputerList){
+        If($Computer.CanonicalName-like"*Domain Controller*"){
+            If(($Computer.DNSHostName).ToLower()-eq$DomainController){
+                $FocusDC=$Computer.Name
+                $ValidDCName=$true
+            }Else{
+                $Counter++
+                Switch($Counter){
+                    "1"{$DCList=($Computer.DNSHostName).ToLower();Break}
+                    Default{$DCList=$DCList+","+($Computer.DNSHostName).ToLower();Break}
+                }
+            }
+        }
+    }
+    If($ValidDCName-eq$true){
+        $Counter=$null
+        $DCCount=0
+<#        ForEach($DC in $DCList.Split(",")){
+            $NewDC=$DC.Split(".")[0]
+            $FileName=$ExportFile.Replace($FocusDC.ToLower(),$NewDC)
+            $Message=DisplayMessage -Description ""
+            $Message=DisplayMessage -Description "Retrieving list of domain computers from $NewDC.$SearchDomain,"
+            $Message=DisplayMessage -Description "and exporting list of domain computers to '$WorkingPath\$FileName'."
+            If(Test-Path $FileName){Remove-Item -Path $FileName}
+            Get-ADComputer -Credential $AuthUser -Server $DC -Filter $FilterBy -Property $Headers | Select-Object $Headers | Sort-Object -Property Name | Export-CSV $FileName -NoTypeInformation -Encoding UTF8
+            $Message=DisplayMessage -Description "Completed export of domain computers to '$FileName'."
+            $SystemList[$DCCount]=Import-Csv $FileName
+            $DCCount++
+        }#>
+        $ImportForPMP="ImportForPMP.csv"
+        $NSLookupData="nslookup.txt"
+        $PingResults="PingData.txt"
+        $ResultFile="Results.log"
+        $AliasesFound=$true
+        $Message=DisplayMessage -Description "Completed import of domain computers to memory."
+        If(Test-Path $ResultFile){Remove-Item -Path $ResultFile}
+        If(Test-Path $ImportForPMP){Remove-Item -Path $ImportForPMP}
+        $Message=DisplayMessage -Description "Starting to process imported list of domain computers." -FontColor "Cyan"
+        For($Loop=0;$Loop-le2;$Loop++){
+            $Message=DisplayMessage -Description "" -Background "Black"
+        }
+        ForEach($Computer In $ComputerList){
+            $ForwardDNS=$($Computer.DNSHostName).ToLower()
+            $CheckForwardDNS=$false
+            $CheckReverseDNS=$false
+            $ForwardLookup=$false
+            $IPv4AddressAD=$null
+            $ResolvedIP=$null
+            $OS=$Computer.OperatingSystem.ToLower()
+            If(($OS-like"*8*")-or($OS-like"*10*")){$OS="workstation"}Else{$OS=$null}
+            $Active=$false
+            If(!$OS-eq"workstation"){
+                $HostName=$($Computer.Name).ToUpper()
+                $DaysPast=DateDiff -StartDate $ResetDate -EndDate (@($($Computer.PasswordLastSet).Split(" "))[0])
+                If(!$($Computer.LastLogonDate)-eq""){
+                    $DaysLogon=DateDiff -StartDate $ResetDate -EndDate (@($($Computer.LastLogonDate).Split(" "))[0])
+                    If((0-lt$DaysPast)-or(0-lt$DaysLogon)){
+                        $Active=$true
+                        $Message=DisplayMessage -Description "$($HostName.ToLower()) changed it's password and/or logged into the '$SearchDomain' domain within 30 days" -FontColor "White" -Background "DarkMagenta"
+                    }Else{
+                        For($Counter=0;$Counter-le$DCCount;$Counter++){
+                            ForEach($CN In $SystemList[$Counter]){
+                                If($CN.Name-eq$HostName){
+                                    $DaysPast=DateDiff -StartDate $ResetDate -EndDate (@($($CN.PasswordLastSet).Split(" "))[0])
+                                    If(!$($CN.LastLogonDate)-eq""){
+                                        $DaysLogon=DateDiff -StartDate $ResetDate -EndDate (@($($CN.LastLogonDate).Split(" "))[0])
+                                        If((0-lt$DaysPast)-or(0-lt$DaysLogon)){
+                                            $Message=DisplayMessage -Description "$($HostName.ToLower()) changed it's password and/or logged into the '$SearchDomain' domain within 30 days" -FontColor "Yellow" -Background "DarkGray"
+                                            $Active=$true
+                                        }
+                                    }
+                                    Break
+                                }
+                            }
+                        }
+                        If($Active-eq$false){$Message=DisplayMessage -Description "$HostName last logon: '$($Computer.LastLogonDate)' and password was set on: '$($Computer.PasswordLastSet)'" -Background "DarkRed"}
+                    }
+                }
+                #Validate FOrward DSN Lookup
+                $CheckForwardDNS=DNSLookup -ObjectValue $ForwardDNS -SearchValue ("Name*"+$ForwardDNS+"*")
+                $ResolvedIP=$CheckForwardDNS[1]
+                If($CheckForwardDNS[0]-eq$true){
+                    $Message=DisplayMessage -Description "Forward Lookup was able to resolve $ForwardDNS to $($Computer.IPv4Address)" -FontColor "Yellow" -Background "DarkGreen"
+                }Else{
+                    $Message=DisplayMessage -Description "Forward Lookup does not resolve to $ForwardDNS" -FontColor "Yellow" -Background "DarkRed"
+                }
+                If(!$($Computer.IPv4Address)-eq""){
+                    $IPv4AddressAD=$($Computer.IPv4Address)
+                    $CheckReverseDNS=DNSLookup -ObjectValue $IPv4AddressAD -SearchValue ("Name*"+$ForwardDNS+"*")
+                    $ResolvedIP=$CheckForwardDNS[1]
+                    If($CheckReverseDNS[0]-eq$true){
+                        $Message=DisplayMessage -Description "Reverse Lookup was able to resolve $IPv4AddressAD to $($Computer.DNSHostName)" -FontColor "Yellow" -Background "DarkGreen"
+                    }Else{
+                        $Message=DisplayMessage -Description "Reverse Lookup record does not exist for $($Computer.DNSHostName)" -FontColor "Yellow" -Background "DarkRed"
+                    }
+                }Else{
+                    $Message=DisplayMessage -Description "$HostName does not have an IP Address listed in: '$SearchDomain'" -Background "DarkRed"
+                }
+                #Validate server is in the correct zone
+                $PartIP=$($Computer.IPv4Address.Split(".")[2])
+                If($(ZoneName -Octate3 $PartIP)-eq$($Computer.DNSHostName).Split(".")[1]){$CorrectZone=$true}
+                If($CorrectZone-eq$false){
+                    If($($Computer.DNSHostName).Split(".")[1]-eq$AuthUser.ToLower()){$RootDomain=$false}
+                }
+                If($Active-eq$true){
+                    If(@($($Computer.IPv4Address).Split("."))[1]-like"118"){
+                        $Message=DisplayMessage -Description "$ForwardDNS is located at ARDC" -FontColor "Cyan" -Background "DarkBlue"
+                        $IPv4AddressAD=$($Computer.IPv4Address).ToString()
+                        $Message=DisplayMessage -Description "Beginning process to ping $IPv4AddressAD" -FontColor "Cyan" -Background "DarkBlue"
+                        $AbleToPing=ProcessPing -ObjectValue "-a $IPv4AddressAD" -SearchValue "Reply from*bytes=*"
+                        $ResolvedIP=$AbleToPing[1]
+                        If($AbleToPing[0]-eq$true){
+                            $Message=DisplayMessage -Description "Was able to successfully ping $ForwardDNS using the IP Address: $ResolvedIP" -FontColor "Cyan" -Background "DarkBlue"
+                        }Else{
+                            $Message=DisplayMessage -Description "Failed to ping '$HostName' using the IP Address: $IPv4AddressAD" -FontColor "Red"
+                        }
+                    }ElseIf(@($($Computer.IPv4Address).Split("."))[1]-like"126"){
+                        $Message=DisplayMessage -Description "$ForwardDNS is located at UDCC" -FontColor "Green" -Background "DarkBlue"
+                        $IPv4AddressAD=$($Computer.IPv4Address).ToString()
+                        $Message=DisplayMessage -Description "Beginning process to ping $IPv4AddressAD" -FontColor "Green" -Background "DarkBlue"
+                        $AbleToPing=ProcessPing -ObjectValue "-a $IPv4AddressAD" -SearchValue "Reply from*bytes=*"
+                        $ResolvedIP=$AbleToPing[1]
+                        If($AbleToPing[0]-eq$true){
+                            $Message=DisplayMessage -Description "Was able to successfully ping $ForwardDNS using the IP Address: $ResolvedIP" -FontColor "Green" -Background "DarkBlue"
+                        }Else{
+                            $Message=DisplayMessage -Description "Failed to ping '$HostName' using the IP Address: $IPv4AddressAD" -FontColor "Red"
+                        }
+                    }
+                }Else{
+                    If($CheckForwardDNS-eq$true){
+                        $AbleToPing=ProcessPing -ObjectValue "-a $IPv4AddressAD" -SearchValue "Reply from*bytes=*"
+                        $ResolvedIP=$AbleToPing[1]
+                        If($AbleToPing[0]-eq$true){
+                            $Message=DisplayMessage -Description "Was able to successfully ping $ForwardDNS using the IP Address: $ResolvedIP" -FontColor "Cyan" -Background "DarkBlue"
+                        }Else{
+                            $Message=DisplayMessage -Description "Failed to ping '$HostName' using the IP Address: $IPv4AddressAD" -FontColor "Red"
+                        }
+                    }ElseIf($CheckReverseDNS-eq$true){
+                        $AbleToPing=ProcessPing -ObjectValue "$ForwardDNS" -SearchValue "Reply from*bytes=*"
+                        $ResolvedIP=$AbleToPing[1]
+                        If($AbleToPing[0]-eq$true){
+                            $Message=DisplayMessage -Description "Was able to successfully ping $ForwardDNS using the IP Address: $ResolvedIP" -FontColor "Cyan" -Background "DarkBlue"
+                        }Else{
+                            $Message=DisplayMessage -Description "Failed to ping '$HostName' using the IP Address: $IPv4AddressAD" -FontColor "Red"
+                        }
+                    }
+                }
+                For($Loop=0;$Loop-le2;$Loop++){
+                    $Message=DisplayMessage -Description "" -Background "Black"
+                }
+            }
+            If($AbleToPing-eq$true){$GoodIPAddress++}
+            If($AbleToPing-eq$false){$BadIPAddress++}
+            If($Active-eq$false){$BadComputer++}
+            $LastLogon=$null
+            $DaysLogon=$null
+            $LastPass=$null
+            $DaysPast=$null
+        }
+    }Else{$Message=DisplayMessage -Description "$DomainController IS NOT a valid domain controller for the $SearchDomain domain." -Background "DarkRed"}
+}
+$BGC=(Get-Host).UI.RawUI.BackgroundColor=$BGC
+$FGC=(Get-Host).UI.RawUI.ForegroundColor=$FGC
+If(Test-Path $NSLookupData){Remove-Item -Path $NSLookupData -Force}
+$EndTime=TimeDiff -StartDate $StartTime -EndDate (Get-Date).toString('H:mm:ss-M/d/yyyy')
+Write-Host "'$EndTime minutes have past, Good computers: $GoodIPAddress, Failed to ping: $BadIPAddress, Not in DNS: $BadComputer'"
+Set-Location -Path "C:\Windows\System32"
+$DomainController=$null;$GoodIPAddress=$null;$BadIPAddress=$null;$BadComputer=$null;$WorkingPath=$null;$ValidDCName=$null;$ResolvedIP=$null
+$UserDomain=$null;$UserName=$null;$AuthUser=$null;$Counter=$null;$Message=$null;$FocusDC=$null;$DCCount=$null;$Active=$null;
+$DCList=$null;$LastPass=$null;$DaysPast=$null;$LastLogon=$null;$DaysLogon=$null;$SystemList=$null;$SearchDomain=$null
\ No newline at end of file
diff --git a/PowerShell/General/VerifyHash.ps1 b/PowerShell/General/VerifyHash.ps1
new file mode 100644
index 0000000..a8d0657
--- /dev/null
+++ b/PowerShell/General/VerifyHash.ps1
@@ -0,0 +1,36 @@
+﻿# Path of Microsoft.PowerShell.Utility.psd1
+$file = (Get-Module Microsoft.PowerShell.Utility).Path
+
+$hashFromFile = Get-FileHash -Path $file -Algorithm MD5
+
+# Open $file as a stream
+$stream = [System.IO.File]::OpenRead($file)
+$hashFromStream = Get-FileHash -InputStream $stream -Algorithm MD5
+$stream.Close()
+
+Write-Host '### Hash from File ###' -NoNewline
+$hashFromFile | Format-List
+Write-Host '### Hash from Stream ###' -NoNewline
+$hashFromStream | Format-List
+
+# Check both hashes are the same
+if ($hashFromFile.Hash -eq $hashFromStream.Hash) {
+	Write-Host 'Get-FileHash results are consistent' -ForegroundColor Green
+} else {
+	Write-Host 'Get-FileHash results are inconsistent!!' -ForegroundColor Red
+}
+<#
+### Hash from File ###
+
+Algorithm : MD5
+Hash      : 593D6592BD9B7F9174711AB136F5E751
+Path      : C:\Program Files\PowerShell\6.0.0\Modules\Microsoft.Powe
+            rShell.Utility\Microsoft.PowerShell.Utility.psd1
+
+### Hash from Stream ###
+
+Algorithm : MD5
+Hash      : 593D6592BD9B7F9174711AB136F5E751
+Path      :
+
+Get-FileHash results are consistent #>
\ No newline at end of file
diff --git a/PowerShell/General/WinEvents-Test.ps1 b/PowerShell/General/WinEvents-Test.ps1
new file mode 100644
index 0000000..0481d9e
--- /dev/null
+++ b/PowerShell/General/WinEvents-Test.ps1
@@ -0,0 +1,2 @@
+﻿Clear-Host;Clear-History
+(get-winevent -listprovider microsoft-windows-printservice).events | format-table id, description -auto
\ No newline at end of file
diff --git a/PowerShell/General/ping_cmcs.ps1 b/PowerShell/General/ping_cmcs.ps1
new file mode 100644
index 0000000..6c6b62a
--- /dev/null
+++ b/PowerShell/General/ping_cmcs.ps1
@@ -0,0 +1,130 @@
+Clear-History;Clear-Host
+Set-Variable -Name Devices -Value @("1","3","4","5","6","7","8")
+Set-Variable -Name Chassis -Value @("1","2","3","4","5","6","9")
+Set-Variable -Name Sites -Value @("10.118.2.","10.126.2.")
+Set-Variable -Name IPAddress -Value @()
+Set-Variable -Name Loops -Value 5000
+Set-Variable -Name Start -Value 101
+Set-Variable -Name ResolveIP -Value $null
+Set-Variable -Name ChassisName -Value $null
+Set-Variable -Name CmcIPAddress -Value $null
+Set-Variable -Name DType -Value $null
+Set-Variable -Name SC -Value $null
+$Global:CType="cmc1ke"
+$Global:LServer=($env:LOGONSERVER)
+$Global:UDomain=($env:USERDNSDOMAIN)
+Set-Variable -Name DNSHost -Value (($LServer+"."+$UDomain).ToLower()).Replace("\\","")
+ForEach($S In $Sites){
+    $Start=101;$N=$null;$NetIPAddress=0
+    ForEach($C In $Chassis){
+        Switch(($S).Split(".")[1]){
+            "118"{
+                If($C-eq"9"){
+                    $N="6"
+                }Else{
+                    $N=$C
+                }
+                $ResolveIP=($($S)+$($C)+"1")
+                $ChassisName=($CType+$N+"a1.mgt."+$UDomain).ToLower();Break}
+            "126"{
+                If($C-eq"6"){
+                    $N="7"
+                }Else{
+                    $N=$C
+                }
+                $ResolveIP=($($S)+$($N)+"1")
+                $ChassisName=($CType+$C+"b1.mgt."+$UDomain).ToLower();Break}
+        }
+        $CmcIPAddress=(Resolve-DnsName -Name $ChassisName -ErrorAction SilentlyContinue).IPAddress
+        If($CmcIPAddress-eq$ResolveIP){
+            $R=$null;$HC=0
+            Switch(($S).Split(".")[1]){
+                "118"{
+                    $R=$C
+                    $HC=16
+                    $SC="a"
+                    Break}
+                "126"{
+                    $R=$N
+                    If($R-eq7){
+                        $HC=12
+                        $Start+=16
+                    }Else{
+                        $HC=16
+                    }
+                    $SC="b"
+                    Break}
+            }
+            ForEach($D In $Devices){
+                $NetIPAddress=($S+$R+$D)
+                $IPAddress+=$NetIPAddress
+                $FQDN=(Resolve-DnsName $NetIPAddress -ErrorAction SilentlyContinue).NameHost
+                If(($FQDN-eq$null)-and!($FQDN-eq$ChassisName)){
+                    $DN=1;$DType=$null
+                    Switch($D){
+                        {($_-eq3)-or($_-eq8)}{
+                            If($_-eq8){
+                                $DN=2
+                            }
+                            $DType=("pem10"+$SC+$C+"a"+$DN+".mgt."+$UDomain).ToLower()
+                            Break
+                        }
+                        {($_-eq4)-or($_-eq7)}{
+                            If($_-eq7){
+                                $DN=2
+                            }
+                            $DType=("pem10"+$SC+$C+"b"+$DN+".mgt."+$UDomain).ToLower()
+                            Break
+                        }
+                        {($_-eq5)-or($_-eq6)}{
+                            If($_-eq6){
+                                $DN=2
+                            }
+                            $DType=("bc6505"+$SC+$C+"c"+$DN+".mgt."+$UDomain).ToLower()
+                            Break
+                        }
+                    }
+                    $FQDN=(Resolve-DnsName -Name $DType -ErrorAction SilentlyContinue).Name
+                    If($FQDN-eq$null){
+                        $NetBIOS=($DType).Split(".")[0]
+                        Add-DnsServerResourceRecordA -Name $NetBIOS -ZoneName ("mgt."+$UDomain).ToLower() -AllowUpdateAny -IPv4Address $NetIPAddress -TimeToLive 01:00:00
+                    }
+                    $SO=($S).Split(".")[1]
+                    Add-DnsServerResourceRecordPtr -Name ($R+$D) -ZoneName ("2."+$SO+".10.in-addr.arpa") -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $DType
+                }
+            }
+            For($h=1;$h-le$HC;$h++){
+                $NetIPAddress=($S+$Start)
+                $IPAddress+=$NetIPAddress
+                $FQDN=(Resolve-DnsName $NetIPAddress -ErrorAction SilentlyContinue).NameHost
+                If($FQDN-eq$null){
+                    $SN=0;$DType=$null
+                    If($h-le9){
+                        $SN=($C+"0"+$h)
+                    }Else{
+                        $SN=($C+$h)
+                    }
+                    $DType=("m630"+$SC+$SN+".mgt."+$UDomain).ToLower()
+                    $FQDN=(Resolve-DnsName -Name $DType -ErrorAction SilentlyContinue).Name
+                    If($FQDN-eq$null){
+                        $NetBIOS=($DType).Split(".")[0]
+                        Add-DnsServerResourceRecordA -ComputerName $DNSHost -Name $NetBIOS -ZoneName ("mgt."+$UDomain).ToLower() -AllowUpdateAny -IPv4Address $NetIPAddress -TimeToLive 01:00:00
+                    }
+                    $SO=($S).Split(".")[1]
+                    $SN=($NetIPAddress.Split(".")[3])
+                    Add-DnsServerResourceRecordPtr -ComputerName $DNSHost -Name $SN -ZoneName ("2."+$SO+".10.in-addr.arpa") -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $DType
+                }
+                $Start++
+            }
+        }
+    }
+}
+Set-Variable -Name Count -Value 0
+For($l=0;$l-lt$Loops;$l++){
+    ForEach($IP In $IPAddress){
+        ping -a -n 3 -w 50 $($IP)
+    }
+    $Count++
+    $Msg=("The current loop count is: "+$Count+" of "+$Loops+" loops")
+    Clear;Write-Host $Msg
+}
\ No newline at end of file
diff --git a/PowerShell/Install SCCM Current Branch latest version.ps1 b/PowerShell/Install SCCM Current Branch latest version.ps1
new file mode 100644
index 0000000..ed3a6e4
--- /dev/null
+++ b/PowerShell/Install SCCM Current Branch latest version.ps1	
@@ -0,0 +1,144 @@
+﻿Set-ExecutionPolicy -ExecutionPolicy ByPass
+Set-ExecutionPolicy Unrestricted
+Clear-History;Clear-Host
+If(-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]“Administrator”)){
+    Write-Warning “You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!”
+    Break
+}
+$folderpath="E:\Sources\Scripts"
+$SCCMSource="E:\Sources\SCCM_2016"
+Try{
+    If(Test-Path -Path $SCCMSource){
+        Write-Host "found the media for SCCM Current Branch (cd.latest version)"
+    }Else{
+        Write-Host "Could not find the media for SCCM Current Branch (cd.latest version)..."
+        Break
+    }
+}Catch{
+    Write-Host "Something went wrong with the installation of SCCM Current Branch (latest version), aborting."
+    Break
+}
+Set-Variable -Name SCCM_ARDC_Server -Value "w16asccmdb01.inf.utshare.local"
+Set-Variable -Name SCCM_UDCC_Server -Value "w16bsccmdb01.inf.utshare.local"
+Set-Variable -Name SCCM_ARDC_Share -Value "DFW"
+Set-Variable -Name SCCM_UDCC_Share -Value "AUS"
+Set-Variable -Name IP_Address -Value $null
+Set-Variable -Name Octet_1 -Value $null
+Set-Variable -Name Octet_2 -Value $null
+Set-Variable -Name Octet_3 -Value $null
+Set-Variable -Name Octet_4 -Value $null
+$IP_Address=Get-NetIpAddress|Where-Object{$_.AddressFamily-eq"IPv4"}
+ForEach($IPv4 In $IP_Address.IPAddress){
+    $Parser=$IPv4.Split(".")
+    For($O=0;$O-le3;$O++){
+        Switch($O){
+            0{$Octet_1=$Parser[$O];Break}
+            1{$Octet_2=$Parser[$O];Break}
+            2{$Octet_3=$Parser[$O];Break}
+            3{$Octet_4=$Parser[$O];Break}
+        }
+    }
+    If($Octet_1-eq10){
+        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+            $SiteCode=$SCCM_ARDC_Share
+            $SDKServer=$SCCM_ARDC_Server
+            $SQLSSBPort="4022"
+        }
+        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+            $SiteCode=$SCCM_UDCC_Share
+            $SDKServer=$SCCM_UDCC_Server
+            $SQLSSBPort="4023"
+        }
+        Break
+    }
+}
+$UserDnsDomain=$($env:USERDNSDOMAIN).ToLower()
+$Sitename="$UserDnsDomain - Primary Site ($SiteCode)"
+$Action="InstallPrimarySite"
+$ProductID="BXH69-M62YX-QQD6R-3GPWX-8WMFY"
+$SMSInstallDir="E:\Program Files\Microsoft Configuration Manager"
+$RoleCommunicationProtocol="HTTPorHTTPS"
+$ClientsUsePKICertificate="0"
+$PrerequisiteComp="1"
+$PrerequisitePath="E:\sources\Downloads"
+$ManagementPoint="$SDKServer"
+$ManagementPointProtocol="HTTP"
+$DistributionPoint="$SDKServer"
+$DistributionPointProtocol="HTTP"
+$DistributionPointInstallIIS="0"
+$AdminConsole="1"
+$JoinCEIP="0"
+$SQLServerName=$SDKServer
+$DatabaseName="CM_$SiteCode"
+$CloudConnector="1"
+$CloudConnectorServer="$SDKServer"
+$UseProxy="0"
+$ProxyName=""
+$ProxyPort=""
+$SysCenterId=""
+$conffile=@"
+[Identification]
+Action="$Action"
+
+[Options]
+ProductID="$ProductID"
+SiteCode="$SiteCode"
+SiteName="$Sitename"
+SMSInstallDir="$SMSInstallDir"
+SDKServer="$SDKServer"
+RoleCommunicationProtocol="$RoleCommunicationProtocol"
+ClientsUsePKICertificate="$ClientsUsePKICertificate"
+PrerequisiteComp="$PrerequisiteComp"
+PrerequisitePath="$PrerequisitePath"
+ManagementPoint="$ManagementPoint"
+ManagementPointProtocol="$ManagementPointProtocol"
+DistributionPoint="$DistributionPoint"
+DistributionPointProtocol="$DistributionPointProtocol"
+DistributionPointInstallIIS="$DistributionPointInstallIIS"
+AdminConsole="$AdminConsole"
+JoinCEIP="$JoinCEIP"
+
+[SQLConfigOptions]
+SQLServerName="$SQLServerName"
+DatabaseName="$DatabaseName"
+SQLSSBPort="$SQLSSBPort"
+
+[CloudConnectorOptions]
+CloudConnector="$CloudConnector"
+CloudConnectorServer="$CloudConnectorServer"
+UseProxy="$UseProxy"
+ProxyName="$ProxyName"
+ProxyPort="$ProxyPort"
+
+[SystemCenterOptions]
+SysCenterId="$SysCenterId"
+
+[HierarchyExpansionOption]
+
+"@
+If(Test-Path -Path "$folderpath"){
+    Write-Host "The folder '$folderpath' already exists, will not recreate it."
+}Else{
+    mkdir "$folderpath"
+}
+$ConfigFile=$SiteCode+"_ConfigMgr_AutoSave.ini"
+If(Test-Path "$folderpath\$ConfigFile"){
+    Write-Host "The file '$folderpath\$ConfigFile' already exists, removing..."
+    Remove-Item -Path "$folderpath\$ConfigFile" -Force
+}Else{
+    Write-Host "Creating '$folderpath\$ConfigFile'..."
+}
+New-Item -Path "$folderpath\$ConfigFile" -ItemType File -Value $Conffile
+Write-Host "about to install SCCM cd.latest version..." -nonewline
+$filepath="$SCCMSource\SMSSETUP\bin\X64\Setup.exe"
+$Parms=" /script C:\scripts\$ConfigFile"
+$Prms=$Parms.Split(" ")
+Try{
+    & "$filepath" $Prms|Out-Null
+}Catch{
+    Write-Host "error!" -ForegroundColor red
+    Break
+}
+Write-Host "done!" -ForegroundColor Green
+Write-Host "Exiting script, goodbye."
+Set-ExecutionPolicy Restricted
diff --git a/PowerShell/Install SQL Server 2016.ps1 b/PowerShell/Install SQL Server 2016.ps1
new file mode 100644
index 0000000..d9074db
--- /dev/null
+++ b/PowerShell/Install SQL Server 2016.ps1	
@@ -0,0 +1,161 @@
+﻿<# 
+# This Script:        Niall Brady      - http://www.windows-noob.com
+#                                      - 2016/12/6.
+#                                      - Installs SQL Server 2016 with Management Studio from here http://go.microsoft.com/fwlink/?linkid=832812
+#                                      - copy the SSMS (Management Studio) file to $folderpath\SSMS-Setup-ENU.exe in advance if you don't want the script to download it
+#>
+If(-not([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]“Administrator”)){
+    Write-Warning “You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!”
+    Break
+}
+# User define variables
+$ProgFileDir="Program Files"
+$DataDrive="F:\$ProgFileDir"
+$LogsDrive="G:\$ProgFileDir"
+$TempDrive="H:\$ProgFileDir"
+$BckpDrive="I:\$ProgFileDir"
+# below variables are customizable
+$folderpath="C:\Scripts"
+$inifile="$folderpath\ConfigurationFile.ini"
+# next line sets user as a SQL sysadmin
+$userDomain=$env:USERDOMAIN
+$yourusername="$userDomain\zasvccm_naa"
+# path to the SQL media
+$SQLsource="D:\"
+# configurationfile.ini settings https://msdn.microsoft.com/en-us/library/ms144259.aspx
+$ACTION="Install"
+$ASCOLLATION="Latin1_General_CI_AS"
+$ErrorReporting="False"
+$SUPPRESSPRIVACYSTATEMENTNOTICE="False"
+$IACCEPTROPENLICENSETERMS="False"
+$ENU="True"
+$QUIET="True"
+$QUIETSIMPLE="False"
+$UpdateEnabled="True"
+$USEMICROSOFTUPDATE="False"
+$FEATURES="SQLENGINE,RS,CONN,IS,BC,SDK,BOL"
+$UpdateSource="MU"
+$HELP="False"
+$INDICATEPROGRESS="False"
+$X86="False"
+$INSTANCENAME="SCCM"
+$INSTALLSHAREDDIR="E:\Program Files\Microsoft SQL Server"
+$INSTALLSHAREDWOWDIR="E:\Program Files (x86)\Microsoft SQL Server"
+$INSTANCEID="MSSQLSERVER"
+$RSINSTALLMODE="DefaultNativeMode"
+$SQLTELSVCACCT="NT Service\SQLTELEMETRY"
+$SQLTELSVCSTARTUPTYPE="Automatic"
+$ISTELSVCSTARTUPTYPE="Automatic"
+$ISTELSVCACCT="NT Service\SSISTELEMETRY130"
+$INSTANCEDIR="E:\Program Files\Microsoft SQL Server"
+$AGTSVCACCOUNT="NT AUTHORITY\SYSTEM"
+$AGTSVCSTARTUPTYPE="Automatic"
+$ISSVCSTARTUPTYPE="Disabled"
+$ISSVCACCOUNT="NT AUTHORITY\System"
+$COMMFABRICPORT="0"
+$COMMFABRICNETWORKLEVEL="0"
+$COMMFABRICENCRYPTION="0"
+$MATRIXCMBRICKCOMMPORT="0"
+$SQLSVCSTARTUPTYPE="Automatic"
+$FILESTREAMLEVEL="0"
+$ENABLERANU="False"
+$SQLCOLLATION="SQL_Latin1_General_CP1_CI_AS"
+$SQLSVCACCOUNT="NT AUTHORITY\System"
+$SQLSVCINSTANTFILEINIT="False"
+$SQLSYSADMINACCOUNTS="$yourusername"
+$SQLTEMPDBFILECOUNT="1"
+$SQLTEMPDBFILESIZE="8"
+$SQLTEMPDBFILEGROWTH="64"
+$SQLTEMPDBLOGFILESIZE="8"
+$SQLTEMPDBLOGFILEGROWTH="64"
+$ADDCURRENTUSERASSQLADMIN="True"
+$TCPENABLED="1"
+$NPENABLED="1"
+$BROWSERSVCSTARTUPTYPE="Disabled"
+$RSSVCACCOUNT="NT AUTHORITY\System"
+$RSSVCSTARTUPTYPE="Automatic"
+$IAcceptSQLServerLicenseTerms="True"
+# User define variables
+$SQLUSERDBDIR="$DataDrive\$INSTANCENAME\MSSQL\Data"
+$SQLUSERDBLOGDIR="$LogsDrive\$INSTANCENAME\MSSQL\Data"
+$SQLTEMPDBDIR="$TempDrive\$INSTANCENAME\MSSQL\Data"
+$SQLBACKUPDIR="$BckpDrive\$INSTANCENAME\MSSQL\Data"
+# do not edit below this line
+$conffile=@"
+[OPTIONS]
+Action="$ACTION"
+ErrorReporting="$ERRORREPORTING"
+Quiet="$Quiet"
+Features="$FEATURES"
+InstanceName="$INSTANCENAME"
+InstanceDir="$INSTANCEDIR"
+SQLSVCAccount="$SQLSVCACCOUNT"
+SQLSysAdminAccounts="$SQLSYSADMINACCOUNTS"
+SQLSVCStartupType="$SQLSVCSTARTUPTYPE"
+SQLUSERDBDIR="$SQLUSERDBDIR"
+SQLUSERDBLOGDIR="$SQLUSERDBLOGDIR"
+SQLTEMPDBDIR="$SQLTEMPDBDIR"
+SQLBACKUPDIR="$SQLBACKUPDIR"
+AGTSVCACCOUNT="$AGTSVCACCOUNT"
+AGTSVCSTARTUPTYPE="$AGTSVCSTARTUPTYPE"
+RSSVCACCOUNT="$RSSVCACCOUNT"
+RSSVCSTARTUPTYPE="$RSSVCSTARTUPTYPE"
+ISSVCACCOUNT="$ISSVCACCOUNT" 
+ISSVCSTARTUPTYPE="$ISSVCSTARTUPTYPE"
+ASCOLLATION="$ASCOLLATION"
+SQLCOLLATION="$SQLCOLLATION"
+TCPENABLED="$TCPENABLED"
+NPENABLED="$NPENABLED"
+IAcceptSQLServerLicenseTerms="$IAcceptSQLServerLicenseTerms"
+"@
+# Check for Script Directory & file
+If(Test-Path "$folderpath"){
+    Write-Host "The folder '$folderpath' already exists, will not recreate it."
+}Else{
+    MkDir "$folderpath"
+}
+If(Test-Path "$folderpath\ConfigurationFile.ini"){
+    Write-Host "The file '$folderpath\ConfigurationFile.ini' already exists, removing..."
+    Remove-Item -Path "$folderpath\ConfigurationFile.ini" -Force
+}Else{
+# Create file:
+    Write-Host "Creating '$folderpath\ConfigurationFile.ini'..."
+    New-Item -Path "$folderpath\ConfigurationFile.ini" -ItemType File -Value $Conffile
+}
+# Create firewall rule
+If(!(Get-NetFirewallRule -DisplayName "SQL Server (TCP 1433) Inbound" -ErrorAction SilentlyContinue)){
+    Write-Host "Creating firewall rule"
+    New-NetFirewallRule -DisplayName "SQL Server (TCP 1433) Inbound" -Action Allow -Direction Inbound -LocalPort 1433 -Protocol TCP
+}
+# start the SQL installer
+Try{
+    If(Test-Path $SQLsource){
+        Write-Host "about to install SQL Server 2016..."
+        $FileExe="$SQLsource\setup.exe"
+        $CONFIGURATIONFILE="$folderpath\ConfigurationFile.ini $FileExe /CONFIGURATIONFILE=$CONFIGURATIONFILE"
+    }Else{
+        Write-Host "Could not find the media for SQL Server 2016..."
+        Break
+    }
+}Catch{
+    Write-Host "Something went wrong with the installation of SQL Server 2016, aborting."
+    Break
+}
+# start the SQL SSMS downloader
+$filepath="$folderpath\SSMS-Setup-ENU.exe"
+If(!(Test-Path $filepath)){
+    Write-Host "Downloading SQL Server 2016 SSMS..."
+    $URL="https://download.microsoft.com/download/3/1/D/31D734E0-BFE8-4C33-A9DE-2392808ADEE6/SSMS-Setup-ENU.exe"
+    $clnt=New-Object System.Net.WebClient
+    $clnt.DownloadFile($url,$filepath)
+    Write-Host "done!" -ForegroundColor Green
+}Else{
+    Write-Host "found the SQL SSMS Installer, no need to download it..."
+}
+# start the SQL SSMS installer
+Write-Host "about to install SQL Server 2016 SSMS..." -nonewline
+$Parms=" /Install /Quiet /Norestart /Logs log.txt"
+$Prms=$Parms.Split(" ")+"$filepath"+$Prms|Out-Null
+Write-Host "done!" -ForegroundColor Green
+# exit script
+Write-Host "Exiting script, goodbye."
\ No newline at end of file
diff --git a/PowerShell/JoinDomain.ps1 b/PowerShell/JoinDomain.ps1
new file mode 100644
index 0000000..4a4bc49
--- /dev/null
+++ b/PowerShell/JoinDomain.ps1
@@ -0,0 +1,10 @@
+<# join computer to domain and then reboot
+#  2016/12/2 niall brady
+#>
+$domain = "windowsnoob"
+$password = "P@ssw0rd" | ConvertTo-SecureString -asPlainText -Force
+$joindomainuser = "Administrator"
+$username = "$domain\$joindomainuser" 
+$credential = New-Object System.Management.Automation.PSCredential($username,$password)
+Add-Computer -DomainName $domain -Credential $credential
+Restart-Computer
\ No newline at end of file
diff --git a/PowerShell/Linux-Rename.ps1 b/PowerShell/Linux-Rename.ps1
new file mode 100644
index 0000000..f6cc1a0
--- /dev/null
+++ b/PowerShell/Linux-Rename.ps1
@@ -0,0 +1,68 @@
+﻿Clear-Host;Clear-History
+Set-Location $env:SystemRoot\System32
+$StartingPath=Get-Location
+Set-Variable -Name MainPath -Value "E:\Shared\Storage\s"
+Do{
+    Set-Variable -Name WorkingPath -Value $MainPath
+    If(!(Test-Path -LiteralPath $MainPath)){Break}
+    Set-Location -Path $WorkingPath
+    Set-Variable -Name Folders -Value $null
+    Set-Variable -Name Files -Value $null
+    Set-Variable -Name AlphaNum -Value "0123456789abcdefghijklmnopqrstuvwxyz"
+    Do{
+        Set-Variable -Name DirLoop -Value 0
+        Set-Variable -Name DirCount -Value 0
+        Set-Variable -Name FileCount -Value 0
+        Set-Variable -Name CurrentPath -Value $null
+        $Folders=Get-ChildItem -Path $WorkingPath|?{$_.PSISContainer}
+        If($Folders-ne$null){
+            ForEach($Folder In $Folders){
+                If($CurrentPath-eq$null){
+                    $DirCount=$Folders.Count
+                    $CurrentPath=$Folder.FullName
+                    $WorkingPath=$CurrentPath
+                    Echo $CurrentPath
+                }
+                $Files=Get-ChildItem -Path $Folder.FullName -File
+                $FileCount=$Files.Count
+                $varLenght=0
+                If($FileCount-gt0){
+                    Switch ($FileCount){
+                        {$_-lt36}{$varLenght=1;Break}
+                        {$_-lt36*36}{$varLenght=2;Break}
+                        {$_-lt36*36*36}{$varLenght=3;Break}
+                        Default{$varLenght=4;Break}
+                    }
+                    $FileLoop=0
+                    ForEach($File In $Files){
+                        $FileName=$File.FullName
+                        $NewName=$AlphaNum.Substring($FileLoop,1)+$File.Extension
+                        If($File.Name-ne$NewName){
+                            Rename-Item -LiteralPath $FileName -NewName $NewName
+                        }
+                        $FileLoop++
+                    }
+                }
+                If($($Folder.Name).Length-gt1){
+                    $DirName=$Folder.FullName
+                    $NewDir=$AlphaNum.Substring($DirLoop,1)
+                    If($Folder.Name-ne$NewDir){
+                        Rename-Item -LiteralPath $DirName -NewName $NewDir
+                        If($DirLoop-eq0){
+                            $PathSize=$($DirName).Length
+                            $DirSize=$($Folder.Name).Length
+                            $DirLength=$PathSize-$DirSize
+                            $WorkingPath=$($DirName.Substring(0,$DirLength))+$NewDir
+                            Remove-Item -LiteralPath $WorkingPath -Recurse -Force
+                        }
+                    }
+                }
+                $DirLoop++
+            }
+        }Else{
+            Set-Location -Path $StartingPath
+            Remove-Item -LiteralPath $MainPath -Recurse -Force
+            Break
+        }
+    }Until($StartingPath-eq$WorkingPath)
+}While(Test-Path -LiteralPath $MainPath)
\ No newline at end of file
diff --git a/PowerShell/Modules/ProcessCredentials.psm1 b/PowerShell/Modules/ProcessCredentials.psm1
new file mode 100644
index 0000000..2d06d47
--- /dev/null
+++ b/PowerShell/Modules/ProcessCredentials.psm1
@@ -0,0 +1,173 @@
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$true)]$SecureUser,[String][Parameter(Mandatory=$true)]$Domain)
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|ForEach-Object{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $Script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
diff --git a/PowerShell/ReinstallSccmClient.ps1 b/PowerShell/ReinstallSccmClient.ps1
new file mode 100644
index 0000000..3810043
--- /dev/null
+++ b/PowerShell/ReinstallSccmClient.ps1
@@ -0,0 +1,8 @@
+﻿CLS
+$SysRoot=$env:SystemRoot
+$SysDir=$SysRoot+"\System32"
+Set-Location $SysDir
+If(Test-Path $SysDir"\CMTrace.exe"="False"){Copy-Item "\\w16sccmmgra01.inf.utshare.local\SMSSETUP\TOOLS\CMTrace.exe" -Destination $SysDir}
+If(Test-Path -Path $SysRoot"\ccm"="True"){Start-Process -FilePath "\\w16sccmmgra01.inf.utshare.local\SMSSETUP\Client\ccmsetup.exe" "/uninstall" -Wait}
+Start-Process -FilePath "\\w16sccmmgra01.inf.utshare.local\SMSSETUP\Client\ccmsetup.exe"
+Start-Process -FilePath "$SysDir\CMTrace.exe" "C:\Windows\ccmsetup\Logs\ccmsetup.log"
\ No newline at end of file
diff --git a/PowerShell/RepairWMI.ps1 b/PowerShell/RepairWMI.ps1
new file mode 100644
index 0000000..bc4cee9
--- /dev/null
+++ b/PowerShell/RepairWMI.ps1
@@ -0,0 +1,54 @@
+﻿Clear-History;Clear-Host
+Set-Variable -Name WMI_Path -Value "$env:SystemRoot\System32\wbem\repository"
+Set-Variable -Name WMI_Path_Old -Value $WMI_Path-old
+Set-Variable -Name SCCM_ARDC_Server -Value w16asccmdb01.inf.utshare.local
+Set-Variable -Name SCCM_UDCC_Server -Value w16bsccmdb01.inf.utshare.local
+Set-Variable -Name SCCM_ARDC_Share -Value SMS_DFW
+Set-Variable -Name SCCM_UDCC_Share -Value SMS_AUS
+Set-Variable -Name SCCM_Client -Value Client\ccmsetup.exe
+Set-Variable -Name IP_Address -Value $null
+Set-Variable -Name Octet_1 -Value $null
+Set-Variable -Name Octet_2 -Value $null
+Set-Variable -Name Octet_3 -Value $null
+Set-Variable -Name Octet_4 -Value $null
+Set-Variable -Name Primary_Site -Value $null
+Set-Variable -Name SCCM_Client_Install -Value $null
+Stop-Service -Name "Winmgmt" -Force
+If(Test-Path $WMI_Path_Old){Remove-Item $WMI_Path_Old -Recurse -Force}
+Rename-Item -Path $WMI_Path -NewName $WMI_Path_Old
+Start-Service -Name "Winmgmt"
+$IP_Address=Get-NetIpAddress|Where-Object{$_.AddressFamily-eq"IPv4"}
+ForEach($IPv4 In $IP_Address.IPAddress){
+    $Parser=$IPv4.Split(".")
+    For($O=0;$O-le3;$O++){
+        Switch($O){
+            0{$Octet_1=$Parser[$O];Break}
+            1{$Octet_2=$Parser[$O];Break}
+            2{$Octet_3=$Parser[$O];Break}
+            3{$Octet_4=$Parser[$O];Break}
+        }
+    }
+    If($Octet_1-eq10){
+        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+            $Primary_Site="\\$SCCM_ARDC_Server\$SCCM_ARDC_Share"
+        }
+        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+            $Primary_Site="\\$SCCM_UDCC_Server\$SCCM_UDCC_Share"
+        }
+        $SCCM_Client_Install="$Primary_Site\$SCCM_CLient";Break
+    }
+}
+Set-Location -Path "$env:SystemRoot\System32"
+If(!(Test-Path "$env:SystemRoot\System32\cmtrace.exe")){
+    Copy-Item -Path "\\dca01.utshare.local\admin$\System32\cmtrace.exe"
+}
+If(!(Test-Path "$env:SystemRoot\System32\reboot.cmd")){
+    Copy-Item -Path "\\dca01.utshare.local\admin$\System32\reboot.cmd"
+}
+If(!($Primary_Site-eq$null)){
+    Start-Process -FilePath $SCCM_Client_Install -ArgumentList "/uninstall"
+    $ccmsetup=(Get-Process -Name "ccmsetup").Id
+    Wait-Process -Id $ccmsetup
+    Remove-Item "$env:systemroot\ccm*" -Recurse -Force
+    Start-Process -FilePath $SCCM_Client_Install
+}
\ No newline at end of file
diff --git a/PowerShell/SCCM_Client_Health/ClientHealthMonitor.ps1 b/PowerShell/SCCM_Client_Health/ClientHealthMonitor.ps1
new file mode 100644
index 0000000..53e4208
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/ClientHealthMonitor.ps1
@@ -0,0 +1,307 @@
+﻿<#
+.SYNOPSIS
+    Automatically remediate SCCM clients stuck in provisoning mode or clients having corrupt local group policy files. Two very common problems related to Configuration Manager Client Health
+    
+.EXAMPLES
+    .\SCCM-ClientHealthMonitor.ps1 -TestProvMode -TestGPOFiles (this will run the test and remediation for both options and log to file locally)
+
+    .\SCCM-ClientHealthMonitor.ps1 -TestProvMode -TestGPOFiles -SendEmail (this will run the test and remediation for both options and log to file locally and send an email with the log attached)
+   
+.DESCRIPTION
+    A complete script that fixes two common problems related to Configuration Manager client health:
+     
+    SCCM clients stuck in provisioning mode has very limited capabilities and does not work properly.
+    Windows with corrupt local group policy files are known for not scanning and reporting Software Updates compliance.
+
+.NOTES
+    Filename: SCCM-ClientHealthMonitor.ps1
+    Version: 1.0
+    Author: Martin Bengtsson
+    Blog: www.imab.dk
+    Twitter: @mwbengtsson
+
+.LINKS
+    My post about the script can be found here alongside some additional information: https://www.imab.dk/sccm-client-health-monitor-automatically-remediate-provisioning-mode-and-corrupt-local-group-policy-files/
+
+    The remediation of the local group policy files are done with inspiration from this: https://itinlegal.wordpress.com/2017/09/09/psa-locating-badcorrupt-registry-pol-files/
+
+    The Write-Log function in this script is this: https://gallery.technet.microsoft.com/scriptcenter/Write-Log-PowerShell-999c32d0
+    
+#> 
+
+[CmdletBinding()]
+param(
+    [parameter(Mandatory=$false)]
+    [ValidateNotNullOrEmpty()]
+    [switch]$SendEmail,
+
+    [parameter(Mandatory=$false)]
+    [ValidateNotNullOrEmpty()]
+    [switch]$TestProvMode,
+
+    [parameter(Mandatory=$false)]
+    [ValidateNotNullOrEmpty()]
+    [switch]$TestGPOFiles
+)
+
+function Write-Log {
+    [CmdletBinding()]
+    Param
+    (
+        [Parameter(Mandatory=$true,
+                   ValueFromPipelineByPropertyName=$true)]
+        [ValidateNotNullOrEmpty()]
+        [Alias("LogContent")]
+        [string]$Message,
+        
+        # EDIT with your location for the local log file
+        [Parameter(Mandatory=$false)]
+        [Alias('LogPath')]
+        [string]$Path="$env:SystemRoot\" + "SCCM-ClientHealthMonitor.log",
+        
+        [Parameter(Mandatory=$false)]
+        [ValidateSet("Error","Warn","Info")]
+        [string]$Level="Info",
+        
+        [Parameter(Mandatory=$false)]
+        [switch]$NoClobber
+    )
+
+    Begin
+    {
+        # Set VerbosePreference to Continue so that verbose messages are displayed.
+        $VerbosePreference = 'Continue'
+    }
+    Process
+    {
+        
+        # If the file already exists and NoClobber was specified, do not write to the log.
+        if ((Test-Path $Path) -AND $NoClobber) {
+            Write-Error "Log file $Path already exists, and you specified NoClobber. Either delete the file or specify a different name."
+            Return
+            }
+
+        # If attempting to write to a log file in a folder/path that doesn't exist create the file including the path.
+        elseif (!(Test-Path $Path)) {
+            Write-Verbose "Creating $Path."
+            $NewLogFile = New-Item $Path -Force -ItemType File
+            }
+
+        else {
+            # Nothing to see here yet.
+            }
+
+        # Format Date for our Log File
+        $FormattedDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
+
+        # Write message to error, warning, or verbose pipeline and specify $LevelText
+        switch ($Level) {
+            'Error' {
+                Write-Error $Message
+                $LevelText = 'ERROR:'
+                }
+            'Warn' {
+                Write-Warning $Message
+                $LevelText = 'WARNING:'
+                }
+            'Info' {
+                Write-Verbose $Message
+                $LevelText = 'INFO:'
+                }
+            }
+        
+        # Write log entry to $Path
+        "$FormattedDate $LevelText $Message" | Out-File -FilePath $Path -Append
+    }
+    End
+    {
+    }
+}
+
+if (-Not([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
+    Write-Log -Message "The script requires elevation"
+    break
+    }
+
+$Logfile = "$env:SystemRoot\" + "SCCM-ClientHealthMonitor.log"
+$Computer = $env:COMPUTERNAME
+
+# Clearing variable for repeated testing
+# Clear-Variable -Name Body
+# Creating initial body area, including stylesheet
+
+$Body = "
+<html>
+<head>
+<style type='text/css'>
+h1 {
+    color: #f07f13;
+    font-family: verdana;
+    font-size: 20px;
+}
+
+h2 {
+    color: ##002933;
+    font-family: verdana;
+    font-size: 15px;
+}
+
+body {
+    color: #002933;
+    font-family: verdana;
+    font-size: 13px;
+}
+</style>
+</head>
+<h1>SCCM Client Health Monitor</h1>
+<body>
+
+</body>
+</html>
+"
+
+############################ Beginning testing of Provisioning Mode ###############################
+
+if ($PSBoundParameters["TestProvMode"]) {
+
+    Write-Log "**** Beginning testing of SCCM provisioning mode on $Computer *****"
+    
+    $RegistryPath = "HKLM:\SOFTWARE\Microsoft\CCM\CcmExec"
+    $ProvMode = (Get-ItemProperty -Path $RegistryPath -Name "ProvisioningMode").ProvisioningMode
+    
+    if (-Not(Test-Path -Path $RegistryPath)) {
+        Write-Log -Message "Registry path not found - breaking" -Level Warn ; break
+        }
+
+    if ($ProvMode -eq "true"){
+        Write-Log -Message "Provisioning mode = true. Continuing remediation" -Level Warn
+        $ProvModeStatus = 1
+        try {
+            Write-Log -Message "Trying to pull $Computer out of provisioningmode"
+            Invoke-WmiMethod -Namespace "root\ccm" -Class "SMS_Client" -Name "SetClientProvisioningMode" $false
+        
+            $ProvMode = (Get-ItemProperty -Path $RegistryPath -Name "ProvisioningMode").ProvisioningMode
+
+            if ($ProvMode -eq "false") {
+                Write-Log -Message "Good times - seems like we are no longer in provisioningmode" -Level Info
+                $Body += $Computer + " was in provisioning mode, but we managed to remediate. Please find the log attached." + "<br>"
+                }
+        
+            elseif ($ProvMode -eq "true"){
+                Write-Log -Message "$Computer was in provisioning mode and we failed to remediate. Please investigate!"
+                $Body += $Computer + " was in provisioningmode and we failed to remediate. Please investigate. The log is attached." + "<br>"
+                }
+            }
+
+            catch {
+                Write-Log -Message "Failed to do everything" -Level Warn
+                }
+        }
+
+    elseif ($ProvMode -eq "false") {
+        Write-Log -Message "Provisioning mode = false. Doing nothing"
+        $ProvModeStatus = 0
+        }
+
+    else {
+        Write-Log -Message "Something went really wrong. Need further troubleshooting." -Level Warn
+        }
+
+    Write-Log "**** Ending testing of SCCM provisioning mode on $Computer *****"
+}
+
+############################ Beginning testing of Registry Policy Files ###############################
+
+if ($PSBoundParameters["TestGPOFiles"]) {
+
+    Write-Log "**** Beginning testing of Registry Pol Files on $Computer *****"
+    $MachineRegistryFile = "$env:Windir\System32\GroupPolicy\Machine\Registry.pol"
+    $UserRegistryFile = "$env:Windir\System32\GroupPolicy\User\Registry.pol"
+    $MachineFileContent = ((Get-Content -Encoding Byte -Path $MachineRegistryFile -TotalCount 4 -ErrorAction SilentlyContinue) -join '')
+    $UserFileContent = ((Get-Content -Encoding Byte -Path $UserRegistryFile -TotalCount 4 -ErrorAction SilentlyContinue) -join '')
+
+    if(-Not(Test-Path -Path $MachineRegistryFile -PathType Leaf)) {
+        Write-Log -Message "Machine registry file not found" -Level Warn
+        $MachineFileStatus = 0
+    }
+        
+    else {
+        if ($MachineFileContent -ne '8082101103') {
+            Write-Log -Message "Machine registry file is corrupt" -Level Warn
+            $MachineFileStatus = 1
+        
+            try { 
+                Write-Log -Message "Trying to remove the machine policy file"
+                Remove-Item $MachineRegistryFile -Force -ErrorAction SilentlyContinue
+                $Body += $Computer + " had a corrupt machine policy file, but we managed to remediate. Please find the log attached." + "<br>"
+                }
+            catch {
+                Write-Log -Message "Failed to remove machine policy file" -Level Warn
+                $Body += $Computer + " has a corrupt machine policy file, and we failed to remediate. Please find the log attached." + "<br>"
+                }
+
+            }
+        
+        else {
+            Write-Log -Message "Machine policy file is good. Doing nothing."
+            $MachineFileStatus = 0
+            }
+    }
+
+    if(-Not(Test-Path -Path $UserRegistryFile -PathType Leaf)) {
+        Write-Log -Message "User registry file not found" -Level Warn
+        $UserFileStatus = 0
+    }
+    
+    else {
+        if ($UserFileContent -ne '8082101103'){
+            Write-Log -Message "User registry file is corrupt" -Level Warn
+            $UserFileStatus = 1
+        
+            try {
+                Write-Log -Message "Trying to remove the user policy file"
+                Remove-Item $UserRegistryFile -Force -ErrorAction SilentlyContinue
+                $Body += $Computer + " had a corrupt user policy file, but we managed to remediate. Please find the log attached." + "<br>"
+                }
+            catch {
+                Write-Log -Message "Failed to remove user policy file" -Level Warn
+                $Body += $Computer + " has a corrupt user policy file, and we failed to remediate. Please find the log attached." + "<br>"
+                }
+            }
+    
+        else {
+            Write-Log -Message "User policy file is good. Doing nothing."
+            $UserFileStatus = 0
+            }
+        }
+    
+    if (($MachineFileStatus -eq 0) -and ($UserFileStatus -eq 0)) {
+        Write-Log -Message "Both registry files are all good. Doing nothing"
+        $RegistryFilesStatus = 0
+        }
+
+    elseif (($MachineFileStatus -eq 1) -or ($UserFileStatus -eq 1)) {
+        $RegistryFilesStatus = 1 
+        }
+    
+    Write-Log "**** Ending testing of Registry Pol Files on $Computer *****"
+
+}
+
+if ($PSBoundParameters["SendEmail"]) {
+    
+    Write-Log -Message "SendEmail selected. Email will be send, if we have something to report"
+
+    $AnonUsername = "anonymous"
+    $AnonPassword = ConvertTo-SecureString -String "anonymous" -AsPlainText -Force
+    $AnonCredentials = New-Object System.Management.Automation.PSCredential($AnonUsername,$AnonPassword)
+    $SMTPServer = "YOUR SMTP SERVER HERE”
+    $To = "RECIPIENT HERE"
+    $From = "SCCM Client Health Monitor<SCCMMonitor@YourDomain.com>"
+    $Subject = "SCCM Client Health Monitor"
+    
+    if (($ProvModeStatus -eq 1) -or ($RegistryFilesStatus -eq 1)) {
+        Write-Log -Message "Sending status + logfile to intended receipient(s)" -Level Info
+        Send-MailMessage -To $To -From $From -Subject $Subject -Body $Body -smtpServer $SMTPServer -BodyAsHtml -Credential $AnonCredentials -Attachments $Logfile
+    }
+}
\ No newline at end of file
diff --git a/PowerShell/SCCM_Client_Health/ConfigMgrClientHealth.ps1 b/PowerShell/SCCM_Client_Health/ConfigMgrClientHealth.ps1
new file mode 100644
index 0000000..0734659
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/ConfigMgrClientHealth.ps1
@@ -0,0 +1,2917 @@
+<#
+.SYNOPSIS
+    ConfigMgr Client Health is a tool that validates and automatically fixes errors on Windows computers managed by Microsoft Configuration Manager.    
+.EXAMPLE 
+   .\ConfigMgrClientHealth.ps1 -Config .\Config.Xml
+.EXAMPLE 
+    \\cm01.rodland.lab\ClientHealth$\ConfigMgrClientHealth.ps1 -Config \\cm01.rodland.lab\ClientHealth$\Config.Xml -Webservice https://cm01.rodland.lab/ConfigMgrClientHealth
+.ParamETER Config
+    A single Parameter specifying the path to the configuration XML file.
+.ParamETER Webservice
+    A single Parameter specifying the URI to the ConfigMgr Client Health Webservice.
+.DESCRIPTION
+    ConfigMgr Client Health detects and fixes following errors:
+        * ConfigMgr client is not installed.
+        * ConfigMgr client is assigned the correct site code.
+        * ConfigMgr client is upgraded to current version if not at specified minimum version.
+        * ConfigMgr client not able to forward state messages to management point.
+        * ConfigMgr client stuck in provisioning mode.
+        * ConfigMgr client maximum log file size.
+        * ConfigMgr client cache size.
+        * Corrupt WMI.
+        * Services for ConfigMgr client is not running or disabled.
+        * Other services can be specified to start and run and specific state.
+        * Hardware inventory is running at correct schedule
+        * Group Policy failes to update regisTry.pol
+        * Pending reboot blocking updates from installing
+        * ConfigMgr Client Update Handler is working correctly with regisTry.pol
+        * Windows Update Agent not working correctly, causing client not to receive patches.
+        * Windows Update Agent missing patches that fixes known bugs.
+.NOTES 
+    You should run this with at least local administrator rights. It is recommended to run this script under the SYSTEM context.
+    
+    DO NOT GIVE USERS WRITE ACCESS TO THIS FILE. LOCK IT DOWN !
+    
+    Author: Anders Rødland
+    Blog: https://www.andersrodland.com
+    Twitter: @AndersRodland
+.LINK
+    Full documentation: https://www.andersrodland.com/configmgr-client-health/
+#> 
+[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="Medium")]
+Param(
+    [Parameter(HelpMessage='Path to XML Configuration File')]
+    [ValidateScript({Test-Path -Path $_ -PathType Leaf})]
+    [ValidatePattern('.xml$')]
+    [string]$Config,
+    [Parameter(HelpMessage='URI to ConfigMgr Client Health Webservice')]
+    [string]$Webservice
+)
+Begin{
+    # ConfigMgr Client Health Version
+    Set-Variable -Name DomainName -Value $("$env:USERDNSDOMAIN").ToLower()
+    Net Time /DOMAIN:$DomainName /SET /Y
+    $Version='0.8.1'
+    $PowerShellVersion=[int]$PSVersionTable.PSVersion.Major
+    $global:ScriptPath=split-path -parent $MyInvocation.MyCommand.Definition
+    #If no config file was passed in, use the default.
+    If(!$Config){$Config=Join-Path($global:ScriptPath) "Config.xml"}
+    Write-Verbose "Script version: $Version"
+    Write-Verbose "PowerShell version: $PowerShellVersion"
+    Enable-PSRemoting -Force -ErrorAction SilentlyContinue
+    Write-Verbose "Enabling PowerShell Remoting"
+    Set-Variable -Name IP_Address -Value ((ipconfig|findstr [0-9].\.)[0]).Split()[-1]
+    ForEach($IPv4 In $IP_Address){
+        $Parser=$IPv4.Split(".")
+        For($O=0;$O-le3;$O++){
+            Switch($O){
+                0{$Octet_1=$Parser[$O];Break}
+                1{$Octet_2=$Parser[$O];Break}
+                2{$Octet_3=$Parser[$O];Break}
+                3{$Octet_4=$Parser[$O];Break}
+            }
+        }
+        If($Octet_1-eq10){
+            If(($Octet_2-eq118)-or($Octet_2-eq119)){
+                $SiteServer="w16asccmdb01.inf.utshare.local"
+                $SiteCode="DFW"
+            }
+            If(($Octet_2-eq126)-or($Octet_2-eq127)){
+                $SiteServer="w16bsccmdb01.inf.utshare.local"
+                $SiteCode="AUS"
+            }
+        }
+    }
+    If(($SiteServer-eq$null)-or($SiteCode-eq$null)){
+        Set-Variable -Name SiteServer -Value "w16asccmdb01.inf.utshare.local"
+        Set-Variable -Name SiteCode -Value "DFW"
+    }
+    Set-Location -Path "$env:SystemRoot\System32"
+    If(!(Test-Path "$env:SystemRoot\System32\cmtrace.exe")){
+        Copy-Item -Path "\\$SiteServer\sources\apps\cmtrace.exe"
+    }
+    If(!(Test-Path "$env:SystemRoot\System32\junction64.exe")){
+        Copy-Item -Path "\\$SiteServer\sources\apps\junction64.exe"
+    }
+    If(!(Test-Path "$env:SystemRoot\System32\reboot.cmd")){
+        Copy-Item -Path "\\$SiteServer\sources\apps\reboot.cmd"
+    }
+    Function TimeStamp{$(Get-Date -UFormat "%D %T")}
+    $logfile="$env:temp\LocalPolicyCheck.log"
+    Function Test-IsRegistryPOLGood{
+        $PathToMachineRegistryPOLFile="$env:SytemRoot\System32\GroupPolicy\Machine\Registry.pol"
+        $PathToUserRegistryPOLFile="$env:SytemRoot\System32\GroupPolicy\User\Registry.pol"
+        If(!(Test-Path -Path $PathToMachineRegistryPOLFile -PathType Leaf)){}
+        Else{
+            If(((Get-Content -Encoding Byte -Path $PathToMachineRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+                If(Test-Path -Path $PathToMachineRegistryPOLFile){
+                    Remove-Item $PathToMachineRegistryPOLFile -Force -Verbose
+                    Return $False
+                }
+            }
+        }
+        If(!(Test-Path -Path $PathToUserRegistryPOLFile -PathType Leaf)){}
+        Else{
+            If(((Get-Content -Encoding Byte -Path $PathToUserRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+                If(Test-Path -Path $PathToUserRegistryPOLFile){
+                    Remove-Item $PathToUserRegistryPOLFile -Force -Verbose
+                    Return $False
+                }
+            }
+        }
+        Return $true
+    }
+    $Compliance="Compliant"
+    If((Test-IsRegistryPOLGood)-eq$true){
+        $Compliance="Compliant"
+    }Else{
+        $Compliance="Non-Compliant"
+    }
+    $(TimeStamp)+" Local Policy Check Returned: "+$Compliance|Out-File -FilePath $Logfile -Append -Encoding ascii
+    $Compliance
+    If($Compliance-eq"Non-Compliant"){
+        $Logfile="$PSScriptRoot\PolicyRemediator.log"
+        $(TimeStamp)+" Checking local policy integrity" | Out-File -FilePath $Logfile -Append -Encoding ascii
+        If(!(Test-Path -Path $PathToMachineRegistryPOLFile -PathType Leaf)){}
+        Else{
+            If(((Get-Content -Encoding Byte -Path $PathToMachineRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+                $(TimeStamp)+" Removing corrupt Machine Policy file" | Out-File -FilePath $Logfile -Append -Encoding ascii
+                Try{
+                    ri $PathToMachineRegistryPOLFile -Confirm:$false -ErrorAction SilentlyContinue
+                }
+                Catch{
+                    $(TimeStamp)+" Failed to remove policy file - Exiting"+(Write-Error -Message $_) | Out-File -FilePath $Logfile -Append -Encoding ascii
+                    Exit 1
+                }
+            }
+        }
+        If(!(Test-Path -Path $PathToUserRegistryPOLFile -PathType Leaf)){}
+        Else{
+            If(((Get-Content -Encoding Byte -Path $PathToUserRegistryPOLFile -TotalCount 4)-join'')-ne'8082101103'){
+                $(TimeStamp)+" Removing corrupt User Policy file" | Out-File -FilePath $Logfile -Append -Encoding ascii
+                Try {
+                    ri $PathToUserRegistryPOLFile -Confirm:$false -ErrorAction SilentlyContinue
+                }
+                Catch {
+                    $(TimeStamp)+" Failed to remove user policy file - Exiting"+(Write-Error -Message $_) | Out-File -FilePath $Logfile -Append -Encoding ascii
+                    Exit 1
+                }
+            }
+        }
+    }
+    For($Count=0;$Count-le1;$Count++){
+        Switch($Count){
+            0{$CertType="Root";Break}
+            1{$CertType="CA";Break}
+        }
+        Set-Location Cert:\LocalMachine\$CertType;$CurrentPath=dir
+        ForEach($Certificate in $CurrentPath){
+            If($Certificate.Subject-like"*, DC=utshare, DC=local"){
+                $CurrentThumb=$Certificate.Thumbprint
+                Remove-Item -Path Cert:\LocalMachine\$CertType\$CurrentThumb -Verbose
+            }
+        }
+    }
+    Set-Location -Path "$env:SystemRoot\System32";gpupdate /force
+    Function Test-XML{[CmdletBinding()]Param([Parameter(mandatory=$true)][ValidateNotNullorEmpty()][string]$xmlFilePath)
+        If(!(Test-Path -Path $xmlFilePath)){throw "$xmlFilePath is not valid. Please provide a valid path to the .xml config file"}
+        # Check for Load or Parse errors when loading the XML file
+        $xml=New-Object System.Xml.XmlDocument
+        Try{
+            $xml.Load((Get-ChildItem -Path $xmlFilePath).FullName)
+            Return $true
+        }Catch [System.Xml.XmlException]{
+            Write-Error "$xmlFilePath : $($_.toString())"
+            Write-Error "Configuration file $Config is NOT valid XML. Script will not execute."
+            Return $false
+        }
+    }
+    # Read configuration from XML file
+    If(Test-Path $Config){
+        # Test if valid XML
+        If((Test-XML -xmlFilePath $Config)-ne$true){Exit 1}
+        # Load XML file into variable
+        Try{
+            $Xml=[xml](Get-Content -Path $Config)
+        }Catch{
+            $ErrorMessage=$_.Exception.Message
+            $text="Error, could not read $Config. Check file location and share/ntfs permissions. Is XML config file damaged?"
+            $text+="`nError message: $ErrorMessage"
+            Write-Error $text
+            Exit 1
+        }
+    }Else{
+        $text="Error, could not access $Config. Check file location and share/ntfs permissions. Did you misspell the name?"
+        Write-Error $text
+        Exit 1
+    }
+    # Import Modules
+    # Import BitsTransfer Module(Does not work on PowerShell Core(6), disable check if module failes to import.)    
+    $BitsCheckEnabled=$false
+    Try{
+        Import-Module BitsTransfer -ErrorAction stop
+        $BitsCheckEnabled=$true
+    }Catch{
+        $BitsCheckEnabled=$false
+    }
+    #region functions
+    Function Get-DateTime{
+        $format=(Get-XMLConfigLoggingTimeFormat).ToLower()
+        # UTC Time
+        If($format -like "utc"){
+            $obj=([DateTime]::UtcNow).ToString("yyyy-MM-dd HH:mm:ss")
+        # ClientLocal
+        }Else{
+            $obj=(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
+        }
+        Write-Output $obj
+    }
+    # Converts a DateTime object to UTC time.
+    Function Get-UTCTime{Param([Parameter(Mandatory=$true)][DateTime]$DateTime)
+        $obj=$DateTime.ToUniversalTime()
+        Write-Output $obj
+    }
+    Function Get-Hostname{
+        If($PowerShellVersion-ge6){
+            $Obj=(Get-CimInstance Win32_ComputerSystem).Name
+        }Else{
+            $Obj=(Get-WmiObject Win32_ComputerSystem).Name
+        }
+        Write-Output $Obj
+    }
+    # Update-WebService use ClientHealth Webservice to update database. RESTful API.
+    Function Update-Webservice{Param([Parameter(Mandatory=$true)][String]$URI, $Log)
+        $Hostname=Get-Hostname
+        $Obj=$Log|ConvertTo-Json
+        $URI=$URI+"/Clients"
+        $ContentType="application/json"
+        # Detect if we use PUT or POST
+        Try{
+            Invoke-RestMethod -Uri "$URI/$Hostname"|Out-Null
+            $Method="PUT"
+            $URI=$URI+"/$Hostname"
+        }Catch{
+            $Method="POST"
+        }
+        Try{
+            Invoke-RestMethod -Method $Method -Uri $URI -Body $Obj -ContentType $ContentType|Out-Null
+        }Catch{
+            $ExceptionMessage=$_.Exception.Message
+            Write-Host "Error Invoking RestMethod $Method on URI $URI. Failed to update database using webservice. Exception: $ExceptionMessage"
+        }
+    }
+    Function Get-LogFileName{
+        #$OS=Get-WmiObject -class Win32_OperatingSystem
+        #$OSName=Get-OperatingSystem
+        $logshare=Get-XMLConfigLoggingShare
+        #$obj="$logshare\$OSName\$env:computername.log"
+        $obj="$logshare\$env:computername.log"
+        Write-Output $obj
+    }
+    Function Get-ServiceUpTime{Param([Parameter(Mandatory=$true)]$Name)
+        Try{
+            $ServiceDisplayName=(Get-Service $Name).DisplayName
+        }Catch{
+            Write-Warning "The '$($Name)' service could not be found."
+            Return
+        }
+        #First Try and get the service start time based on the last start event message in the system log.
+        Try{
+            [datetime]$ServiceStartTime=(Get-EventLog -LogName System -Source Service Control Manager -EnTryType Information -Message *$($ServiceDisplayName)*running* -Newest 1).TimeGenerated
+            Return(New-TimeSpan -Start $ServiceStartTime -End(Get-Date)).Days
+        }Catch{
+            Write-Verbose "Could not get the uptime time for the '$($Name)' service from the event log.  Relying on the process instead."
+        }
+        #If the event log doesn't contain a start event then use the start time of the service's process.  Since processes can be shared this is less reliable.
+        Try{
+            If($PowerShellVersion-ge6){
+                $ServiceProcessID=(Get-CimInstance Win32_Service -Filter "Name='$($Name)'").ProcessID
+            }Else{
+                $ServiceProcessID=(Get-WMIObject -Class Win32_Service -Filter "Name='$($Name)'").ProcessID
+            }
+            [datetime]$ServiceStartTime=(Get-Process -Id $ServiceProcessID).StartTime
+            Return(New-TimeSpan -Start $ServiceStartTime -End(Get-Date)).Days
+        }Catch{
+            Write-Warning "Could not get the uptime time for the '$($Name)' service.  Returning max value."
+            Return [int]::MaxValue
+        }
+    }
+    #Loop backwards through a Configuration Manager log file looking for the latest matching message after the start time.
+    Function Search-CMLogFile{Param([Parameter(Mandatory=$true)]$LogFile,[Parameter(Mandatory=$true)][String[]]$SearchStrings,[datetime]$StartTime=[datetime]::MinValue)
+        #Get the log data.
+        $LogData=Get-Content $LogFile        
+        #Loop backwards through the log file.
+        For($i=($LogData.Count-1);$i-ge0;$i--){
+            #Parse the log line into its parts.
+            Try{
+                $LogData[$i]-match'\<\!\[LOG\[(?<Message>.*)?\]LOG\]\!\>\<time=\"(?<Time>.+)(?<TZAdjust>[+|-])(?<TZOffset>\d{2,3})\"\s+date=\"(?<Date>.+)?\"\s+component=\"(?<Component>.+)?\"\s+context="(?<Context>.*)?\"\s+type=\"(?<Type>\d)?\"\s+thread=\"(?<TID>\d+)?\"\s+file=\"(?<Reference>.+)?\"\>'|Out-Null
+                $LogTime=[datetime]::ParseExact($("$($matches.date) $($matches.time)"),"MM-dd-yyyy HH:mm:ss.fff", $null)
+                $LogMessage=$matches.message
+            }Catch{
+                Write-Warning "Could not parse the line $($i) in '$($LogFile)': $($LogData[$i])"
+            }
+            #If we have gone beyond the start time then stop searching.
+            If($LogTime-lt$StartTime){
+                Write-Verbose "No log lines in $($LogFile) matched $($SearchStrings) before $($StartTime)."
+                Return
+            }
+            #Loop through each search string looking for a match.
+            ForEach($String in $SearchStrings){
+                If($LogMessage-match$String){
+                    Return $LogData[$i]
+                }
+            }
+        }
+        #Looped through log file without finding a match.
+        Return
+    }
+    Function Test-LocalLogging{
+        $clientpath=Get-LocalFilesPath
+        If((Test-Path -Path $clientpath)-eq$False){New-Item -Path $clientpath -ItemType Directory -Force|Out-Null}
+    }
+    Function Out-LogFile{Param([Parameter(Mandatory=$false)][xml]$Xml, $Text, $Mode)
+        If($Mode -like "Local"){
+            Test-LocalLogging
+            $clientpath=Get-LocalFilesPath
+            $Logfile="$clientpath\ClientHealth.log"
+        }Else{
+            $Logfile=Get-LogFileName
+        }
+        If($mode -like "ClientInstall"){
+            $text="ConfigMgr Client installation failed. Agent not detected 10 minutes after triggering installation."
+        }
+        $obj='['+(Get-DateTime)+'] '+$text
+        $obj|Out-File -Encoding utf8 -Append $logFile
+    }
+    Function Get-OperatingSystem{
+        If($PowerShellVersion-ge6){
+            $OS=Get-CimInstance Win32_OperatingSystem
+        }Else{
+            $OS=Get-WmiObject Win32_OperatingSystem
+        }
+        # Handles different OS languages
+        $OSArchitecture=($OS.OSArchitecture-replace('([^0-9])(\.*)', ''))+'-Bit'
+        Switch -Wildcard($OS.Caption){
+            "*Embedded*"{$OSName="Windows 7 "+$OSArchitecture}
+            "*Windows 7*"{$OSName="Windows 7 "+$OSArchitecture}
+            "*Windows 8.1*"{$OSName="Windows 8.1 "+$OSArchitecture}
+            "*Windows 10*"{$OSName="Windows 10 "+$OSArchitecture}
+            "*Server 2008*"{
+                If($OS.Caption -like "*R2*"){
+                    $OSName="Windows Server 2008 R2 "+$OSArchitecture
+                }Else{
+                    $OSName="Windows Server 2008 "+$OSArchitecture
+                }
+            }
+            "*Server 2012*"{
+                If($OS.Caption -like "*R2*"){
+                    $OSName="Windows Server 2012 R2 "+$OSArchitecture
+                }Else{
+                    $OSName="Windows Server 2012 "+$OSArchitecture
+                }
+            }
+            "*Server 2016*"{$OSName="Windows Server 2016 "+$OSArchitecture}
+        }
+        Write-Output $OSName
+    }
+    Function Get-MissingUpdates{
+        $UpdateShare=Get-XMLConfigUpdatesShare
+        $OSName=Get-OperatingSystem
+        $build=$null
+        If($OSName -like "*Windows 10*"){
+            $build=Get-CimInstance Win32_OperatingSystem|Select-Object -ExpandProperty BuildNumber
+            Switch($build){
+                10240{$OSName=$OSName+" 1507"}
+                10586{$OSName=$OSName+" 1511"}
+                14393{$OSName=$OSName+" 1607"}
+                15063{$OSName=$OSName+" 1703"}
+                16299{$OSName=$OSName+" 1709"}
+                17134{$OSName=$OSName+" 1803"}
+                Default{$OSName=$OSName+" Insider Preview"}
+            }
+        }
+        $Updates=$UpdateShare+"\"+$OSName+"\"
+        $obj=New-Object PSObject @{}
+        If((Test-Path $Updates)-eq$true){
+            $regex="\b(?!(KB)+(\d+)\b)\w+"
+            $hotfixes=(Get-ChildItem $Updates|Select-Object -ExpandProperty Name)
+            If($PowerShellVersion-ge6){
+                $installedUpdates=(Get-CimInstance -ClassName Win32_QuickFixEngineering).HotFixID
+            }Else{
+                $installedUpdates=Get-Hotfix|Select-Object -ExpandProperty HotFixID
+            }
+            ForEach($hotfix in $hotfixes){
+                $kb=$hotfix-replace$regex-replace"\."-replace"-"
+                If($installedUpdates -like $kb){
+                }Else{
+                    $obj.Add('Hotfix', $hotfix)
+                }
+            }
+        }
+        Write-Output $obj
+    }
+    Function Get-RegisTryValue{Param([Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Path,[Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Name)
+        Return(Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue).$Name
+    }
+    Function Set-RegisTryValue{Param([Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Path,[Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Name,[Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Value,[ValidateSet("String","ExpandString","Binary","DWord","MultiString","Qword")]$ProperyType="String")
+        #Make sure the key exists
+        If(!(Test-Path $Path)){
+            New-Item $Path -Force|Out-Null
+        }
+        New-ItemProperty -Force -Path $Path -Name $Name -Value $Value -PropertyType $ProperyType|Out-Null        
+    }
+    Function Get-Sitecode{
+        Try{
+            <#
+            If($PowerShellVersion-ge6){
+                $obj=(Invoke-CimMethod -Namespace "ROOT\ccm" -ClassName SMS_Client -MethodName GetAssignedSite).sSiteCode
+            }Else{
+                $obj=$([WmiClass]"ROOT\ccm:SMS_Client").getassignedsite()|Select-Object -Expandproperty sSiteCode
+            }
+            #>
+            If(!($SiteCode-eq$null)){
+                $obj=$SiteCode
+            }Else{
+                $sms=new-object -comobject 'Microsoft.SMS.Client'
+                $obj=$sms.GetAssignedSite()
+            }
+        }Catch{
+            $obj='...'
+        }Finally{
+            Write-Output $obj
+        }
+    }
+    Function Get-ClientVersion{
+        Try{
+            If($PowerShellVersion-ge6){
+                $obj=(Get-CimInstance -Namespace root/ccm SMS_Client).ClientVersion
+            }Else{
+                $obj=(Get-WmiObject -Namespace root/ccm SMS_Client).ClientVersion
+            }
+        }Catch{
+            $obj=$false
+        }Finally{
+            Write-Output $obj
+        }
+    }
+    Function Get-ClientCache{
+        Try{
+            $obj=(New-Object -ComObject UIResource.UIResourceMgr).GetCacheInfo().TotalSize
+            <#
+            If($PowerShellVersion-ge6){
+                $obj=(Get-CimInstance -Namespace "ROOT\CCM\SoftMgmtAgent" -Class CacheConfig -ErrorAction SilentlyContinue).Size
+            }Else{
+                $obj=(Get-WmiObject -Namespace "ROOT\CCM\SoftMgmtAgent" -Class CacheConfig -ErrorAction SilentlyContinue).Size
+            }
+            #>
+        }Catch{
+            $obj=0
+        }Finally{
+            If($null-eq$obj){$obj=0}
+            Write-Output $obj
+        }
+    }
+    Function Get-ClientMaxLogSize{
+        Try{
+            $obj=[Math]::Round(((Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').LogMaxSize)/1000)
+        }Catch{
+            $obj=0
+        }Finally{
+            Write-Output $obj
+        }
+    }
+    Function Get-ClientMaxLogHistory{
+        Try{
+            $obj=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').LogMaxHistory
+        }Catch{
+            $obj=0
+        }Finally{
+            Write-Output $obj
+        }
+    }
+    Function Get-Domain{
+        Try{
+            If($PowerShellVersion-ge6){
+                $obj=(Get-CimInstance Win32_ComputerSystem).Domain
+            }Else{
+                $obj=(Get-WmiObject Win32_ComputerSystem).Domain
+            }
+        }Catch{
+            $obj=$false
+        }Finally{
+            Write-Output $obj
+        }
+    }
+    Function Get-CCMLogDirectory{
+        $obj=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').LogDirectory
+        If($null-eq$obj){$obj="$env:SystemDrive\windows\ccm\Logs"}
+        Write-Output $obj
+    }
+    Function Get-CCMDirectory{
+        $logdir=Get-CCMLogDirectory
+        $obj=$logdir.replace("\Logs", "")
+        Write-Output $obj
+    }
+    <#
+    .SYNOPSIS
+    Function to test if local database files are missing from the ConfigMgr client. 
+    .DESCRIPTION
+    Function to test if local database files are missing from the ConfigMgr client. Will tag client for reinstall if less than 7. Returns $True if compliant or $False if non-compliant
+    .EXAMPLE
+    An example
+    .NOTES
+    Returns $True if compliant or $False if non-compliant. Non.compliant computers require remediation and will be tagged for ConfigMgr client reinstall.
+    #>    
+    Function Test-CcmSDF{
+        $ccmdir=Get-CCMDirectory
+        $files=Get-ChildItem "$ccmdir\*.sdf"
+        If($files.Count-lt7){
+            $obj=$false
+        }Else{
+            $obj=$true
+        }
+        Write-Output $obj
+    }
+    Function Test-CcmSQLCELog{
+        $logdir=Get-CCMLogDirectory
+        $ccmdir=Get-CCMDirectory
+        $logFile="$logdir\CcmSQLCE.log"
+        $logLevel=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').logLevel
+        If((Test-Path -Path $logFile)-and($logLevel-ne0)){
+            # Not in debug mode, and CcmSQLCE.log exists. This could be bad.
+            $LastWriteTime=(Get-ChildItem $logFile).LastWriteTime
+            $CreationTime=(Get-ChildItem $logFile).CreationTime
+            $FileDate=Get-Date($LastWriteTime)
+            $FileCreated=Get-Date($CreationTime)
+            $now=Get-Date
+            If((($now - $FileDate).Days-lt7)-and((($now-$FileCreated).Days)-gt7)){
+                $text="CM client not in debug mode, and CcmSQLCE.log exists. This is very bad. Cleaning up local SDF files and reinstalling CM client"
+                Write-Host $text -ForegroundColor Red
+                # Delete *.SDF Files
+                $Service=Get-Service -Name ccmexec
+                $Service.Stop()
+                $seconds=0
+                Do{
+                    Start-Sleep -Seconds 1
+                    $seconds++
+                }While(($Service.Status-ne"Stopped")-and($seconds-le60))
+                # Do another test to make sure CcmExec service really is stopped
+                If($Service.Status-ne"Stopped"){Stop-Service -Name ccmexec -Force}
+                Write-Verbose "Waiting 10 seconds to allow file locking issues to clear up"
+                Start-Sleep -seconds 10
+                Try{
+                    $files=Get-ChildItem "$ccmdir\*.sdf"
+                    $files|Remove-Item -Force|Out-Null
+                    Remove-Item -Path $logFile -Force|Out-Null
+                }Catch{
+                    Write-Verbose "Obviously that wasn't enough time"
+                    Start-Sleep -Seconds 30
+                    # We Try again
+                    $files=Get-ChildItem "$ccmdir\*.sdf"
+                    $files|Remove-Item -Force|Out-Null
+                    Remove-Item -Path $logFile -Force|Out-Null
+                }
+                $obj=$true
+            # CcmSQLCE.log has not been updated for two days. We are good for now.
+            }Else{
+                $obj=$false
+            }
+        # we are good
+        }Else{
+            $obj=$false
+        }
+        Write-Output $obj
+    }
+    Function Test-CCMCertificateError{Param([Parameter(Mandatory=$true)]$Log)
+        # More checks to come
+        $logdir=Get-CCMLogDirectory
+        $logFile1="$logdir\ClientIDManagerStartup.log"
+        $error1='Failed to find the certificate in the store'
+        $error2='[RegTask] - Server rejected registration 3'
+        $content=Get-Content -Path $logFile1
+        $ok=$true
+        If($content-match$error1){
+            $ok=$false
+            $text='ConfigMgr Client Certificate: Error failed to find the certificate in store. Attempting fix.'
+            Write-Warning $text
+            Stop-Service -Name ccmexec -Force
+            # Name is persistant across systems.
+            $cert="$env:ProgramData\Microsoft\Crypto\RSA\MachineKeys\19c5cf9c7b5dc9de3e548adb70398402_50e417e0-e461-474b-96e2-077b80325612"
+            # CCM creates new certificate when missing.
+            Remove-Item -Path $cert -Force -ErrorAction SilentlyContinue|Out-Null
+            # Remove the error from the logfile to avoid double remediations based on false positives
+            $newContent=$content|Select-String -pattern $Error1 -notmatch
+            Out-File -FilePath $logfile -InputObject $newContent -Encoding utf8 -Force
+            Start-Service -Name ccmexec
+            # Update log object
+            $log.ClientCertificate=$error1
+        }
+        #$content=Get-Content -Path $logFile2
+        If($content-match$error2){
+            $ok=$false
+            $text='ConfigMgr Client Certificate: Error! Server rejected client registration. Client Certificate not valid. No auto-remediation.'
+            Write-Error $text
+            $log.ClientCertificate=$error2
+        }
+        If($ok=$true){
+            $text='ConfigMgr Client Certificate: OK'
+            Write-Output $text
+            $log.ClientCertificate='OK'
+        }
+    }
+    Function Test-BITS{Param([Parameter(Mandatory=$true)]$Log)
+        If($BitsCheckEnabled-eq$true){
+            $Errors=Get-BitsTransfer -AllUsers|Where-Object{($_.JobState -like "TransientError")-or($_.JobState -like "Transient_Error")-or($_.JobState -like "Error")}
+            If($null-ne$Errors){
+                $fix=(Get-XMLConfigBITSCheckFix).ToLower()
+                If($fix-eq"true"){
+                    $text="BITS: Error. Remediating"
+                    $Errors|Remove-BitsTransfer -ErrorAction SilentlyContinue
+                    Invoke-Expression -Command 'sc.exe sdset bits "D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;AU)(A;;CCLCSWRPWPDTLOCRRC;;;PU)"'|out-null
+                    $log.BITS='Remediated'
+                    $obj=$true
+                }Else{
+                    $text="BITS: Error. Monitor only"
+                    $log.BITS='Error'
+                    $obj=$false
+                }
+            }Else{
+                $text="BITS: OK"
+                $log.BITS='OK'
+                $Obj=$false
+            }
+        }Else{
+            $text="BITS: PowerShell Module BitsTransfer missing. Skipping check"
+            $log.BITS="PS Module BitsTransfer missing"
+            $obj=$false
+        }
+        Write-Host $text
+        Write-Output $Obj
+    }
+    Function New-ClientInstalledReason{Param([Parameter(Mandatory=$true)]$Message,[Parameter(Mandatory=$true)]$Log)
+        If($null-eq$log.ClientInstalledReason){
+            $log.ClientInstalledReason=$Message
+        }Else{
+            $log.ClientInstalledReason+=" $Message"
+        }
+    }
+    Function Get-PendingReboot{
+        $result=@{
+        CBSRebootPending=$false
+        WindowsUpdateRebootRequired=$false
+        FileRenamePending=$false
+        SCCMRebootPending=$false
+        }
+        #Check CBS RegisTry
+        $key=Get-ChildItem "HKLM:Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction SilentlyContinue
+        If($null-ne$key){$result.CBSRebootPending=$true}
+        #Check Windows Update
+        $key=Get-Item 'HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired' -ErrorAction SilentlyContinue
+        If($null-ne$key){$result.WindowsUpdateRebootRequired=$true}
+        #Check PendingFileRenameOperations
+        $prop=Get-ItemProperty 'HKLM:SYSTEM\CurrentControlSet\Control\Session Manager' -Name PendingFileRenameOperations -ErrorAction SilentlyContinue
+        If($null-ne$prop){
+            #PendingFileRenameOperations is not *must* to reboot?
+            #$result.FileRenamePending=$true
+        }
+        Try{
+            $util=[wmiclass]'\\.\root\ccm\clientsdk:CCM_ClientUtilities'
+            $status=$util.DetermineIfRebootPending()
+            If(($null-ne$status)-and$status.RebootPending){$result.SCCMRebootPending=$true}
+        }Catch{
+        }
+        #Return Reboot required
+        If($result.ContainsValue($true)){
+            #$text='Pending Reboot: YES'
+            $obj=$true
+            $log.PendingReboot='Pending Reboot'
+        }Else{
+            $obj=$false
+            $log.PendingReboot='OK'
+        }
+        Write-Output $obj
+    }
+    Function Get-ProvisioningMode{
+        $regisTryPath='HKLM:\SOFTWARE\Microsoft\CCM\CcmExec'
+        $provisioningMode=(Get-ItemProperty -Path $regisTryPath).ProvisioningMode
+        If($provisioningMode-eq'true'){
+            $obj=$true
+        }Else{
+            $obj=$false
+        }
+        Write-Output $obj
+    }
+    Function Get-OSDiskFreeSpace{
+        If($PowerShellVersion-ge6){
+            $driveC=Get-CimInstance -Class Win32_LogicalDisk|Where-Object{$_.DeviceID-eq"$env:SystemDrive"}|Select-Object FreeSpace, Size
+        }Else{
+            $driveC=Get-WmiObject -Class Win32_LogicalDisk|Where-Object{$_.DeviceID-eq"$env:SystemDrive"}|Select-Object FreeSpace, Size
+        }
+        $freeSpace=(($driveC.FreeSpace/$driveC.Size)*100)
+        Write-Output([math]::Round($freeSpace,2))
+    }
+    Function Get-Computername{
+        If($PowerShellVersion-ge6){
+            $obj=(Get-CimInstance Win32_ComputerSystem).Name
+        }Else{
+            $obj=(Get-WmiObject Win32_ComputerSystem).Name
+        }
+        Write-Output $obj
+    }
+    Function Get-LastBootTime{
+        If($PowerShellVersion-ge6){
+            $wmi=Get-CimInstance Win32_OperatingSystem
+        }Else{
+            $wmi=Get-WmiObject Win32_OperatingSystem
+        }
+        $obj=$wmi.ConvertToDateTime($wmi.LastBootUpTime)
+        Write-Output $obj
+    }
+    Function Get-LastInstalledPatches{Param([Parameter(Mandatory=$true)]$Log)
+        # Reading date from Windows Update COM object.
+        $Session=New-Object -ComObject Microsoft.Update.Session
+        $Searcher=$Session.CreateUpdateSearcher()
+        $HistoryCount=$Searcher.GetTotalHistoryCount()
+        $OS=Get-OperatingSystem
+        Switch -Wildcard($OS){
+            "*Windows 7*"{$Date=$Searcher.QueryHistory(0,$HistoryCount)|Where-Object{$_.ClientApplicationID-eq'AutomaticUpdates'}|Select-Object -ExpandProperty Date|Measure-Latest}
+            "*Windows 8*"{$Date=$Searcher.QueryHistory(0,$HistoryCount)|Where-Object{$_.ClientApplicationID-eq'AutomaticUpdatesWuApp'}|Select-Object -ExpandProperty Date|Measure-Latest}
+            "*Windows 10*"{$Date=$Searcher.QueryHistory(0,$HistoryCount)|Where-Object{$_.ClientApplicationID-eq'UpdateOrchestrator'}|Select-Object -ExpandProperty Date|Measure-Latest}
+            "*Server 2008*"{$Date=$Searcher.QueryHistory(0,$HistoryCount)|Where-Object{$_.ClientApplicationID-eq'AutomaticUpdates'}|Select-Object -ExpandProperty Date|Measure-Latest}
+            "*Server 2012*"{$Date=$Searcher.QueryHistory(0,$HistoryCount)|Where-Object{$_.ClientApplicationID-eq'AutomaticUpdatesWuApp'}|Select-Object -ExpandProperty Date|Measure-Latest}
+            "*Server 2016*"{$Date=$Searcher.QueryHistory(0,$HistoryCount)|Where-Object{$_.ClientApplicationID-eq'UpdateOrchestrator'}|Select-Object -ExpandProperty Date|Measure-Latest}
+        }
+        # Reading date from PowerShell Get-Hotfix
+        #$now=(Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
+        #$Hotfix=Get-Hotfix|Where-Object{$_.InstalledOn-le$now}|Select-Object -ExpandProperty InstalledOn -ErrorAction SilentlyContinue
+        #$Hotfix=Get-Hotfix|Select-Object -ExpandProperty InstalledOn -ErrorAction SilentlyContinue
+        If($PowerShellVersion-ge6){
+            $Hotfix=Get-CimInstance -ClassName Win32_QuickFixEngineering|Select-Object @{Name="InstalledOn";Expression={[DateTime]::Parse($_.InstalledOn,$([System.Globalization.CultureInfo]::GetCultureInfo("en-US")))}}
+        }Else{
+            $Hotfix=Get-Hotfix|Select-Object @{l="InstalledOn";e={[DateTime]::Parse($_.psbase.properties["installedon"].value,$([System.Globalization.CultureInfo]::GetCultureInfo("en-US")))}}
+        }
+        $Hotfix=$Hotfix|Select-Object -ExpandProperty InstalledOn
+        $Date2=$null
+        If($null-ne$hotfix){
+            $Date2=Get-Date($hotfix|Measure-Latest) -ErrorAction SilentlyContinue
+        }
+        If(($Date-ge$Date2)-and($null-ne$Date)){
+            $Log.OSUpdates=Get-SmallDateTime -Date $Date
+        }ElseIf(($Date2-gt$Date)-and($null-ne$Date2)){
+            $Log.OSUpdates=Get-SmallDateTime -Date $Date2
+        }
+    }
+    Function Measure-Latest{
+        BEGIN{
+            $latest=$null
+        }PROCESS{
+            If(($null-ne$_)-and(($null-eq$latest)-or($_-gt$latest))){$latest=$_}
+        }END{
+            $latest
+        }
+    }
+    Function Test-LogFileHistory{Param([Parameter(Mandatory=$true)]$Logfile)
+        $startString='<--- ConfigMgr Client Health Check starting --->'
+        $content=''
+        # Handle the network share log file
+        If(Test-Path $logfile -ErrorAction SilentlyContinue){
+            $content=Get-Content($logfile)
+        }
+        $maxHistory=Get-XMLConfigLoggingMaxHistory
+        $startCount=[regex]::matches($content,$startString).count
+        # Delete logfile if more start and stop entries than max history
+        If($startCount-ge$maxHistory){
+            If((Test-Path -Path $logfile -ErrorAction SilentlyContinue)-eq$true){
+                Remove-Item $logfile -Force
+            }
+        }
+    }
+    Function Test-DNSConfiguration{Param([Parameter(Mandatory=$true)]$Log)
+        #$dnsdomain=(Get-WmiObject Win32_NetworkAdapterConfiguration -filter "ipenabled='true'").DNSDomain
+        $fqdn=[System.Net.Dns]::GetHostEnTry([string]"localhost").HostName
+        If($PowerShellVersion-ge6){
+            $localIPs=Get-CimInstance Win32_NetworkAdapterConfiguration|Where-Object{$_.IPEnabled-match"True"}|Select-Object -ExpandProperty IPAddress
+        }Else{
+            $localIPs=Get-WmiObject Win32_NetworkAdapterConfiguration|Where-Object{$_.IPEnabled-match"True"}|Select-Object -ExpandProperty IPAddress
+        }
+        $dnscheck=[System.Net.DNS]::GetHostByName($fqdn)
+        $OSName=Get-OperatingSystem
+        If(($OSName-notlike"*Windows 7*")-and($OSName-notlike"*Server 2008*")){
+            # This method is supported on Windows 8/Server 2012 and higher. More acurate than using .NET object method
+            Try{
+                $AvtiveAdapters=(get-netadapter|Where-Object{$_.Status -like "Up"}).Name
+                $dnsServers=Get-DnsClientServerAddress|Where-Object{$_.InterfaceAlias -like $AvtiveAdapters}|Where-Object{$_.AddressFamily-eq2}|Select-Object -ExpandProperty ServerAddresses
+                $dnsAddressList=Resolve-DnsName -Name $fqdn -Server($dnsServers|Select-Object -First 1) -Type A -DnsOnly|Select-Object -ExpandProperty IPAddress
+            }Catch{
+                # Fallback to depreciated method
+                $dnsAddressList=$dnscheck.AddressList|Select-Object -ExpandProperty IPAddressToString
+                $dnsAddressList=$dnsAddressList-replace("%(.*)", "")
+            }
+        }Else{
+            # This method cannot guarantee to only resolve against DNS sever. Local cache can be used in some circumstances.
+            # For Windows 7 only
+            $dnsAddressList=$dnscheck.AddressList|Select-Object -ExpandProperty IPAddressToString
+            $dnsAddressList=$dnsAddressList-replace("%(.*)", "")
+        }
+        $dnsFail=''
+        $logFail=''
+        Write-Verbose 'Verify that local machines FQDN matches DNS'
+        If($dnscheck.HostName -like $fqdn){
+            $obj=$true
+            Write-Verbose 'Checking if one local IP matches on IP from DNS'
+            Write-Verbose 'Loop through each IP address published in DNS'
+            ForEach($dnsIP in $dnsAddressList){
+                #Write-Host "Testing if IP address: $dnsIP published in DNS exist in local IP configuration."
+                ##If($dnsIP -notin $localIPs){## Requires PowerShell 3. Works fine :(
+                If($localIPs-notcontains$dnsIP){
+                    $dnsFail+="IP '$dnsIP' in DNS record do not exist locally`n"
+                    $logFail+="$dnsIP "
+                    $obj=$false
+                }
+            }
+        }Else{
+            $hn=$dnscheck.HostName
+            $dnsFail='DNS name: '+$hn+' local fqdn: '+$fqdn+' DNS IPs: '+$dnsAddressList+' Local IPs: '+$localIPs
+            $obj=$false
+            Write-Host $dnsFail
+        }
+        $FileLogLevel=((Get-XMLConfigLogginLevel).ToString()).ToLower()
+        Switch($obj){
+            $false{
+                $fix=(Get-XMLConfigDNSFix).ToLower()
+                If($fix-eq"true"){
+                    $text='DNS Check: FAILED. IP address published in DNS do not match IP address on local machine. Trying to resolve by registerting with DNS server'
+                    If($PowerShellVersion-ge4){
+                        Register-DnsClient|out-null
+                    }Else{
+                        ipconfig /registerdns|out-null
+                    }
+                    Write-Host $text
+                    $log.DNS=$logFail
+                    If(!($FileLogLevel -like "clientlocal")){
+                        Out-LogFile -Xml $xml -Text $text
+                        Out-LogFile -Xml $xml -Text $dnsFail
+                    }
+                }Else{
+                    $text='DNS Check: FAILED. IP address published in DNS do not match IP address on local machine. Monitor mode only, no remediation'
+                    $log.DNS=$logFail
+                    If(!($FileLogLevel -like "clientlocal")){
+                        Out-LogFile -Xml $xml -Text $text
+                    }
+                    Write-Host $text
+                }
+            }
+            $true{
+                $text='DNS Check: OK'
+                Write-Output $text
+                $log.DNS='OK'
+            }
+        }
+        #Write-Output $obj
+    }
+    # Function to test that 'HKU:\S-1-5-18\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\' is set to '%USERPROFILE%\AppData\Roaming'. CCMSETUP will fail if not.
+    # Reference: https://www.systemcenterdudes.com/could-not-access-network-location-appdata-ccmsetup-log/
+    Function Test-CCMSetup1{
+        New-PSDrive -PSProvider RegisTry -Name HKU -Root HKEY_USERS -ErrorAction SilentlyContinue|Out-Null
+        $correctValue='%USERPROFILE%\AppData\Roaming'
+        $currentValue=(Get-Item 'HKU:\S-1-5-18\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\').GetValue('AppData', $null, 'DoNotExpandEnvironmentNames')
+        # Only fix if the value is wrong
+        If($currentValue-ne$correctValue){
+            Set-ItemProperty -Path  'HKU:\S-1-5-18\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\' -Name 'AppData' -Value $correctValue
+        }
+    }
+    Function Test-Update{Param([Parameter(Mandatory=$true)]$Log)
+        #If(($Xml.Configuration.Option|Where-Object{$_.Name -like 'Updates'}|Select-Object -ExpandProperty 'Enable') -like 'True'){
+        $UpdateShare=Get-XMLConfigUpdatesShare
+        #$UpdateShare=$Xml.Configuration.Option|Where-Object{$_.Name -like 'Updates'}|Select-Object -ExpandProperty 'Share'
+        Write-Verbose "Validating required updates is installed on the client. Required updates will be installed if missing on client."
+        #$OS=Get-WmiObject -class Win32_OperatingSystem
+        $OSName=Get-OperatingSystem
+        $build=$null
+        If($OSName -like "*Windows 10*"){
+            $build=Get-CimInstance Win32_OperatingSystem|Select-Object -ExpandProperty BuildNumber
+            Switch($build){
+                10240{$OSName=$OSName+" 1507"}
+                10586{$OSName=$OSName+" 1511"}
+                14393{$OSName=$OSName+" 1607"}
+                15063{$OSName=$OSName+" 1703"}
+                16299{$OSName=$OSName+" 1709"}
+                17134{$OSName=$OSName+" 1803"}
+                Default{$OSName=$OSName+" Insider Preview"}
+            }
+        }
+        $Updates=(Join-Path $UpdateShare $OSName)
+        If((Test-Path $Updates)-eq$true){
+            $regex="\b(?!(KB)+(\d+)\b)\w+"
+            $hotfixes=(Get-ChildItem $Updates|Select-Object -ExpandProperty Name)
+            If($PowerShellVersion-ge6){
+                $installedUpdates=(Get-CimInstance Win32_QuickFixEngineering).HotFixID
+            }Else{
+                $installedUpdates=Get-Hotfix|Select-Object -ExpandProperty HotFixID
+            }
+            $count=$hotfixes.count
+            If(($count-eq0)-or($count-eq$null)){
+                $text='Updates: No mandatory updates to install.'
+                Write-Output $text
+                $log.Updates='OK'
+            }Else{
+                $logEnTry=$null
+                ForEach($hotfix in $hotfixes){
+                    $kb=$hotfix-replace$regex-replace"\."-replace"-"
+                    If($installedUpdates -like $kb){
+                        $text="Update $hotfix"+": OK"
+                        Write-Output $text
+                    }Else{
+                        If($null-eq$logEnTry){
+                            $logEnTry=$kb
+                        }Else{
+                            $logEnTry+=", $kb"
+                        }
+                        $fix=(Get-XMLConfigUpdatesFix).ToLower()
+                        If($fix-eq"true"){
+                            $kbfullpath=Join-Path $updates $hotfix
+                            $text="Update $hotfix"+": Missing. Installing now..."
+                            Write-Warning $text
+                            $temppath=Join-Path(Get-LocalFilesPath) "Temp"
+                            If((Test-Path $temppath)-eq$false){New-Item -Path $temppath -ItemType Directory|Out-Null}
+                            Copy-Item -Path $kbfullpath -Destination $temppath
+                            $install=Join-Path $temppath $hotfix
+                            wusa.exe $install /quiet /norestart
+                            While(Get-Process wusa -ErrorAction SilentlyContinue){Start-Sleep -Seconds 2}
+                            Remove-Item $install -Force -Recurse
+                        }Else{
+                            $text="Update $hotfix"+": Missing. Monitor mode only, no remediation."
+                            Write-Warning $text
+                        }
+                    }
+                    If($null-eq$logEnTry){
+                        $log.Updates='OK'
+                    }Else{
+                        $log.Updates=$logEnTry
+                    }
+                }
+            }
+        }Else{
+            $log.Updates='Failed'
+            Write-Warning "Updates Failed: Could not locate update folder '$($Updates)'."
+        }
+    }
+    Function Test-ConfigMgrClient{Param([Parameter(Mandatory=$true)]$Log)
+        # Check if the SCCM Agent is installed or not.
+        # If installed, perform tests to decide if reinstall is needed or not.
+        If(Get-Service -Name ccmexec -ErrorAction SilentlyContinue){
+            $text="Configuration Manager Client is installed"
+            Write-Host $text
+            # Lets not reinstall client unless tests tells us to.
+            $Reinstall=$false
+            # We test that the local database files exists. Less than 7 means the client is horrible broken and requires reinstall.
+            $LocalDBFilesPresent=Test-CcmSDF
+            If($LocalDBFilesPresent-eq$False){
+                New-ClientInstalledReason -Log $Log -Message "ConfigMgr Client database files missing."
+                Write-Host "ConfigMgr Client database files missing. Reinstalling..."
+                # Add /ForceInstall to Client Install Properties to ensure the client is uninstalled before we install client again.
+                #If(-NOT($clientInstallProperties -like "*/forceinstall*")){$clientInstallProperties=$clientInstallProperties+" /forceinstall"}
+                $Reinstall=$true
+                $Uninstall=$true
+            }
+            # Only test CM client local DB if this check is enabled
+            $testLocalDB=(Get-XMLConfigCcmSQLCELog).ToLower()
+            If($testLocalDB -like "enable"){
+                Write-Host "Testing CcmSQLCELog"
+                $LocalDB=Test-CcmSQLCELog
+                If($LocalDB-eq$true){
+                    # LocalDB is messed up
+                    New-ClientInstalledReason -Log $Log -Message "ConfigMgr Client database corrupt."
+                    Write-Host "ConfigMgr Client database corrupt. Reinstalling..."
+                    $Reinstall=$true
+                    $Uninstall=$true
+                }
+            }
+            $CCMService=Get-Service -Name ccmexec -ErrorAction SilentlyContinue
+            # Reinstall if we are unable to start the CM client
+            If(($CCMService.Status-eq"Stopped")-and($LocalDB-eq$false)){
+                Try{
+                    Write-Host "ConfigMgr Agent not running. Attempting to start it."
+                    If($CCMService.StartType-ne"Automatic"){
+                        $text="Configuring service CcmExec StartupType to: Automatic(Delayed Start)..."
+                        Write-Output $text
+                        Set-Service -Name CcmExec -StartupType Automatic
+                    }
+                    Start-Service -Name CcmExec
+                }Catch{
+                    $Reinstall=$true
+                    New-ClientInstalledReason -Log $Log -Message "Service not running, failed to start."
+                }
+            }
+            If($reinstall-eq$true){
+                $text="ConfigMgr Client Health thinks the agent need to be reinstalled.."
+                Write-Host $text
+                # Lets check that regisTry settings are OK before we Try a new installation.
+                Test-CCMSetup1
+                # Adding forceinstall to the client install properties to make sure previous client is uninstalled.
+                #If(($localDB-eq$true)-and(-NOT($clientInstallProperties -like "*/forceinstall*"))){$clientInstallProperties=$clientInstallProperties+" /forceinstall"}
+                Resolve-Client -Xml $xml -ClientInstallProperties $clientInstallProperties -FirstInstall $false
+                $log.ClientInstalled=Get-SmallDateTime
+                Start-Sleep 600
+            }
+        }Else{
+            $text="Configuration Manager client is not installed. Installing..."
+            Write-Host $text
+            Resolve-Client -Xml $xml -ClientInstallProperties $clientInstallProperties -FirstInstall $true
+            New-ClientInstalledReason -Log $Log -Message "No agent found."
+            $log.ClientInstalled=Get-SmallDateTime
+            #Start-Sleep 600
+            # Test again if agent is installed
+            If(Get-Service -Name ccmexec -ErrorAction SilentlyContinue){
+            }Else{
+                Out-LogFile -Mode "ClientInstall"
+            }
+        }
+    }
+    Function Test-ClientCacheSize{Param([Parameter(Mandatory=$true)]$Log)
+        $ClientCacheSize=Get-XMLConfigClientCache
+        If($PowerShellVersion-ge6){
+            $Cache=Get-CimInstance -Namespace "ROOT\CCM\SoftMgmtAgent" -Class CacheConfig
+        }Else{
+            $Cache=Get-WmiObject -Namespace "ROOT\CCM\SoftMgmtAgent" -Class CacheConfig
+        }
+        $CurrentCache=Get-ClientCache
+        If($ClientCacheSize-match'%'){
+            $type='percentage'
+            # percentage based cache based on disk space
+            $num=$ClientCacheSize-replace'%'
+            $num=($num/100)
+            # TotalDiskSpace in Byte
+            If($PowerShellVersion-ge6){
+                $TotalDiskSpace=(Get-CimInstance -Class Win32_LogicalDisk|Where-Object{$_.DeviceID-eq"$env:SystemDrive"}|Select-Object -ExpandProperty Size)
+            }Else{
+                $TotalDiskSpace=(Get-WmiObject -Class Win32_LogicalDisk|Where-Object{$_.DeviceID-eq"$env:SystemDrive"}|Select-Object -ExpandProperty Size)
+            }
+            $ClientCacheSize=([math]::Round(($TotalDiskSpace * $num)/1048576))
+        }Else{
+            $type='fixed'
+        }
+        If($CurrentCache-eq$ClientCacheSize){
+            $text="ConfigMgr Client Cache Size: OK"
+            Write-Host $text
+            $Log.CacheSize=$CurrentCache
+            $obj=$false
+        }Else{
+            Switch($type){
+                'fixed'{$text="ConfigMgr Client Cache Size: $CurrentCache. Expected: $ClientCacheSize. Redmediating."}
+                'percentage'{
+                    $percent=Get-XMLConfigClientCache
+                    $text="ConfigMgr Client Cache Size: $CurrentCache. Expected: $ClientCacheSize($percent). Redmediating."
+                }
+            }
+            Write-Warning $text
+            #$Cache.Size=$ClientCacheSize
+            #$Cache.Put()
+            $log.CacheSize=$ClientCacheSize
+            (New-Object -ComObject UIResource.UIResourceMgr).GetCacheInfo().TotalSize="$ClientCacheSize"
+            $obj=$true
+        }
+        Write-Output $obj
+    }
+    Function Test-ClientVersion{Param([Parameter(Mandatory=$true)]$Log)
+        $ClientVersion=Get-XMLConfigClientVersion
+        $installedVersion=Get-ClientVersion
+        $log.ClientVersion=$installedVersion
+        If($installedVersion-ge$ClientVersion){
+            $text='ConfigMgr Client version is: '+$installedVersion+': OK'
+            Write-Output $text
+            $obj=$false
+        }ElseIf((Get-XMLConfigClientAutoUpgrade).ToLower() -like 'true'){
+            $text='ConfigMgr Client version is: '+$installedVersion+': Tagging client for upgrade to version: '+$ClientVersion
+            Write-Warning $text
+            $obj=$true
+        }Else{
+            $text='ConfigMgr Client version is: '+$installedVersion+': Required version: '+$ClientVersion+' AutoUpgrade: false. Skipping upgrade'
+            Write-Output $text
+            $obj=$false
+        }
+        Write-Output $obj
+    }
+    Function Test-ClientSiteCode{Param([Parameter(Mandatory=$true)]$Log)
+        $sms=new-object -comobject "Microsoft.SMS.Client"
+        $ClientSiteCode=Get-XMLConfigClientSitecode
+        #[String]$currentSiteCode=Get-Sitecode
+        $currentSiteCode=$sms.GetAssignedSite()
+        $currentSiteCode=$currentSiteCode.Trim()
+        $Log.Sitecode=$currentSiteCode
+        # Do more investigation and testing on WMI Method "SetAssignedSite" to possible avoid reinstall of client for this check.
+        If($ClientSiteCode -like $currentSiteCode){
+            $text="ConfigMgr Client Site Code: OK"
+            Write-Host $text
+            #$obj=$false
+        }Else{
+            $text='ConfigMgr Client Site Code is "'+$currentSiteCode+'". Expected: "'+$ClientSiteCode+'". Changing sitecode.'
+            Write-Warning $text
+            $sms.SetAssignedSite($ClientSiteCode)
+            #$obj=$true
+        }
+        #Write-Output $obj
+    }
+    Function Test-PendingReboot{Param([Parameter(Mandatory=$true)]$Log)
+        # Only run pending reboot check if enabled in config
+        If(($Xml.Configuration.Option|Where-Object{$_.Name -like 'PendingReboot'}|Select-Object -ExpandProperty 'Enable') -like 'True'){
+            $result=@{
+            CBSRebootPending=$false
+            WindowsUpdateRebootRequired=$false
+            FileRenamePending=$false
+            SCCMRebootPending=$false
+            }
+            #Check CBS RegisTry
+            $key=Get-ChildItem "HKLM:Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction SilentlyContinue
+            If($null-ne$key){$result.CBSRebootPending=$true}
+            #Check Windows Update
+            $key=Get-Item 'HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired' -ErrorAction SilentlyContinue
+            If($null-ne$key){$result.WindowsUpdateRebootRequired=$true}
+            #Check PendingFileRenameOperations
+            $prop=Get-ItemProperty 'HKLM:SYSTEM\CurrentControlSet\Control\Session Manager' -Name PendingFileRenameOperations -ErrorAction SilentlyContinue
+            If($null-ne$prop){
+                #PendingFileRenameOperations is not *must* to reboot?
+                #$result.FileRenamePending=$true
+            }
+            Try{
+                $util=[wmiclass]'\\.\root\ccm\clientsdk:CCM_ClientUtilities'
+                $status=$util.DetermineIfRebootPending()
+                If(($null-ne$status)-and$status.RebootPending){$result.SCCMRebootPending=$true}
+            }Catch{
+            }
+            #Return Reboot required
+            If($result.ContainsValue($true)){
+                $text='Pending Reboot: Computer is in pending reboot'
+                Write-Warning $text
+                $log.PendingReboot='Pending Reboot'
+                If((Get-XMLConfigPendingRebootApp)-eq$true){
+                    Start-RebootApplication
+                    $log.RebootApp=Get-SmallDateTime
+                }
+            }Else{
+                $text='Pending Reboot: OK'
+                Write-Output $text
+                $log.PendingReboot='OK'
+            }
+            #Out-LogFile -Xml $xml -Text $text
+        }
+    }
+    # Functions to detect and fix errors
+    Function Test-ProvisioningMode{Param([Parameter(Mandatory=$true)]$Log)
+        $regisTryPath='HKLM:\SOFTWARE\Microsoft\CCM\CcmExec'
+        $provisioningMode=(Get-ItemProperty -Path $regisTryPath).ProvisioningMode
+        If($provisioningMode-eq'true'){
+            $text='ConfigMgr Client Provisioning Mode: YES. Remediating...'
+            Write-Warning $text
+            Set-ItemProperty -Path $regisTryPath -Name ProvisioningMode -Value "false"
+            $ArgumentList=@($false)
+            If($PowerShellVersion-ge6){
+                Invoke-CimMethod -Namespace 'root\ccm' -Class 'SMS_Client' -MethodName 'SetClientProvisioningMode' -Arguments @{bEnable=$false}|Out-Null
+            }Else{
+                Invoke-WmiMethod -Namespace 'root\ccm' -Class 'SMS_Client' -Name 'SetClientProvisioningMode' -ArgumentList $ArgumentList|Out-Null
+            }
+            $log.ProvisioningMode='Repaired'
+        }Else{
+            $text='ConfigMgr Client Provisioning Mode: OK'
+            Write-Output $text
+            $log.ProvisioningMode='OK'
+        }
+    }
+    Function Update-State{
+        Write-Verbose "Start Update-State"
+        $SCCMUpdatesStore=New-Object -ComObject Microsoft.CCM.UpdatesStore
+        $SCCMUpdatesStore.RefreshServerComplianceState()
+        $log.StateMessages='OK'
+        Write-Verbose "End Update-State"
+    }
+    Function Test-UpdateStore{Param([Parameter(Mandatory=$true)]$Log)
+        Write-Verbose "Check StateMessage.log if State Messages are successfully forwarded to Management Point"
+        $logdir=Get-CCMLogDirectory
+        $logfile="$logdir\StateMessage.log"
+        $StateMessage=Get-Content($logfile)
+        If($StateMessage-match'Successfully forwarded State Messages to the MP'){
+            $text='StateMessage: OK'
+            $log.StateMessages='OK'
+            Write-Output $text
+        }Else{
+            $text='StateMessage: ERROR. Remediating...'
+            Write-Warning $text
+            Update-State
+            $log.StateMessages='Repaired'
+        }
+    }
+    Function Test-RegisTryPol{Param([datetime]$StartTime=[datetime]::MinValue,$Days,[Parameter(Mandatory=$true)]$Log)
+        $log.WUAHandler="Checking"
+        $RepairReason=""
+        $MachineRegisTryFile="$($env:WinDir)\System32\GroupPolicy\Machine\regisTry.pol"
+        # Check 1 - Error in WUAHandler.log
+        Write-Verbose "Check WUAHandler.log for errors since $($StartTime)."
+        $logdir=Get-CCMLogDirectory
+        $logfile="$logdir\WUAHandler.log"
+        $logLine=Search-CMLogFile -LogFile $logfile -StartTime $StartTime -SearchStrings @('0x80004005','0x87d00692')
+        If($logLine){$RepairReason="WUAHandler Log"}
+        # Check 2 - RegisTry.pol is too old.
+        If($Days){
+            Write-Verbose "Check machine regisTry file to see if it's older than $($Days) days."
+            Try{
+                $file=Get-ChildItem -Path $MachineRegisTryFile -ErrorAction SilentlyContinue|Select-Object -First 1 -ExpandProperty LastWriteTime
+                $regPolDate=Get-Date($file)
+                $now=Get-Date
+                If(($now - $regPolDate).Days-ge$Days){$RepairReason="File Age"}
+            }Catch{
+                Write-Warning "GPO Cache: Failed to check machine policy age."
+            }
+        }
+        # Check 3 - Look back through the last 7 days for group policy processing errors.  
+        #Event IDs documented here: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-vista/cc749336(v=ws.10)#troubleshooting-group-policy-using-event-logs-1      
+        Try{
+            Write-Verbose "Checking the Group Policy event log for errors since $($StartTime)."
+            $numberOfGPOErrors=(Get-WinEvent -Verbose:$false -FilterHashTable @{LogName='Microsoft-Windows-GroupPolicy/Operational';Level=2;StartTime=$StartTime}-ErrorAction SilentlyContinue|Where-Object{($_.ID-ge7000-and$_.ID-le7007)-or($_.ID-ge7017-and$_.ID-le7299)-or($_.ID-eq1096)}).Count
+            If($numberOfGPOErrors-gt0){$RepairReason="Event Log"}
+        }Catch{
+            Write-Warning "GPO Cache: Failed to check the event log for policy errors."
+        }
+        #If we need to repart the policy files then do so.
+        If($RepairReason-ne""){
+            $log.WUAHandler="Broken($RepairReason)"
+            Write-Output "GPO Cache: Broken($RepairReason)"
+            Write-Verbose 'Deleting regisTry.pol and running gpupdate...'
+            Try{
+                If(Test-Path -Path $MachineRegisTryFile){Remove-Item $MachineRegisTryFile -Force}
+            }Catch{
+                Write-Warning "GPO Cache: Failed to remove the regisTry file($($MachineRegisTryFile))."
+            }Finally{
+                & Write-Output n|gpupdate.exe /force /target:computer|Out-Null
+            }
+            #Write-Verbose 'Sleeping for 1 minute to allow for group policy to refresh'
+            #Start-Sleep -Seconds 60
+            Write-Verbose 'Refreshing update policy'
+            Get-SCCMPolicyScanUpdateSource
+            Get-SCCMPolicySourceUpdateMessage
+            $log.WUAHandler="Repaired($RepairReason)"
+            Write-Output "GPO Cache: $($log.WUAHandler)"
+        }Else{
+            $log.WUAHandler='OK'
+            Write-Output "GPO Cache: OK"
+        }
+    }
+    Function Test-ClientLogSize{Param([Parameter(Mandatory=$true)]$Log)
+        Try{
+            [int]$currentLogSize=Get-ClientMaxLogSize
+        }Catch{
+            [int]$currentLogSize=0
+        }
+        Try{
+            [int]$currentMaxHistory=Get-ClientMaxLogHistory
+        }Catch{
+            [int]$currentMaxHistory=0
+        }
+        Try{
+            $logLevel=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\CCM\Logging\@Global').logLevel
+        }Catch{
+            $logLevel=1
+        }
+        $clientLogSize=Get-XMLConfigClientMaxLogSize
+        $clientLogMaxHistory=Get-XMLConfigClientMaxLogHistory
+        $text=''
+        If(($currentLogSize-eq$clientLogSize)-and($currentMaxHistory-eq$clientLogMaxHistory)){
+            $Log.MaxLogSize=$currentLogSize
+            $Log.MaxLogHistory=$currentMaxHistory
+            $text="ConfigMgr Client Max Log Size: OK($currentLogSize)"
+            Write-Host $text
+            $text="ConfigMgr Client Max Log History: OK($currentMaxHistory)"
+            Write-Host $text
+            $obj=$false
+        }Else{
+            If($currentLogSize-ne$clientLogSize){
+                $text='ConfigMgr Client Max Log Size: Configuring to '+$clientLogSize+' KB'
+                $Log.MaxLogSize=$clientLogSize
+                Write-Warning $text
+            }Else{
+                $text="ConfigMgr Client Max Log Size: OK($currentLogSize)"
+                Write-Host $text
+            }
+            If($currentMaxHistory-ne$clientLogMaxHistory){
+                $text='ConfigMgr Client Max Log History: Configuring to '+$clientLogMaxHistory
+                $Log.MaxLogHistory=$clientLogMaxHistory
+                Write-Warning $text
+            }Else{
+                $text="ConfigMgr Client Max Log History: OK($currentMaxHistory)"
+                Write-Host $text
+            }
+            $newLogSize=[int]$clientLogSize
+            $newLogSize=$newLogSize * 1000
+            If($PowerShellVersion-ge6){
+                Invoke-CimMethod -Namespace "root/ccm" -ClassName "sms_client" -MethodName SetGlobalLoggingConfiguration -Arguments @{LogLevel=$loglevel; LogMaxHistory=$clientLogMaxHistory; LogMaxSize=$newLogSize}
+            }Else{
+                $smsClient=[wmiclass]"root/ccm:sms_client"
+                $smsClient.SetGlobalLoggingConfiguration($logLevel, $newLogSize, $clientLogMaxHistory)
+            }
+            #Write-Verbose 'Returning true to trigger restart of ccmexec service'
+            #Write-Verbose 'Sleeping for 5 seconds to allow WMI method complete before we collect new results...'
+            #Start-Sleep -Seconds 5
+            Try{
+                $Log.MaxLogSize=Get-ClientMaxLogSize
+            }Catch{
+                $Log.MaxLogSize=0
+            }
+            Try{
+                $Log.MaxLogHistory=Get-ClientMaxLogHistory
+            }Catch{
+                $Log.MaxLogHistory=0
+            }
+            $obj=$true
+        }
+        Write-Output $obj
+    }
+    Function Remove-CCMOrphanedCache{
+        Write-Host "Clearing ConfigMgr orphaned Cache items."
+        Try{
+            $CCMCache="$env:SystemDrive\Windows\ccmcache"
+            $CCMCache=(New-Object -ComObject "UIResource.UIResourceMgr").GetCacheInfo().Location
+            If($null-eq$CCMCache){
+                $CCMCache="$env:SystemDrive\Windows\ccmcache"
+            }
+            $ValidCachedFolders=(New-Object -ComObject "UIResource.UIResourceMgr").GetCacheInfo().GetCacheElements()|ForEach-Object{$_.Location}
+            $AllCachedFolders=(Get-ChildItem -Path $CCMCache)|Select-Object Fullname -ExpandProperty Fullname
+            ForEach($CachedFolder in $AllCachedFolders){
+                If($ValidCachedFolders-notcontains$CachedFolder){
+                    #Don't delete new folders that might be syncing data with BITS
+                    If((Get-ItemProperty $CachedFolder).LastWriteTime-le(get-date).AddDays(-14)){
+                        Write-Verbose "Removing orphaned folder: $CachedFolder - LastWriteTime: $((Get-ItemProperty $CachedFolder).LastWriteTime)"
+                        Remove-Item -Path $CachedFolder -Force -Recurse
+                    }
+                }
+            }
+        }Catch{
+            Write-Host "Failed Clearing ConfigMgr orphaned Cache items."
+        }
+    }
+    Function Resolve-Client{Param([Parameter(Mandatory=$false)]$Xml,[Parameter(Mandatory=$true)]$ClientInstallProperties,[Parameter(Mandatory=$false)]$FirstInstall=$false)
+        $ClientShare=Get-XMLConfigClientShare
+        If((Test-Path $ClientShare -ErrorAction SilentlyContinue)-eq$true){
+            If($FirstInstall-eq$true){
+                $text='Installing Configuration Manager Client.'
+            }Else{
+                $text='Client tagged for reinstall. Reinstalling client...'
+            }
+            Write-Output $text
+            Write-Verbose "Perform a test on a specific regisTry key required for ccmsetup to succeed."
+            Test-CCMSetup1
+            Write-Verbose "Enforce registration of common DLL files to make sure CCM Agent works."
+            $DllFiles='actxprxy.dll', 'atl.dll', 'Bitsprx2.dll', 'Bitsprx3.dll', 'browseui.dll', 'cryptdlg.dll', 'dssenh.dll', 'gpkcsp.dll', 'initpki.dll', 'jscript.dll', 'mshtml.dll', 'msi.dll', 'mssip32.dll', 'msxml.dll', 'msxml3.dll', 'msxml3a.dll', 'msxml3r.dll', 'msxml4.dll', 'msxml4a.dll', 'msxml4r.dll', 'msxml6.dll', 'msxml6r.dll', 'muweb.dll', 'ole32.dll', 'oleaut32.dll', 'Qmgr.dll', 'Qmgrprxy.dll', 'rsaenh.dll', 'sccbase.dll', 'scrrun.dll', 'shdocvw.dll', 'shell32.dll', 'slbcsp.dll', 'softpub.dll', 'rlmon.dll', 'userenv.dll', 'vbscript.dll', 'Winhttp.dll', 'wintrust.dll', 'wuapi.dll', 'wuaueng.dll', 'wuaueng1.dll', 'wucltui.dll', 'wucltux.dll', 'wups.dll', 'wups2.dll', 'wuweb.dll', 'wuwebv.dll', 'Xpob2res.dll', 'WBEM\wmisvc.dll'
+            ForEach($Dll in $DllFiles){
+                $file=$env:windir+"\System32\$Dll"
+                Register-DLLFile -FilePath $File
+            }
+            If($Uninstall-eq$true){
+                Write-Verbose "Trigger ConfigMgr Client uninstallation using Invoke-Expression."
+                Invoke-Expression "&'$ClientShare\ccmsetup.exe' /uninstall"
+                $launched=$true
+                Do{
+                    Start-Sleep -seconds 5
+                    If(Get-Process "ccmsetup" -ErrorAction SilentlyContinue){
+                        Write-Verbose "ConfigMgr Client Uninstallation still running"
+                        $launched=$true
+                    }Else{
+                        $launched=$false
+                    }
+                }While($launched-eq$true)
+            }
+            Write-Verbose "Trigger ConfigMgr Client installation using Invoke-Expression."
+            Invoke-Expression "&'$ClientShare\ccmsetup.exe' $ClientInstallProperties"
+            $launched=$true
+            Do{
+                Start-Sleep -seconds 5
+                If(Get-Process "ccmsetup" -ErrorAction SilentlyContinue){
+                    Write-Verbose "ConfigMgr Client installation still running"
+                    $launched=$true
+                }Else{
+                    $launched=$false
+                }
+            }While($launched-eq$true)
+            If($FirstInstall-eq$true){
+                Write-Host "ConfigMgr Client was installed for the first time. Waiting 6 minutes for client to syncronize policy before proceeding."
+                Start-Sleep -Seconds 360
+            }
+        # Client is reinstalled. Remove tag.
+        }Else{
+            $text='ERROR: Client tagged for reinstall, but failed to access fileshare: '+$ClientShare
+            Write-Error $text
+            Exit 1
+        }
+    }
+    Function Register-DLLFile{[CmdletBinding()]Param([string]$FilePath)
+        Try{
+            $Result=Start-Process -FilePath 'regsvr32.exe' -Args "/s `"$FilePath`"" -Wait -NoNewWindow -PassThru
+        }Catch{
+        }
+    }
+    Function Test-WMI{Param([Parameter(Mandatory=$true)]$Log)
+        $vote=0
+        $result=winmgmt /verifyrepository
+        Switch -wildcard($result){
+            # Always fix if this returns inconsistent
+            "*inconsistent*"{$vote=100}# English
+            "*not consistent*" {$vote=100}# English
+            "*inkonsekvent*"{$vote=100}# Swedish
+            "*epäyhtenäinen*"{$vote=100}# Finnish
+            "*inkonsistent*"{$vote=100}# German
+            # Add more languages as I learn their inconsistent value
+        }
+        Try{
+            If($PowerShellVersion-ge6){
+                $WMI=Get-CimInstance Win32_ComputerSystem -ErrorAction Stop
+            }Else{
+                $WMI=Get-WmiObject Win32_ComputerSystem -ErrorAction Stop
+            }
+        }Catch{
+            Write-Verbose 'Failed to connect to WMI class "Win32_ComputerSystem". Voting for WMI fix...'
+            $vote++
+        }
+        Try{
+            If($PowerShellVersion-ge6){
+                $WMI=Get-CimInstance -Namespace root/ccm -Class SMS_Client -ErrorAction Stop
+            }Else{
+                $WMI=Get-WmiObject -Namespace root/ccm -Class SMS_Client -ErrorAction Stop
+            }
+        }Catch{
+            Write-Verbose 'Failed to connect to WMI namespace "root/ccm" class "SMS_Client". Tagging client for reinstall instead of WMI fix.'
+            $obj=$true
+        }Finally{
+            If($vote-eq0){
+                $text='WMI Check: OK'
+                $log.WMI='OK'
+                Write-Host $text
+                $obj=$false
+            }Else{
+                $fix=Get-XMLConfigWMIRepairEnable
+                If($fix -like "True"){
+                    $text='WMI Check: Corrupt. Attempting to repair WMI and reinstall ConfigMgr client.'
+                    Write-Warning $text
+                    Repair-WMI
+                    $log.WMI='Repaired'
+                }Else{
+                    $text='WMI Check: Corrupt. Autofix is disabled'
+                    Write-Warning $text
+                    $log.WMI='Corrupt'
+                }
+                Write-Verbose "returning true to tag client for reinstall" 
+                $obj=$true
+            }
+            #Out-LogFile -Xml $xml -Text $text
+            Write-Output $obj
+        }
+    }
+    Function Repair-WMI{
+        $text='Repairing WMI'
+        Write-Output $text
+        # Check PATH
+        If((!(@(($ENV:PATH).Split(";"))-contains"$env:SystemDrive\WINDOWS\System32\Wbem"))-and(!(@(($ENV:PATH).Split(";"))-contains"%systemroot%\System32\Wbem"))){
+            $text="WMI Folder not in search path!."
+            Write-Warning $text
+        }
+        # Stop WMI
+        Stop-Service -Force ccmexec -ErrorAction SilentlyContinue 
+        Stop-Service -Force winmgmt
+        # WMI Binaries
+        [String[]]$aWMIBinaries=@("unsecapp.exe","wmiadap.exe","wmiapsrv.exe","wmiprvse.exe","scrcons.exe")
+        ForEach($sWMIPath in @(($ENV:SystemRoot+"\System32\wbem"),($ENV:SystemRoot+"\SysWOW64\wbem"))){
+            If(Test-Path -Path $sWMIPath){
+                Push-Location $sWMIPath
+                ForEach($sBin in $aWMIBinaries){
+                    If(Test-Path -Path $sBin){
+                        $oCurrentBin=Get-Item -Path $sBin
+                        & $oCurrentBin.FullName /RegServer
+                    }Else{
+                        # Warning only for System32
+                        If($sWMIPath-eq$ENV:SystemRoot+"\System32\wbem"){
+                            Write-Warning "File $sBin not found!"
+                        }
+                    }
+                }
+                Pop-Location
+            }
+        }
+        # Reregister Managed Objects
+        Write-Verbose "Reseting Repository..."
+        &($ENV:SystemRoot+"\system32\wbem\winmgmt.exe") /resetrepository
+        &($ENV:SystemRoot+"\system32\wbem\winmgmt.exe") /salvagerepository
+        Start-Service winmgmt
+        $text='Tagging ConfigMgr client for reinstall'
+        Write-Warning $text
+    }
+    # Test if the compliance state messages should be resent.
+    Function Test-RefreshComplianceState{Param($Days=0,[Parameter(Mandatory=$true)]$RegisTryKey,[Parameter(Mandatory=$true)]$Log)    
+        $RegValueName="RefreshServerComplianceState"
+        #Get the last time this script was ran.  If the regisTry isn't found just use the current date.
+        Try{
+            [datetime]$LastSent=Get-RegisTryValue -Path $RegisTryKey -Name $RegValueName
+        }Catch{
+            [datetime]$LastSent=Get-Date
+        }
+        Write-Verbose "The compliance states were last sent on $($LastSent)"
+        #Determine the number of days until the next run.
+        $NumberOfDays=(New-Timespan -Start(Get-Date) -End($LastSent.AddDays($Days))).Days
+        #Resend complianc states if the next interval has already arrived or randomly based on the number of days left until the next interval.
+        If(($NumberOfDays-le0)-or((Get-Random -Maximum $NumberOfDays)-eq0)){
+            Try{
+                Write-Verbose "Resending compliance states."
+                (New-Object -ComObject Microsoft.CCM.UpdatesStore).RefreshServerComplianceState()
+                $LastSent=Get-Date                
+                Write-Output "Compliance States: Refreshed."
+            }Catch{
+                Write-Error "Failed to resend the compliance states."
+                $LastSent=[datetime]::MinValue
+            }                       
+        }Else{
+            Write-Output "Compliance States: OK."            
+        }
+        Set-RegisTryValue -Path $RegisTryKey -Name $RegValueName -Value $LastSent
+        $Log.RefreshComplianceState=Get-SmallDateTime $LastSent
+    }
+    # Start ConfigMgr Agent if not already running
+    Function Test-SCCMService{
+        If($service.Status-ne'Running'){
+            Try{
+                Start-Service -Name CcmExec|Out-Null
+            }Catch{
+            }
+        }
+    }
+    Function Test-SMSTSMgr{
+        $service=get-service smstsmgr
+        If(($service.ServicesDependedOn).name-contains"ccmexec"){ 
+            write-host "SMSTSMgr: Removing dependency on CCMExec service."  
+            start-process sc.exe -ArgumentList "config smstsmgr depend=winmgmt" -wait  
+        }
+        # WMI service depenency is present by default
+        If(($service.ServicesDependedOn).name-notcontains"Winmgmt"){ 
+            write-host "SMSTSMgr: Adding dependency on Windows Management Instrumentaion service."  
+            start-process sc.exe -ArgumentList "config smstsmgr depend=winmgmt" -wait  
+        }Else{
+            Write-Host "SMSTSMgr: OK"
+        }
+    }
+    # Windows Service Functions
+    Function Test-Services{Param([Parameter(Mandatory=$true)]$Xml, $log)
+        $log.Services='OK'
+        Write-Verbose 'Test services from XML configuration file'
+        ForEach($service in $Xml.Configuration.Service){
+            $startuptype=($service.StartupType).ToLower()
+            If($startuptype -like "automatic(delayed start)"){
+                $service.StartupType="automaticd"
+            }
+            If($service.uptime-ne$null){
+                $uptime=($service.Uptime).ToLower()
+                Test-Service -Name $service.Name -StartupType $service.StartupType -State $service.State -Log $log -Uptime $uptime -ErrorAction SilentlyContinue
+            }Else{
+                Test-Service -Name $service.Name -StartupType $service.StartupType -State $service.State -Log $log -ErrorAction SilentlyContinue
+            }
+        }
+    }
+    Function Test-Service{Param([Parameter(Mandatory=$True,HelpMessage='Name')][string]$Name,[Parameter(Mandatory=$True,HelpMessage='StartupType: Automatic, Automatic(Delayed Start), Manual, Disabled')][string]$StartupType,[Parameter(Mandatory=$True,HelpMessage='State: Running, Stopped')][string]$State,[Parameter(Mandatory=$False,HelpMessage='Updatime in days')][int]$Uptime,[Parameter(Mandatory=$True)]$log)
+        $OSName=Get-OperatingSystem
+        # Handle all sorts of casing and mispelling of delayed and triggerd start in config.xml services
+        $val=$StartupType.ToLower()
+        Switch -Wildcard($val){
+            "automaticd*"{$StartupType="Automatic(Delayed Start)"}
+            "automatic(d*"{$StartupType="Automatic(Delayed Start)"}
+            "automatic(t*"{$StartupType="Automatic(Trigger Start)"}
+            "automatict*"{$StartupType="Automatic(Trigger Start)"}
+        }
+        $path="HKLM:\SYSTEM\CurrentControlSet\Services\$name"
+        $DelayedAutostart=(Get-ItemProperty -Path $path).DelayedAutostart
+        If($DelayedAutostart-ne1){
+            $DelayedAutostart=0
+        }
+        $service=Get-Service -Name $Name
+        If($PowerShellVersion-ge6){
+            $WMIService=Get-CimInstance -Class Win32_Service -Property StartMode -Filter "Name='$Name'"
+        }Else{
+            $WMIService=Get-WmiObject -Class Win32_Service -Property StartMode -Filter "Name='$Name'"
+        }
+        $StartMode=($WMIService.StartMode).ToLower()
+        Switch -Wildcard($StartMode){
+            "auto*"{
+                If($DelayedAutostart-eq1){
+                    $serviceStartType="Automatic(Delayed Start)"
+                }Else{
+                    $serviceStartType="Automatic"
+                }
+            }
+            <# This will be implemented at a later time.
+            "automatic d*"{$serviceStartType="Automatic(Delayed Start)"}
+            "automatic(d*"{$serviceStartType="Automatic(Delayed Start)"}
+            "automatic(t*"{$serviceStartType="Automatic(Trigger Start)"}
+            "automatic t*"{$serviceStartType="Automatic(Trigger Start)"}
+            #>
+            "manual"{$serviceStartType="Manual"}
+            "disabled"{$serviceStartType="Disabled"}
+        }
+        Write-Verbose "Verify startup type"
+        If($serviceStartType-eq$StartupType){
+            $text="Service $Name startup: OK"
+            Write-Output $text
+        }ElseIf($StartupType -like "Automatic(Delayed Start)"){
+            # Handle Automatic Trigger Start the dirty way for these two services. Implement in a nice way in future version.
+            If((($name-eq"wuauserv")-or($name-eq"W32Time"))-and(($OSName -like "Windows 10*")-or($OSName -like "*Server 2016*"))){
+                If($service.StartType-ne"Automatic"){
+                    $text="Configuring service $Name StartupType to: Automatic(Trigger Start)..."
+                    Set-Service -Name $service.Name -StartupType Automatic
+                }Else{
+                    "Service $Name startup: OK"
+                }
+                Write-Output $text
+            }Else{
+                # Automatic delayed requires the use of sc.exe
+                & sc.exe config $service start=delayed-auto|Out-Null
+                $text="Configuring service $Name StartupType to: $StartupType..."
+                Write-Output $text
+                $log.Services='Started'
+            }
+        }Else{
+            Try{
+                $text="Configuring service $Name StartupType to: $StartupType..."
+                Write-Output $text
+                Set-Service -Name $service.Name -StartupType $StartupType
+                $log.Services='Started'
+            }Catch{
+                $text="Failed to set $StartupType StartupType on service $Name"
+                Write-Error $text
+            }
+        }
+        Write-Verbose 'Verify service is running'
+        If($service.Status-eq"Running"){
+            $text='Service '+$Name+' running: OK'
+            Write-Output $text
+            #If we are checking uptime.
+            If($Uptime){
+                Write-Verbose "Verify the $($Name) service hasn't exceeded uptime of $($Uptime) days."
+                $ServiceUptime=Get-ServiceUpTime -Name $Name
+                If($ServiceUptime-ge$Uptime){
+                    Try{
+                        #Before restarting the service wait for some known processes to end.  Restarting the service while an app or updates is installing might cause issues.
+                        $Timer=[Diagnostics.Stopwatch]::StartNew()
+                        $WaitMinutes=30
+                        $ProcessesStopped=$True
+                        While((Get-Process -Name WUSA,wuauclt,setup,TrustedInstaller,msiexec,TiWorker,ccmsetup -ErrorAction SilentlyContinue).Count-gt0){
+                            $MinutesLeft=$WaitMinutes-$Timer.Elapsed.Minutes                        
+                            If($MinutesLeft-le0){
+                                Write-Warning "Timed out waiting $($WaitMinutes) minutes for installation processes to complete.  Will not restart the $($Name) service."
+                                $ProcessesStopped=$False
+                                Break
+                            }
+                            Write-Warning "Waiting $($MinutesLeft) minutes for installation processes to complete."
+                            Start-Sleep -Seconds 30
+                        }
+                        $Timer.Stop()
+                        #If the processes are not running the restart the service.
+                        If($ProcessesStopped){
+                            Write-Output "Restarting service: $($Name)..."
+                            Restart-Service  -Name $service.Name -Force
+                            Write-Output "Restarted service: $($Name)..."
+                            $log.Services='Restarted'
+                        }
+                    }Catch{
+                        $text="Failed to restart service $($Name)"
+                        Write-Error $text
+                    }
+                }Else{
+                    Write-Output "Service $($Name) uptime: OK"
+                }
+            }
+        }Else{
+            Try{
+                $ReTryService=$False
+                $text='Starting service: '+$Name+'...'
+                Write-Output $text
+                Start-Service -Name $service.Name -ErrorAction Stop                
+                $log.Services='Started'
+            }Catch{
+                #Error 1290(-2146233087) indicates that the service is sharing a thread with another service that is protected and cannot share its thread.
+                #This is resolved by configuring the service to run on its own thread.
+                If($_.Exception.Hresult-eq'-2146233087'){               
+                    Write-Output "Failed to start service $Name because it's sharing a thread with another process.  Changing to use its own thread."
+                    & cmd /c sc config $Name type=own
+                    $ReTryService=$True                    
+                }Else{
+                    $text='Failed to start service '+$Name
+                    Write-Error $text
+                }
+            }
+            #If a recoverable error was found, Try starting it again.
+            If($ReTryService){
+                Try{                   
+                    Start-Service -Name $service.Name -ErrorAction Stop                
+                    $log.Services='Started'
+                }Catch{
+                    $text='Failed to start service '+$Name
+                    Write-Error $text
+                }
+            }
+        }
+    }
+    Function Test-AdminShare{Param([Parameter(Mandatory=$true)]$Log)
+        Write-Verbose "Test the ADMIN$ and C$"
+        If($PowerShellVersion-ge6){
+            $share=Get-CimInstance Win32_Share|Where-Object{$_.Name -like 'ADMIN$'}
+        }Else{
+            $share=Get-WmiObject Win32_Share|Where-Object{$_.Name -like 'ADMIN$'}
+        }
+        #$shareClass=[WMICLASS]"WIN32_Share"  # Depreciated
+        If($share.Name-contains'ADMIN$'){
+            $text='Adminshare Admin$: OK'
+            Write-Output $text
+        }Else{
+            $fix=$true
+        }
+        If($PowerShellVersion-ge6){
+            $share=Get-CimInstance Win32_Share|Where-Object{$_.Name -like 'C$'}
+        }Else{
+            $share=Get-WmiObject Win32_Share|Where-Object{$_.Name -like 'C$'}
+        }
+        #$shareClass=[WMICLASS]'WIN32_Share'  # Depreciated
+        If($share.Name-contains"C$"){
+            $text='Adminshare C$: OK'
+            Write-Output $text
+        }Else{
+            $fix=$true
+        }
+        If($fix-eq$true){
+            $text='Error with Adminshares. Remediating...'
+            $log.AdminShare='Repaired'
+            Write-Warning $text
+            Stop-Service server -Force
+            Start-Service server
+        }Else{
+            $log.AdminShare='OK'
+        }
+    }
+    Function Test-DiskSpace{
+        $XMLDiskSpace=Get-XMLConfigOSDiskFreeSpace
+        If($PowerShellVersion-ge6){
+            $driveC=Get-CimInstance -Class Win32_LogicalDisk|Where-Object{$_.DeviceID-eq"$env:SystemDrive"}|Select-Object FreeSpace, Size
+        }Else{
+            $driveC=Get-WmiObject -Class Win32_LogicalDisk|Where-Object{$_.DeviceID-eq"$env:SystemDrive"}|Select-Object FreeSpace, Size
+        }
+        $freeSpace=(($driveC.FreeSpace/$driveC.Size) * 100)
+        If($freeSpace-le$XMLDiskSpace){
+            $text="Local disk $env:SystemDrive Less than $XMLDiskSpace % free space"
+            Write-Error $text
+        }Else{
+            $text="Free space $env:SystemDrive OK"
+            Write-Output $text
+        }
+    }
+    Function Test-CCMSoftwareDistribution{
+        # TODO Implement this function
+        Get-WmiObject -Class CCM_SoftwareDistributionClientConfig
+    }
+    Function Get-UBR{
+        $UBR=(Get-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion').UBR
+        Write-Output $UBR
+    }
+    Function Get-LastReboot{Param([Parameter(Mandatory=$true)][xml]$Xml)
+        # Only run if option in config is enabled
+        If(($Xml.Configuration.Option|Where-Object{$_.Name -like 'RebootApplication'}|Select-Object -ExpandProperty 'Enable') -like 'True'){
+            [float]$maxRebootDays=Get-XMLConfigMaxRebootDays
+            If($PowerShellVersion-ge6){
+                $wmi=Get-CimInstance Win32_OperatingSystem
+            }Else{
+                $wmi=Get-WmiObject Win32_OperatingSystem
+            }
+            $lastBootTime=$wmi.ConvertToDateTime($wmi.LastBootUpTime)
+            $uptime=(Get-Date) -($wmi.ConvertToDateTime($wmi.lastbootuptime))
+            If($uptime.TotalDays-lt$maxRebootDays){
+                $text='Last boot time: '+$lastBootTime+': OK'
+                Write-Output $text
+            }ElseIf(($uptime.TotalDays-ge$maxRebootDays)-and(Get-XMLConfigRebootApplicationEnable-eq$true)){
+                $text='Last boot time: '+$lastBootTime+': More than '+$maxRebootDays+' days since last reboot. Starting reboot application.'
+                Write-Warning $text
+                Start-RebootApplication
+            }Else{
+                $text='Last boot time: '+$lastBootTime+': More than '+$maxRebootDays+' days since last reboot. Reboot application disabled.'
+                Write-Warning $text
+            }
+        }
+    }
+    Function Start-RebootApplication{
+        $taskName='ConfigMgr Client Health - Reboot on demand'
+        #$OS=Get-OperatingSystem
+        #If($OS -like "*Windows 7*"){
+        $task=schtasks.exe /query|FIND /I "ConfigMgr Client Health - Reboot"
+        #}
+        #Else{$task=Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue}
+        If($task-eq$null){New-RebootTask -taskName $taskName}
+        #If($OS-notlike"*Windows 7*"){Start-ScheduledTask -TaskName $taskName}
+        #Else{
+        schtasks.exe /Run /TN $taskName
+        #}
+    }
+    Function New-RebootTask{Param([Parameter(Mandatory=$true)]$taskName)
+        $rebootApp=Get-XMLConfigRebootApplication
+        # $execute is the executable file, $arguement is all the arguments added to it.
+        $execute,$arguments=$rebootApp.Split(' ')
+        $argument=$null
+        ForEach($i in $arguments){
+            $argument+=$i+" "
+        }
+        # Trim the " " from argument if present
+        $i=$argument.Length -1
+        If($argument.Substring($i)-eq' '){
+            $argument=$argument.Substring(0, $argument.Length -1)
+        }
+        #$OS=Get-OperatingSystem
+        #If($OS -like "*Windows 7*"){
+        schtasks.exe /Create /tn $taskName /tr "$execute $argument" /ru "BUILTIN\Users" /sc ONCE /st 00:00 /sd 01/01/1901
+        #}
+        <#
+        Else{
+        $action=New-ScheduledTaskAction -Execute $execute -Argument $argument
+        $userPrincipal=New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545"
+        Register-ScheduledTask -Action $action -TaskName $taskName -Principal $userPrincipal|Out-Null
+        }
+        #>
+    }
+    Function Start-Ccmeval{
+        Write-Host "Starting Built-in Configuration Manager Client Health Evaluation"
+        $task="Microsoft\Configuration Manager\Configuration Manager Health Evaluation"
+        schtasks.exe /Run /TN $task|Out-Null
+    }
+    Function Test-MissingDrivers{Param([Parameter(Mandatory=$true)]$Log)
+        $FileLogLevel=((Get-XMLConfigLogginLevel).ToString()).ToLower()
+        $i=0
+        If($PowerShellVersion-ge6){
+            $devices=Get-CimInstance Win32_PNPEntity|Where-Object{($_.ConfigManagerErrorCode-ne0)-and($_.ConfigManagerErrorCode-ne22)-and($_.Name-notlike"*PS/2*")}|Select-Object Name, DeviceID
+        }Else{
+            $devices=Get-WmiObject Win32_PNPEntity|Where-Object{($_.ConfigManagerErrorCode-ne0)-and($_.ConfigManagerErrorCode-ne22)-and($_.Name-notlike"*PS/2*")}|Select-Object Name, DeviceID
+        }
+        $devices|ForEach-Object{$i++}
+        If($devices-ne$null){
+            $text="Drivers: $i unknown or faulty device(s)" 
+            Write-Warning $text
+            $log.Drivers="$i unknown or faulty driver(s)" 
+            ForEach($device in $devices){
+                $text='Missing or faulty driver: '+$device.Name+'. Device ID: '+$device.DeviceID
+                Write-Warning $text
+                If(!($FileLogLevel -like "clientlocal")){
+                    Out-LogFile -Xml $xml -Text $text
+                }
+            }
+        }Else{
+            $text="Drivers: OK"
+            Write-Output $text
+            $log.Drivers='OK' 
+        }
+    }
+    # Function to store SCCM log file changes to be processed
+    Function New-SCCMLogFileJob{Param([Parameter(Mandatory=$true)]$Logfile,[Parameter(Mandatory=$true)]$Text,[Parameter(Mandatory=$true)]$SCCMLogJobs)
+        $path=Get-CCMLogDirectory
+        $file="$path\$LogFile"
+        $SCCMLogJobs.Rows.Add($file, $text)
+    }
+    # Function to remove info in SCCM logfiles after remediation. This to prevent false positives triggering remediation next time script runs
+    Function Update-SCCMLogFile{Param([Parameter(Mandatory=$true)]$SCCMLogJobs)
+        Write-Verbose "Start Update-SCCMLogFile"
+        ForEach($job in $SCCMLogJobs){
+            get-content -Path $job.File|Where-Object{$_-notmatch$job.Text}|Out-File $job.File -Force
+        }
+        Write-Verbose "End Update-SCCMLogFile"
+    }
+    Function Test-SCCMHardwareInventoryScan{Param([Parameter(Mandatory=$true)]$Log)
+        Write-Verbose "Start Test-SCCMHardwareInventoryScan"
+        $days=Get-XMLConfigHardwareInventoryDays
+        If($PowerShellVersion-ge6){
+            $wmi=Get-CimInstance -Namespace root\ccm\invagt -Class InventoryActionStatus|Where-Object{$_.InventoryActionID-eq'{00000000-0000-0000-0000-000000000001}'}|Select-Object @{label='HWSCAN';expression={$_.ConvertToDateTime($_.LastCycleStartedDate)}}
+        }Else{
+            $wmi=Get-WmiObject -Namespace root\ccm\invagt -Class InventoryActionStatus|Where-Object{$_.InventoryActionID-eq'{00000000-0000-0000-0000-000000000001}'}|Select-Object @{label='HWSCAN';expression={$_.ConvertToDateTime($_.LastCycleStartedDate)}}
+        }
+        $HWScanDate=$wmi|Select-Object -ExpandProperty HWSCAN
+        $HWScanDate=Get-SmallDateTime $HWScanDate
+        $minDate=Get-SmallDateTime((Get-Date).AddDays(-$days))
+        If($HWScanDate-le$minDate){
+            $fix=(Get-XMLConfigHardwareInventoryFix).ToLower()
+            If($fix-eq"true"){
+                $text="ConfigMgr Hardware Inventory scan: $HWScanDate. Starting hardware inventory scan of the client."
+                Write-Host $Text
+                Get-SCCMPolicyHardwareInventory
+                # Get the new date after policy trigger
+                If($PowerShellVersion-ge6){
+                    $wmi=Get-CimInstance -Namespace root\ccm\invagt -Class InventoryActionStatus|Where-Object{$_.InventoryActionID-eq'{00000000-0000-0000-0000-000000000001}'}|Select-Object @{label='HWSCAN';expression={$_.ConvertToDateTime($_.LastCycleStartedDate)}}
+                }Else{
+                    $wmi=Get-WmiObject -Namespace root\ccm\invagt -Class InventoryActionStatus|Where-Object{$_.InventoryActionID-eq'{00000000-0000-0000-0000-000000000001}'}|Select-Object @{label='HWSCAN';expression={$_.ConvertToDateTime($_.LastCycleStartedDate)}}
+                }
+                $HWScanDate=$wmi|Select-Object -ExpandProperty HWSCAN
+                $HWScanDate=Get-SmallDateTime -Date $HWScanDate
+            }Else{
+                # No need to update anything if fix=false. Last date will still be set in log
+            }
+        }Else{
+            $text="ConfigMgr Hardware Inventory scan: OK"
+            Write-Output $text
+        }
+        $log.HWInventory=$HWScanDate
+        Write-Verbose "End Test-SCCMHardwareInventoryScan"
+    }
+    # TODO: Implement so result of this remediation is stored in WMI log object, next to result of previous WMI check. This do not require db or webservice update
+    # ref: https://social.technet.microsoft.com/Forums/de-DE/1f48e8d8-4e13-47b5-ae1b-dcb831c0a93b/setup-was-unable-to-compile-the-file-discoverystatusmof-the-error-code-is-8004100e?forum=configmanagerdeployment
+    Function Test-PolicyPlatform{Param([Parameter(Mandatory=$true)]$Log)
+        Try{
+            If(Get-WmiObject -Namespace 'root/Microsoft' -Class '__Namespace' -Filter 'Name="PolicyPlatform"'){
+                Write-Host "PolicyPlatform: OK"
+            }Else{
+                Write-Warning "PolicyPlatform: Not found, recompiling WMI 'Microsoft Policy Platform\ExtendedStatus.mof'"
+                If($PowerShellVersion-ge6){
+                    $OS=Get-CimInstance Win32_OperatingSystem
+                }Else{
+                    $OS=Get-WmiObject Win32_OperatingSystem
+                }
+                # 32 or 64?
+                If($OS.OSArchitecture-match'64'){
+                    & mofcomp "$env:ProgramW6432\Microsoft Policy Platform\ExtendedStatus.mof"
+                }Else{
+                    & mofcomp "$env:ProgramFiles\Microsoft Policy Platform\ExtendedStatus.mof"
+                }
+                # Update WMI log object
+                $text='PolicyPlatform Recompiled.'
+                If(!($Log.WMI-eq'OK')){
+                    $Log.WMI+=". $text"
+                }Else{
+                    $Log.WMI=$text
+                }
+            }
+        }Catch{
+            Write-Warning "PolicyPlatform: RecompilePolicyPlatform failed!"
+        }
+    }
+    # Get the clients SiteName in Active Directory
+    Function Get-ClientSiteName{
+        Try{
+            If($PowerShellVersion-ge6){
+                $obj=(Get-CimInstance Win32_NTDomain).ClientSiteName
+            }Else{
+                $obj=(Get-WmiObject Win32_NTDomain).ClientSiteName
+            }
+        }Catch{
+            $obj=$false
+        }Finally{
+            If($obj-ne$false){
+                Write-Output($obj|Select-Object -First 1)
+            }
+        }
+    }
+    Function Test-SoftwareMeteringPrepDriver{Param([Parameter(Mandatory=$true)]$Log)
+        # To execute function:If(Test-SoftwareMeteringPrepDriver-eq$false){$restartCCMExec=$true}
+        # Thanks to Paul Andrews for letting me know about this issue.
+        # And Sherry Kissinger for a nice fix: https://mnscug.org/blogs/sherry-kissinger/481-configmgr-ccmrecentlyusedapps-blank-or-mtrmgr-log-with-startprepdriver-openservice-failed-with-error-issue
+        Write-Verbose "Start Test-SoftwareMeteringPrepDriver"
+        $logdir=Get-CCMLogDirectory
+        $logfile="$logdir\mtrmgr.log"
+        $content=Get-Content -Path $logfile
+        $error1="StartPrepDriver - OpenService Failed with Error"
+        $error2="Software Metering failed to start PrepDriver"
+        If(($content-match$error1)-or($content-match$error2)){
+            $fix=(Get-XMLConfigSoftwareMeteringFix).ToLower()
+            If($fix-eq"true"){
+                $Text="Software Metering - PrepDriver: Error. Remediating..."
+                Write-Host $Text
+                $CMClientDIR=(Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Client\Configuration\Client Properties" -Name 'Local SMS Path').'Local SMS Path'
+                $ExePath=$env:windir+'\system32\RUNDLL32.EXE'
+                $CLine=' SETUPAPI.DLL,InstallHinfSection DefaultInstall 128 '+$CMClientDIR+'prepdrv.inf'
+                $ExePath=$env:windir+'\system32\RUNDLL32.EXE'
+                $Prms=$Cline.Split(" ")
+                & "$Exepath" $Prms
+                $newContent=$content|Select-String -pattern $error1, $error2 -notmatch
+                Stop-Service -Name CcmExec
+                Out-File -FilePath $logfile -InputObject $newContent -Encoding utf8 -Force
+                Start-Service -Name CcmExec
+                $Obj=$false
+                $Log.SWMetering="Remediated"
+            }Else{
+                # Set $obj to true as we don't want to do anything with the CM agent.
+                $obj=$true
+                $Log.SWMetering="Error"
+            }
+        }Else{
+            $Text="Software Metering - PrepDriver: OK"
+            Write-Host $Text
+            $Obj=$true
+            $Log.SWMetering="OK"
+        }
+        $content=$null # Clean the variable containing the log file.
+        Write-Output $Obj
+        Write-Verbose "End Test-SoftwareMeteringPrepDriver"
+    }
+    Function Test-SCCMHWScanErrors{
+        # Function to test and fix errors that prevent a computer to perform a HW scan. Not sure if this is really needed or not.
+    }
+    # SCCM Client evaluation policies
+    Function Get-SCCMPolicySourceUpdateMessage{
+        $trigger="{00000000-0000-0000-0000-000000000032}"
+        If($PowerShellVersion-ge6){
+            Invoke-CimMethod -Namespace 'root\ccm' -ClassName 'sms_client' -MethodName TriggerSchedule -Arguments @{sScheduleID=$trigger}-ErrorAction SilentlyContinue|Out-Null
+        }Else{
+            Invoke-WmiMethod -Namespace 'root\ccm' -Class 'sms_client' -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue|Out-Null
+        }
+    }
+    Function Get-SCCMPolicySendUnsentStateMessages{
+        $trigger="{00000000-0000-0000-0000-000000000111}"
+        If($PowerShellVersion-ge6){
+            Invoke-CimMethod -Namespace 'root\ccm' -ClassName 'sms_client' -MethodName TriggerSchedule -Arguments @{sScheduleID=$trigger}-ErrorAction SilentlyContinue|Out-Null
+        }Else{
+            Invoke-WmiMethod -Namespace 'root\ccm' -Class 'sms_client' -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue|Out-Null
+        }
+    }
+    Function Get-SCCMPolicyScanUpdateSource{
+        $trigger="{00000000-0000-0000-0000-000000000113}"
+        If($PowerShellVersion-ge6){
+            Invoke-CimMethod -Namespace 'root\ccm' -ClassName 'sms_client' -MethodName TriggerSchedule -Arguments @{sScheduleID=$trigger}-ErrorAction SilentlyContinue|Out-Null
+        }Else{
+            Invoke-WmiMethod -Namespace 'root\ccm' -Class 'sms_client' -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue|Out-Null
+        }
+    }
+    Function Get-SCCMPolicyHardwareInventory{
+        $trigger="{00000000-0000-0000-0000-000000000001}"
+        If($PowerShellVersion-ge6){
+            Invoke-CimMethod -Namespace 'root\ccm' -ClassName 'sms_client' -MethodName TriggerSchedule -Arguments @{sScheduleID=$trigger}-ErrorAction SilentlyContinue|Out-Null
+        }Else{
+            Invoke-WmiMethod -Namespace 'root\ccm' -Class 'sms_client' -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue|Out-Null
+        }
+    }
+    Function Get-SCCMPolicyMachineEvaluation{
+        $trigger="{00000000-0000-0000-0000-000000000022}"
+        If($PowerShellVersion-ge6){
+            Invoke-CimMethod -Namespace 'root\ccm' -ClassName 'sms_client' -MethodName TriggerSchedule -Arguments @{sScheduleID=$trigger}-ErrorAction SilentlyContinue|Out-Null
+        }Else{
+            Invoke-WmiMethod -Namespace 'root\ccm' -Class 'sms_client' -Name TriggerSchedule $trigger -ErrorAction SilentlyContinue|Out-Null
+        }
+    }
+    Function Get-Version{
+        $text='ConfigMgr Client Health Version '+$Version
+        Write-Output $text
+        Out-LogFile -Xml $xml -Text $text
+    }
+    <# Trigger codes
+    {00000000-0000-0000-0000-000000000001}Hardware Inventory
+    {00000000-0000-0000-0000-000000000002}Software Inventory 
+    {00000000-0000-0000-0000-000000000003}Discovery Inventory 
+    {00000000-0000-0000-0000-000000000010}File Collection 
+    {00000000-0000-0000-0000-000000000011}IDMIF Collection 
+    {00000000-0000-0000-0000-000000000012}Client Machine Authentication 
+    {00000000-0000-0000-0000-000000000021}Request Machine Assignments 
+    {00000000-0000-0000-0000-000000000022}Evaluate Machine Policies 
+    {00000000-0000-0000-0000-000000000023}Refresh Default MP Task 
+    {00000000-0000-0000-0000-000000000024}LS(Location Service) Refresh Locations Task 
+    {00000000-0000-0000-0000-000000000025}LS(Location Service) Timeout Refresh Task 
+    {00000000-0000-0000-0000-000000000026}Policy Agent Request Assignment(User) 
+    {00000000-0000-0000-0000-000000000027}Policy Agent Evaluate Assignment(User) 
+    {00000000-0000-0000-0000-000000000031}Software Metering Generating Usage Report 
+    {00000000-0000-0000-0000-000000000032}Source Update Message
+    {00000000-0000-0000-0000-000000000037}Clearing proxy settings cache 
+    {00000000-0000-0000-0000-000000000040}Machine Policy Agent Cleanup 
+    {00000000-0000-0000-0000-000000000041}User Policy Agent Cleanup
+    {00000000-0000-0000-0000-000000000042}Policy Agent Validate Machine Policy/Assignment 
+    {00000000-0000-0000-0000-000000000043}Policy Agent Validate User Policy/Assignment 
+    {00000000-0000-0000-0000-000000000051}ReTrying/Refreshing certificates in AD on MP 
+    {00000000-0000-0000-0000-000000000061}Peer DP Status reporting 
+    {00000000-0000-0000-0000-000000000062}Peer DP Pending package check schedule 
+    {00000000-0000-0000-0000-000000000063}SUM Updates install schedule 
+    {00000000-0000-0000-0000-000000000071}NAP action 
+    {00000000-0000-0000-0000-000000000101}Hardware Inventory Collection Cycle 
+    {00000000-0000-0000-0000-000000000102}Software Inventory Collection Cycle 
+    {00000000-0000-0000-0000-000000000103}Discovery Data Collection Cycle 
+    {00000000-0000-0000-0000-000000000104}File Collection Cycle 
+    {00000000-0000-0000-0000-000000000105}IDMIF Collection Cycle 
+    {00000000-0000-0000-0000-000000000106}Software Metering Usage Report Cycle 
+    {00000000-0000-0000-0000-000000000107}Windows Installer Source List Update Cycle 
+    {00000000-0000-0000-0000-000000000108}Software Updates Assignments Evaluation Cycle 
+    {00000000-0000-0000-0000-000000000109}Branch Distribution Point Maintenance Task 
+    {00000000-0000-0000-0000-000000000110}DCM policy 
+    {00000000-0000-0000-0000-000000000111}Send Unsent State Message 
+    {00000000-0000-0000-0000-000000000112}State System policy cache cleanout 
+    {00000000-0000-0000-0000-000000000113}Scan by Update Source 
+    {00000000-0000-0000-0000-000000000114}Update Store Policy 
+    {00000000-0000-0000-0000-000000000115}State system policy bulk send high
+    {00000000-0000-0000-0000-000000000116}State system policy bulk send low 
+    {00000000-0000-0000-0000-000000000120}AMT Status Check Policy 
+    {00000000-0000-0000-0000-000000000121}Application manager policy action 
+    {00000000-0000-0000-0000-000000000122}Application manager user policy action
+    {00000000-0000-0000-0000-000000000123}Application manager global evaluation action 
+    {00000000-0000-0000-0000-000000000131}Power management start summarizer
+    {00000000-0000-0000-0000-000000000221}Endpoint deployment reevaluate 
+    {00000000-0000-0000-0000-000000000222}Endpoint AM policy reevaluate 
+    {00000000-0000-0000-0000-000000000223}External event detection
+    #>
+    Function Test-SQLConnection{   
+        $SQLServer=Get-XMLConfigSQLServer
+        $Database='ClientHealth'
+        $FileLogLevel=((Get-XMLConfigLogginLevel).ToString()).ToLower()
+        $ConnectionString="Server={0};Database={1};Integrated Security=True;" -f $SQLServer,$Database
+        Try{
+            $sqlConnection=New-Object System.Data.SqlClient.SqlConnection $ConnectionString;
+            $sqlConnection.Open();
+            $sqlConnection.Close();
+            $obj=$true;
+        }Catch{
+            $text="Error connecting to SQLDatabase $Database on SQL Server $SQLServer"
+            Write-Error -Message $text
+            If(!($FileLogLevel -like "clientinstall")){
+                Out-LogFile -Xml $xml -Text $text
+            }
+            $obj=$false;
+        }Finally{
+            Write-Output $obj
+        }
+    }
+    # Invoke-SqlCmd2 - Created by Chad Miller
+    Function Invoke-Sqlcmd2{[CmdletBinding()]Param([Parameter(Position=0, Mandatory=$true)][string]$ServerInstance,[Parameter(Position=1, Mandatory=$false)][string]$Database,[Parameter(Position=2, Mandatory=$false)][string]$Query,[Parameter(Position=3, Mandatory=$false)][string]$Username,[Parameter(Position=4, Mandatory=$false)][string]$Password,[Parameter(Position=5, Mandatory=$false)][Int32]$QueryTimeout=600,[Parameter(Position=6, Mandatory=$false)][Int32]$ConnectionTimeout=15,[Parameter(Position=7, Mandatory=$false)][ValidateScript({test-path $_})][string]$InputFile,[Parameter(Position=8, Mandatory=$false)][ValidateSet("DataSet", "DataTable", "DataRow")][string]$As="DataRow") 
+        If($InputFile){
+            $filePath=$(resolve-path $InputFile).path 
+            $Query=[System.IO.File]::ReadAllText("$filePath") 
+        }
+        $conn=new-object System.Data.SqlClient.SQLConnection 
+        If($Username){
+            $ConnectionString="Server={0};Database={1};User ID={2};Password={3};Trusted_Connection=False;Connect Timeout={4}" -f $ServerInstance,$Database,$Username,$Password,$ConnectionTimeout
+        }Else{
+            $ConnectionString="Server={0};Database={1};Integrated Security=True;Connect Timeout={2}" -f $ServerInstance,$Database,$ConnectionTimeout
+        }
+        $conn.ConnectionString=$ConnectionString 
+        #Following EventHandler is used for PRINT and RAISERROR T-SQL statements. Executed when -Verbose Parameter specified by caller 
+        If($PSBoundParameters.Verbose){
+            $conn.FireInfoMessageEventOnUserErrors=$true 
+            $handler=[System.Data.SqlClient.SqlInfoMessageEventHandler]{Write-Verbose "$($_)"}
+            $conn.add_InfoMessage($handler) 
+        }
+        $conn.Open() 
+        $cmd=new-object system.Data.SqlClient.SqlCommand($Query,$conn) 
+        $cmd.CommandTimeout=$QueryTimeout 
+        $ds=New-Object system.Data.DataSet 
+        $da=New-Object system.Data.SqlClient.SqlDataAdapter($cmd) 
+        [void]$da.fill($ds) 
+        $conn.Close() 
+        Switch($As){
+            'DataSet'  {Write-Output($ds)}
+            'DataTable'{Write-Output($ds.Tables)}
+            'DataRow'  {Write-Output($ds.Tables[0])}
+        }
+    }
+    # Gather info about the computer
+    Function Get-Info{
+        If($PowerShellVersion-ge6){
+            $OS=Get-CimInstance Win32_OperatingSystem
+            $ComputerSystem=Get-CimInstance Win32_ComputerSystem
+            If($ComputerSystem.Manufacturer -like 'Lenovo'){
+                $Model=(Get-CimInstance Win32_ComputerSystemProduct).Version
+            }Else{
+                $Model=$ComputerSystem.Model
+            }
+        }Else{
+            $OS=Get-WmiObject Win32_OperatingSystem
+            $ComputerSystem=Get-WmiObject Win32_ComputerSystem
+            If($ComputerSystem.Manufacturer -like 'Lenovo'){
+                $Model=(Get-WmiObject Win32_ComputerSystemProduct).Version
+            }Else{
+                $Model=$ComputerSystem.Model
+            }
+        }
+        $obj=New-Object PSObject -Property @{
+        Hostname=$ComputerSystem.Name;
+        Manufacturer=$ComputerSystem.Manufacturer
+        Model=$Model
+        Operatingsystem=$OS.Caption;
+        Architecture=$OS.OSArchitecture;
+        Build=$OS.BuildNumber;
+        InstallDate=Get-SmallDateTime -Date($OS.ConvertToDateTime($OS.InstallDate))
+        LastLoggedOnUser=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\').LastLoggedOnUser;
+        }
+        $obj=$obj
+        Write-Output $obj
+    }
+    # Start Getters - XML config file
+    Function Get-LocalFilesPath{
+        $obj=$Xml.Configuration.LocalFiles
+        $obj=$ExecutionContext.InvokeCommand.ExpandString($obj)
+        If($obj-eq$null){
+            $obj=Join-path "$env:SystemDrive\ClientHealth"
+        }
+        Return $obj
+    }
+    Function Get-XMLConfigClientVersion{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'Version'}|Select-Object -ExpandProperty '#text'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientSitecode{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'SiteCode'}|Select-Object -ExpandProperty '#text'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientDomain{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'Domain'}|Select-Object -ExpandProperty '#text'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientAutoUpgrade{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'AutoUpgrade'}|Select-Object -ExpandProperty '#text'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientMaxLogSize{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'Log'}|Select-Object -ExpandProperty 'MaxLogSize'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientMaxLogHistory{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'Log'}|Select-Object -ExpandProperty 'MaxLogHistory'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientMaxLogSizeEnabled{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'Log'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientCache{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'CacheSize'}|Select-Object -ExpandProperty 'Value'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientCacheDeleteOrphanedData{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'CacheSize'}|Select-Object -ExpandProperty 'DeleteOrphanedData'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientCacheEnable{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'CacheSize'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigClientShare{
+        $obj=$Xml.Configuration.Client|Where-Object{$_.Name -like 'Share'}|Select-Object -ExpandProperty '#text' -ErrorAction SilentlyContinue
+        If(!($obj)){
+            $obj=$global:ScriptPath
+        }#If Client share is empty, default to the script folder.
+        Write-Output $obj
+    }
+    Function Get-XMLConfigUpdatesShare{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'Updates'}|Select-Object -ExpandProperty 'Share'
+        If(!($obj)){
+            $obj=Join-Path $global:ScriptPath "Updates"
+        }
+        Return $obj
+    }
+    Function Get-XMLConfigUpdatesEnable{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'Updates'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigUpdatesFix{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'Updates'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigLoggingShare{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'File'}|Select-Object -ExpandProperty 'Share'
+        $obj=$ExecutionContext.InvokeCommand.ExpandString($obj)
+        Return $obj
+    }
+    Function Get-XMLConfigLoggingLocalFile{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'File'}|Select-Object -ExpandProperty 'LocalLogFile'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigLoggingEnable{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'File'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigLoggingMaxHistory{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'File'}|Select-Object -ExpandProperty 'MaxLogHistory'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigLogginLevel{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'File'}|Select-Object -ExpandProperty 'Level'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigLoggingTimeFormat{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'Time'}|Select-Object -ExpandProperty 'Format'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigPendingRebootApp{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'PendingReboot'}|Select-Object -ExpandProperty 'StartRebootApplication'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigMaxRebootDays{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'MaxRebootDays'}|Select-Object -ExpandProperty 'Days'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRebootApplication{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'RebootApplication'}|Select-Object -ExpandProperty 'Application'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRebootApplicationEnable{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'RebootApplication'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigDNSCheck{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'DNSCheck'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigCcmSQLCELog{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'CcmSQLCELog'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigDNSFix{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'DNSCheck'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigDrivers{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'Drivers'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigPatchLevel{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'PatchLevel'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigOSDiskFreeSpace{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'OSDiskFreeSpace'}|Select-Object -ExpandProperty '#text'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigHardwareInventoryEnable{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'HardwareInventory'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigHardwareInventoryFix{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'HardwareInventory'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigSoftwareMeteringEnable{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'SoftwareMetering'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigSoftwareMeteringFix{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'SoftwareMetering'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigHardwareInventoryDays{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'HardwareInventory'}|Select-Object -ExpandProperty 'Days'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRemediationAdminShare{
+        $obj=$Xml.Configuration.Remediation|Where-Object{$_.Name -like 'AdminShare'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRemediationClientProvisioningMode{
+        $obj=$Xml.Configuration.Remediation|Where-Object{$_.Name -like 'ClientProvisioningMode'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRemediationClientStateMessages{
+        $obj=$Xml.Configuration.Remediation|Where-Object{$_.Name -like 'ClientStateMessages'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRemediationClientWUAHandler{
+        $obj=$Xml.Configuration.Remediation|Where-Object{$_.Name -like 'ClientWUAHandler'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRemediationClientWUAHandlerDays{
+        $obj=$Xml.Configuration.Remediation|Where-Object{$_.Name -like 'ClientWUAHandler'}|Select-Object -ExpandProperty 'Days'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigBITSCheck{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'BITSCheck'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigBITSCheckFix{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'BITSCheck'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigWMI{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'WMI'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigWMIRepairEnable{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'WMI'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRefreshComplianceState{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'RefreshComplianceState'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRefreshComplianceStateDays{
+        $obj=$Xml.Configuration.Option|Where-Object{$_.Name -like 'RefreshComplianceState'}|Select-Object -ExpandProperty 'Days'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigRemediationClientCertificate{
+        $obj=$Xml.Configuration.Remediation|Where-Object{$_.Name -like 'ClientCertificate'}|Select-Object -ExpandProperty 'Fix'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigSQLServer{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'SQL'}|Select-Object -ExpandProperty 'Server'
+        Write-Output $obj
+    }
+    Function Get-XMLConfigSQLLoggingEnable{
+        $obj=$Xml.Configuration.Log|Where-Object{$_.Name -like 'SQL'}|Select-Object -ExpandProperty 'Enable'
+        Write-Output $obj
+    }
+    # End Getters - XML config file
+    Function GetComputerInfo{
+        $info=Get-Info|Select-Object HostName, OperatingSystem, Architecture, Build, InstallDate, Manufacturer, Model, LastLoggedOnUser
+        #$text='Computer info'+"`n"
+        $text='Hostname: '+$info.HostName
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='Operatingsystem: '+$info.OperatingSystem
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='Architecture: '+$info.Architecture
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='Build: '+$info.Build
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='Manufacturer: '+$info.Manufacturer
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='Model: '+$info.Model
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='InstallDate: '+$info.InstallDate
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+        $text='LastLoggedOnUser: '+$info.LastLoggedOnUser
+        Write-Output $text
+        #Out-LogFile -Xml $xml $text
+    }
+    Function Test-ConfigMgrHealthLogging{
+        # Verifies that logfiles are not bigger than max history
+        $localLogging=(Get-XMLConfigLoggingLocalFile).ToLower()
+        If($localLogging-eq"true"){
+            $clientpath=Get-LocalFilesPath
+            $logfile="$clientpath\ClientHealth.log"
+            Test-LogFileHistory -Logfile $logfile
+        }
+        $fileshareLogging=(Get-XMLConfigLoggingEnable).ToLower()
+        If($fileshareLogging-eq"true"){
+            $logfile=Get-LogFileName
+            Test-LogFileHistory -Logfile $logfile
+        }
+    }
+    Function CleanUp{
+        $clientpath=(Get-LocalFilesPath).ToLower()
+        $forbidden="$env:SystemDrive", "$env:SystemDrive\", "$env:SystemDrive\windows", "$env:SystemDrive\windows\"
+        $NoDelete=$false
+        ForEach($item in $forbidden){
+            If($clientpath -like $item){
+                $NoDelete=$true
+            }
+        }
+        If(((Test-Path "$clientpath\Temp" -ErrorAction SilentlyContinue)-eq$True)-and($NoDelete-eq$false)){
+            Write-Verbose "Cleaning up temporary files in $clientpath\ClientHealth"
+            Remove-Item "$clientpath\Temp" -Recurse -Force|Out-Null
+        }
+        $LocalLogging=((Get-XMLConfigLoggingLocalFile).ToString()).ToLower()
+        If(($LocalLogging-ne"true")-and($NoDelete-eq$false)){
+            Write-Verbose "Local logging disabled. Removing $clientpath\ClientHealth"
+            Remove-Item "$clientpath\Temp" -Recurse -Force|Out-Null
+        }
+    }
+    Function New-LogObject{
+        # Write-Verbose "Start New-LogObject"
+        If($PowerShellVersion-ge6){
+            $OS=Get-CimInstance -class Win32_OperatingSystem
+            $CS=Get-CimInstance -class Win32_ComputerSystem
+            If($CS.Manufacturer -like 'Lenovo'){
+                $Model=(Get-CimInstance Win32_ComputerSystemProduct).Version
+            }Else{
+                $Model=$CS.Model
+            }
+        }Else{
+            $OS=Get-WmiObject -class Win32_OperatingSystem
+            $CS=Get-WmiObject -class Win32_ComputerSystem
+            If($CS.Manufacturer -like 'Lenovo'){
+                $Model=(Get-WmiObject Win32_ComputerSystemProduct).Version
+            }Else{
+                $Model=$CS.Model
+            }
+        }
+        # Handles different OS languages
+        $Hostname=Get-Computername
+        $OperatingSystem=$OS.Caption
+        $Architecture=($OS.OSArchitecture-replace('([^0-9])(\.*)', ''))+'-Bit'
+        $Build=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion').BuildLabEx
+        $Manufacturer=$CS.Manufacturer
+        $Model=$Model
+        $ClientVersion='Unknown'
+        $Sitecode=Get-Sitecode
+        $Domain=Get-Domain
+        [int]$MaxLogSize=0
+        $MaxLogHistory=0
+        If($PowerShellVersion-ge6){
+            $InstallDate=Get-SmallDateTime -Date($OS.InstallDate)
+        }Else{
+            $InstallDate=Get-SmallDateTime -Date($OS.ConvertToDateTime($OS.InstallDate))
+        }
+        $InstallDate=$InstallDate-replace'\.', ':'
+        $LastLoggedOnUser=(Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\').LastLoggedOnUser
+        $CacheSize=Get-ClientCache
+        $Services='Unknown'
+        $Updates='Unknown'
+        $DNS='Unknown'
+        $Drivers='Unknown'
+        $ClientCertificate='Unknown'
+        $PendingReboot='Unknown'
+        $RebootApp='Unknown'
+        If($PowerShellVersion-ge6){
+            $LastBootTime=Get-SmallDateTime -Date($OS.LastBootUpTime)
+        }Else{
+            $LastBootTime=Get-SmallDateTime -Date($OS.ConvertToDateTime($OS.LastBootUpTime))
+        }
+        $LastBootTime=$LastBootTime-replace'\.', ':'
+        $OSDiskFreeSpace=Get-OSDiskFreeSpace
+        $AdminShare='Unknown'
+        $ProvisioningMode='Unknown'
+        $StateMessages='Unknown'
+        $WUAHandler='Unknown'
+        $WMI='Unknown'
+        $RefreshComplianceState=Get-SmallDateTime
+        $Updates='Unknown'
+        $Services='Unknown'
+        $smallDateTime=Get-SmallDateTime
+        $smallDateTime=$smallDateTime-replace'\.', ':'
+        [float]$PSVersion=[float]$psVersion=[float]$PSVersionTable.PSVersion.Major+([float]$PSVersionTable.PSVersion.Minor/10)
+        [int]$PSBuild=[int]$PSVersionTable.PSVersion.Build
+        If($PSBuild-le0){
+            $PSBuild=$null
+        }
+        $UBR=Get-UBR
+        $BITS=$null
+        $obj=New-Object PSObject -Property @{
+        Hostname=$Hostname
+        Operatingsystem=$OperatingSystem
+        Architecture=$Architecture
+        Build=$Build
+        Manufacturer=$Manufacturer
+        Model=$Model
+        InstallDate=$InstallDate
+        OSUpdates=$null
+        LastLoggedOnUser=$LastLoggedOnUser
+        ClientVersion=$ClientVersion
+        PSVersion=$PSVersion
+        PSBuild=$PSBuild
+        Sitecode=$Sitecode
+        Domain=$Domain
+        MaxLogSize=$MaxLogSize
+        MaxLogHistory=$MaxLogHistory
+        CacheSize=$CacheSize
+        ClientCertificate=$Certificate
+        ProvisioningMode=$ProvisioningMode
+        DNS=$DNS
+        Drivers=$Drivers
+        Updates=$Updates
+        PendingReboot=$PendingReboot
+        LastBootTime=$LastBootTime
+        OSDiskFreeSpace=$OSDiskFreeSpace
+        Services=$Services
+        AdminShare=$AdminShare
+        StateMessages=$StateMessages
+        WUAHandler=$WUAHandler
+        WMI=$WMI
+        RefreshComplianceState=$RefreshComplianceState
+        ClientInstalled=$null
+        Version=$Version
+        Timestamp=$smallDateTime
+        HWInventory=$null
+        SWMetering=$null
+        BITS=$BITS
+        PatchLevel=$UBR
+        ClientInstalledReason=$null
+        RebootApp=$RebootApp
+        }
+        Write-Output $obj
+        # Write-Verbose "End New-LogObject"
+    }
+    Function Get-SmallDateTime{Param([Parameter(Mandatory=$false)]$Date)
+        #Write-Verbose "Start Get-SmallDateTime"
+        $UTC=(Get-XMLConfigLoggingTimeFormat).ToLower()
+        If($null-ne$Date){
+            If($UTC-eq"utc"){
+                $obj=(Get-UTCTime -DateTime $Date).ToString("yyyy-MM-dd HH:mm:ss")
+            }Else{
+                $obj=($Date).ToString("yyyy-MM-dd HH:mm:ss")
+            }
+        }Else{
+            $obj=Get-DateTime
+        }
+        $obj=$obj-replace'\.', ':'
+        Write-Output $obj
+        #Write-Verbose "End Get-SmallDateTime"
+    }
+    # Test some values are whole numbers before attempting to insert/update database
+    Function Test-ValuesBeforeLogUpdate{
+        Write-Verbose "Start Test-ValuesBeforeLogUpdate"
+        [int]$Log.MaxLogSize=[Math]::Round($Log.MaxLogSize)
+        [int]$Log.MaxLogHistory=[Math]::Round($Log.MaxLogHistory)
+        [int]$Log.PSBuild=[Math]::Round($Log.PSBuild)
+        [int]$Log.CacheSize=[Math]::Round($Log.CacheSize)
+        Write-Verbose "End Test-ValuesBeforeLogUpdate"
+    }
+    Function Update-SQL{Param([Parameter(Mandatory=$true)]$Log,[Parameter(Mandatory=$false)]$Table)
+        Write-Verbose "Start Update-SQL"
+        Test-ValuesBeforeLogUpdate
+        $SQLServer=Get-XMLConfigSQLServer
+        $Database='ClientHealth'
+        $table='dbo.Clients'
+        $smallDateTime=Get-SmallDateTime
+        If($null-ne$log.OSUpdates){
+            # UPDATE
+            $q1="OSUpdates='"+$log.OSUpdates+"', "
+            # INSERT INTO
+            $q2="OSUpdates, "
+            # VALUES
+            $q3="'"+$log.OSUpdates+"', "
+        }Else{
+            $q1=$null
+            $q2=$null
+            $q3=$null
+        }
+        If($null-ne$log.ClientInstalled){
+            # UPDATE
+            $q10="ClientInstalled='"+$log.ClientInstalled+"', "
+            # INSERT INTO
+            $q20="ClientInstalled, "
+            # VALUES
+            $q30="'"+$log.ClientInstalled+"', "
+        }Else{
+            $q10=$null
+            $q20=$null
+            $q30=$null
+        }
+        $query="begin tran
+        if exists(SELECT * FROM $table WITH(updlock,serializable) WHERE Hostname='"+$log.Hostname+"')
+        begin
+        UPDATE $table SET Operatingsystem='"+$log.Operatingsystem+"', Architecture='"+$log.Architecture+"', Build='"+$log.Build+"', Manufacturer='"+$log.Manufacturer+"', Model='"+$log.Model+"', InstallDate='"+$log.InstallDate+"', $q1 LastLoggedOnUser='"+$log.LastLoggedOnUser+"', ClientVersion='"+$log.ClientVersion+"', PSVersion='"+$log.PSVersion+"', PSBuild='"+$log.PSBuild+"', Sitecode='"+$log.Sitecode+"', Domain='"+$log.Domain+"', MaxLogSize='"+$log.MaxLogSize+"', MaxLogHistory='"+$log.MaxLogHistory+"', CacheSize='"+$log.CacheSize+"', ClientCertificate='"+$log.ClientCertificate+"', ProvisioningMode='"+$log.ProvisioningMode+"', DNS='"+$log.DNS+"', Drivers='"+$log.Drivers+"', Updates='"+$log.Updates+"', PendingReboot='"+$log.PendingReboot+"', LastBootTime='"+$log.LastBootTime+"', OSDiskFreeSpace='"+$log.OSDiskFreeSpace+"', Services='"+$log.Services+"', AdminShare='"+$log.AdminShare+"', StateMessages='"+$log.StateMessages+"', WUAHandler='"+$log.WUAHandler+"', WMI='"+$log.WMI+"', RefreshComplianceState='"+$log.RefreshComplianceState+"', HWInventory='"+$log.HWInventory+"', Version='"+$Version+"', $q10 Timestamp='"+$smallDateTime+"', SWMetering='"+$log.SWMetering+"', BITS='"+$log.BITS+"', PatchLevel='"+$Log.PatchLevel+"', ClientInstalledReason='"+$log.ClientInstalledReason+"'
+        WHERE Hostname='"+$log.Hostname+"'
+        end
+        Else
+        begin
+        INSERT INTO $table(Hostname, Operatingsystem, Architecture, Build, Manufacturer, Model, InstallDate, $q2 LastLoggedOnUser, ClientVersion, PSVersion, PSBuild, Sitecode, Domain, MaxLogSize, MaxLogHistory, CacheSize, ClientCertificate, ProvisioningMode, DNS, Drivers, Updates, PendingReboot, LastBootTime, OSDiskFreeSpace, Services, AdminShare, StateMessages, WUAHandler, WMI, RefreshComplianceState, HWInventory, Version, $q20 Timestamp, SWMetering, BITS, PatchLevel, ClientInstalledReason)
+        VALUES('"+$log.Hostname+"', '"+$log.Operatingsystem+"', '"+$log.Architecture+"', '"+$log.Build+"', '"+$log.Manufacturer+"', '"+$log.Model+"', '"+$log.InstallDate+"', $q3 '"+$log.LastLoggedOnUser+"', '"+$log.ClientVersion+"', '"+$log.PSVersion+"', '"+$log.PSBuild+"', '"+$log.Sitecode+"', '"+$log.Domain+"', '"+$log.MaxLogSize+"', '"+$log.MaxLogHistory+"', '"+$log.CacheSize+"', '"+$log.ClientCertificate+"', '"+$log.ProvisioningMode+"', '"+$log.DNS+"', '"+$log.Drivers+"', '"+$log.Updates+"', '"+$log.PendingReboot+"', '"+$log.LastBootTime+"', '"+$log.OSDiskFreeSpace+"', '"+$log.Services+"', '"+$log.AdminShare+"', '"+$log.StateMessages+"', '"+$log.WUAHandler+"', '"+$log.WMI+"', '"+$log.RefreshComplianceState+"', '"+$log.HWInventory+"', '"+$log.Version+"', $q30 '"+$smallDateTime+"', '"+$log.SWMetering+"', '"+$log.BITS+"', '"+$Log.PatchLevel+"', '"+$Log.ClientInstalledReason+"')
+        end
+        commit tran"
+        Try{
+            Invoke-SqlCmd2 -ServerInstance $SQLServer -Database $Database -Query $query
+        }Catch{
+            $ErrorMessage=$_.Exception.Message
+            $text="Error updating SQL with the following query: $transactSQL. Error: $ErrorMessage"
+            Write-Error $text
+            Out-LogFile -Xml $Xml -Text "ERROR Insert/Update SQL. SQL Query: $query `nSQL Error: $ErrorMessage"
+        }
+        Write-Verbose "End Update-SQL"
+    }
+    Function Update-LogFile{Param([Parameter(Mandatory=$true)]$Log,[Parameter(Mandatory=$false)]$Mode)
+        # Start the logfile
+        Write-Verbose "Start Update-LogFile"
+        #$share=Get-XMLConfigLoggingShare
+        Test-ValuesBeforeLogUpdate
+        # $logfile=$logfile=Get-LogFileName
+        $logfile=Get-LogFileName
+        Test-LogFileHistory -Logfile $logfile
+        $text="<--- ConfigMgr Client Health Check starting --->"
+        $text+=$log|Select-Object Hostname, Operatingsystem, Architecture, Build, Model, InstallDate, OSUpdates, LastLoggedOnUser, ClientVersion, PSVersion, PSBuild, SiteCode, Domain, MaxLogSize, MaxLogHistory, CacheSize, Certificate, ProvisioningMode, DNS, PendingReboot, LastBootTime, OSDiskFreeSpace, Services, AdminShare, StateMessages, WUAHandler, WMI, RefreshComplianceState, ClientInstalled, Version, Timestamp, HWInventory, SWMetering, BITS, PatchLevel, ClientInstalledReason|Out-String
+        $text=$text.replace("`t","")
+        $text=$text.replace("  ","")
+        $text=$text.replace(" :",":")
+        $text=$text-creplace'(?m)^\s*\r?\n',''
+        If($Mode-eq'Local'){
+            Out-LogFile -Xml $xml -Text $text -Mode $Mode
+        }ElseIf($Mode-eq'ClientInstalledFailed'){
+            Out-LogFile -Xml $xml -Text $text -Mode $Mode
+        }Else{
+            Out-LogFile -Xml $xml -Text $text
+        }
+        Write-Verbose "End Update-LogFile"
+    }
+    #endregion
+    # Set default restart values to false
+    $newinstall=$false
+    $restartCCMExec=$false
+    $Reinstall=$false
+    # Build the ConfigMgr Client Install Property string
+    $propertyString=""
+    ForEach($property in $Xml.Configuration.ClientInstallProperty){
+        $propertyString=$propertyString+$property
+        $propertyString=$propertyString+' '
+    }
+    $clientCacheSize=Get-XMLConfigClientCache
+    $clientInstallProperties=$propertyString+"SMSCACHESIZE=$clientCacheSize"
+    $clientAutoUpgrade=(Get-XMLConfigClientAutoUpgrade).ToLower()
+    $AdminShare=Get-XMLConfigRemediationAdminShare
+    $ClientProvisioningMode=Get-XMLConfigRemediationClientProvisioningMode
+    $ClientStateMessages=Get-XMLConfigRemediationClientStateMessages
+    $ClientWUAHandler=Get-XMLConfigRemediationClientWUAHandler
+    $LogShare=Get-XMLConfigLoggingShare
+    # Create a DataTable to store all changes to log files to be processed later. This to prevent false positives to remediate the next time script runs if error is already remediated.
+    $SCCMLogJobs=New-Object System.Data.DataTable
+    [Void]$SCCMLogJobs.Columns.Add("File")
+    [Void]$SCCMLogJobs.Columns.Add("Text")
+}
+Process{
+    Write-Verbose "Starting precheck. Determing if script will run or not."
+    # Veriy script is running with administrative priveleges.
+    If(-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")){
+        $text='ERROR: Powershell not running as Administrator! Client Health aborting.'
+        Out-LogFile -Xml $Xml -Text $text
+        Write-Error $text
+        Exit 1
+    }Else{
+        $StartupText1="PowerShell version: "+$PSVersionTable.PSVersion+". Script executing with Administrator rights."
+        Write-Host $StartupText1
+        Write-Verbose "Determing if a task sequence is running."
+        Try{
+            $tsenv=New-Object -COMObject Microsoft.SMS.TSEnvironment|Out-Null
+        }Catch{
+            $tsenv=$null
+        }
+        If($tsenv-ne$null){
+            $TSName=$tsenv.Value("_SMSTSAdvertID") 
+            Write-Host "Task sequence $TSName is active executing on computer. ConfigMgr Client Health will not execute."
+            Exit 1
+        }Else{
+            $StartupText2="ConfigMgr Client Health "+$Version+" starting."
+            Write-Host $StartupText2
+        }
+    }
+    $LocalLogging=((Get-XMLConfigLoggingLocalFile).ToString()).ToLower()
+    $FileLogging=((Get-XMLConfigLoggingEnable).ToString()).ToLower()
+    $FileLogLevel=((Get-XMLConfigLogginLevel).ToString()).ToLower()
+    $SQLLogging=((Get-XMLConfigSQLLoggingEnable).ToString()).ToLower()
+    $RegisTryKey="HKLM:\Software\ConfigMgrClientHealth"
+    $LastRunRegisTryValueName="LastRun"
+    #Get the last run from the regisTry, defaulting to the minimum date value if the script has never ran.
+    Try{
+        [datetime]$LastRun=Get-RegisTryValue -Path $RegisTryKey -Name $LastRunRegisTryValueName
+    }Catch{
+        $LastRun=[datetime]::MinValue
+    }
+    Write-Output "Script last ran: $($LastRun)"
+    Write-Verbose "Testing if log files are bigger than max history for logfiles."
+    Test-ConfigMgrHealthLogging
+    # Create the log object containing the result of health check
+    $Log=New-LogObject
+    Write-Verbose 'Testing SQL Server connection'
+    If(($SQLLogging -like 'true')-and((Test-SQLConnection)-eq$false)){
+        # Failed to create SQL connection. Logging this error to fileshare and aborting script.
+        #Exit 1
+    }
+    Write-Verbose 'Validating WMI is not corrupt...'
+    $WMI=Get-XMLConfigWMI
+    If($WMI -like 'True'){
+        Write-Verbose 'Checking if WMI is corrupt. Will reinstall configmgr client if WMI is rebuilt.'
+        If((Test-WMI -log $Log)-eq$true){
+            $reinstall=$true
+            New-ClientInstalledReason -Log $Log -Message "Corrupt WMI."
+        }
+    }
+    Write-Verbose 'Determining if compliance state should be resent...'
+    $RefreshComplianceState=Get-XMLConfigRefreshComplianceState
+    If($RefreshComplianceState -like 'True'){
+        $RefreshComplianceStateDays=Get-XMLConfigRefreshComplianceStateDays
+        Write-Verbose "Checking if compliance state should be resent after $($RefreshComplianceStateDays) days."
+        Test-RefreshComplianceState -Days $RefreshComplianceStateDays -RegisTryKey $RegisTryKey  -log $Log
+    }
+    Write-Verbose 'Testing if ConfigMgr client is installed. Installing if not.'
+    Test-ConfigMgrClient -Log $Log
+    Write-Verbose 'Validating if ConfigMgr client is running the minimum version...'
+    If((Test-ClientVersion -Log $log)-eq$true){
+        If($clientAutoUpgrade -like 'true'){
+            $reinstall=$true
+            New-ClientInstalledReason -Log $Log -Message "Below minimum verison."
+        }
+    }
+    <#
+    Write-Verbose 'Validate that ConfigMgr client do not have CcmSQLCE.log and are not in debug mode'
+    If(Test-CcmSQLCELog-eq$true){
+        # This is a very bad situation. ConfigMgr agent is fubar. Local SDF files are deleted by the test itself, now reinstalling client immediatly. Waiting 10 minutes before continuing with health check.
+        Resolve-Client -Xml $xml -ClientInstallProperties $ClientInstallProperties
+        Start-Sleep -Seconds 600
+    }
+    #>
+    Write-Verbose 'Validating services...'
+    Test-Services -Xml $Xml -log $log
+    Write-Verbose 'Validating SMSTSMgr service is depenent on CCMExec service...'
+    Test-SMSTSMgr
+    Write-Verbose 'Validating ConfigMgr SiteCode...'
+    Test-ClientSiteCode -Log $Log
+    Write-Verbose 'Validating client cache size. Will restart configmgr client if cache size is changed'    
+    $CacheCheckEnabled=Get-XMLConfigClientCacheEnable
+    If($CacheCheckEnabled -like 'True'){
+        $TestClientCacheSzie=Test-ClientCacheSize -Log $Log
+        # This check is now able to set ClientCacheSize without restarting CCMExec service.
+        If($TestClientCacheSzie-eq$true){$restartCCMExec=$false}
+    }
+    If((Get-XMLConfigClientMaxLogSizeEnabled -like 'True')-eq$true){
+        Write-Verbose 'Validating Max CCMClient Log Size...'
+        $TestClientLogSize=Test-ClientLogSize -Log $Log
+        If($TestClientLogSize-eq$true){$restartCCMExec=$true}
+    }
+    Write-Verbose 'Validating CCMClient provisioning mode...'
+    If(($ClientProvisioningMode -like 'True')-eq$true){Test-ProvisioningMode -log $log}
+    Write-Verbose 'Validating CCMClient certificate...'
+    If((Get-XMLConfigRemediationClientCertificate -like 'True')-eq$true){Test-CCMCertificateError -Log $Log}
+    If(Get-XMLConfigHardwareInventoryEnable -like 'True'){Test-SCCMHardwareInventoryScan -Log $log}
+    If(Get-XMLConfigSoftwareMeteringEnable -like 'True'){
+        Write-Verbose "Testing software metering prep driver check"
+        If((Test-SoftwareMeteringPrepDriver -Log $Log)-eq$false){$restartCCMExec=$true}
+    }
+    Write-Verbose 'Validating DNS...'
+    If((Get-XMLConfigDNSCheck -like 'True')-eq$true){Test-DNSConfiguration -Log $log}
+    Write-Verbose 'Validating BITS'
+    If(Get-XMLConfigBITSCheck -like 'True'){
+        If((Test-BITS -Log $Log)-eq$true){
+            #$Reinstall=$true
+        }
+    }
+    If(($ClientWUAHandler -like 'True')-eq$true){
+        Write-Verbose 'Validating Windows Update Scan not broken by bad group policy...'
+        $days=Get-XMLConfigRemediationClientWUAHandlerDays
+        Test-RegisTryPol -Days $days -log $log -StartTime $LastRun
+    }
+    Write-Verbose 'Validating that CCMClient is sending state messages...'
+    If(($ClientStateMessages -like 'True')-eq$true){Test-UpdateStore -log $log}
+    Write-Verbose 'Validating Admin$ and C$ are shared...'
+    If(($AdminShare -like 'True')-eq$true){Test-AdminShare -log $log}
+    Write-Verbose 'Testing that all devices have functional drivers.'
+    If((Get-XMLConfigDrivers -like 'True')-eq$true){Test-MissingDrivers -Log $log}
+    $UpdatesEnabled=Get-XMLConfigUpdatesEnable
+    If($UpdatesEnabled -like 'True'){
+        Write-Verbose 'Validating required updates are installed...'
+        Test-Update -Log $log
+    }
+    Write-Verbose "Validating $env:SystemDrive free diskspace(Only warning, no remediation)..."
+    Test-DiskSpace
+    Write-Verbose 'Getting install date of last OS patch for SQL log'
+    Get-LastInstalledPatches -Log $log
+    Write-Verbose 'Sending unsent state messages if any'
+    Get-SCCMPolicySendUnsentStateMessages
+    Write-Verbose 'Getting Source Update Message policy and policy to trigger scan update source'
+    If($newinstall-eq$false){
+        Get-SCCMPolicySourceUpdateMessage
+        Get-SCCMPolicyScanUpdateSource
+        Get-SCCMPolicySendUnsentStateMessages
+    }
+    Get-SCCMPolicyMachineEvaluation
+    # Restart ConfigMgr client if tagged for restart and no reinstall tag
+    If(($restartCCMExec-eq$true)-and($Reinstall-eq$false)){
+        Write-Output "Restarting service CcmExec..."
+        If($SCCMLogJobs.Rows.Count-ge1){
+            Stop-Service -Name CcmExec
+            Write-Verbose "Processing changes to SCCM logfiles after remediation to prevent remediation again next time script runs."
+            Update-SCCMLogFile
+            Start-Service -Name CcmExec
+        }Else{
+            Restart-Service -Name CcmExec
+        }
+        $Log.MaxLogSize=Get-ClientMaxLogSize
+        $Log.MaxLogHistory=Get-ClientMaxLogHistory
+        $log.CacheSize=Get-ClientCache
+    }
+    # Updating SQL Log object with current version number
+    $log.Version=$Version
+    Write-Verbose 'Cleaning up after healthcheck'
+    CleanUp
+    Write-Verbose 'Validating pending reboot...'
+    Test-PendingReboot -log $log
+    Write-Verbose 'Getting last reboot time'
+    Get-LastReboot -Xml $xml
+    If(Get-XMLConfigClientCacheDeleteOrphanedData -like "true"){
+        Write-Verbose "Removing orphaned ccm client cache items."
+        Remove-CCMOrphanedCache
+    }
+    # Reinstall client if tagged for reinstall and configmgr client is not already installing
+    $proc=Get-Process ccmsetup -ErrorAction SilentlyContinue
+    If(($reinstall-eq$true)-and($null-ne$proc)){
+        Write-Warning "ConfigMgr Client set to reinstall, but ccmsetup.exe is already running."
+    }ElseIf(($Reinstall-eq$true)-and($null-eq$proc)){
+        Write-Verbose 'Reinstalling ConfigMgr Client'
+        Resolve-Client -Xml $Xml -ClientInstallProperties $ClientInstallProperties
+        # Add smalldate timestamp in SQL for when client was installed by Client Health.
+        $log.ClientInstalled=Get-SmallDateTime
+        $Log.MaxLogSize=Get-ClientMaxLogSize
+        $Log.MaxLogHistory=Get-ClientMaxLogHistory
+        $log.CacheSize=Get-ClientCache
+    }
+    # Trigger default Microsoft CM client health evaluation
+    Start-Ccmeval
+    Write-Verbose "End Process"
+}
+End{
+    # Update database and logfile with results
+    #Set the last run.
+    $Date=Get-Date
+    Set-RegisTryValue -Path $RegisTryKey -Name $LastRunRegisTryValueName -Value $Date
+    Write-Output "Setting last ran to $($Date)"
+    If($LocalLogging -like 'true'){
+        Write-Output 'Updating local logfile with results'
+        Update-LogFile -Log $log -Mode 'Local'
+    }
+    If(($FileLogging -like 'true')-and($FileLogLevel -like 'full')){
+        Write-Output 'Updating fileshare logfile with results' 
+        Update-LogFile -Log $log
+    }
+    If(($SQLLogging -like 'true')-and(($Webservice-eq$null))-or($Webservice-eq"")){
+        Write-Output 'Updating SQL database with results'
+        Update-SQL -Log $log
+    }
+    If($Webservice){
+        Write-Output 'Updating SQL database with results using webservice'
+        Update-Webservice -URI $Webservice -Log $Log
+    }
+    Write-Verbose "Client Health script finished"
+}
diff --git a/PowerShell/SCCM_Client_Health/Daily_Servers_Health_Check_Reports/ConfigMgr_Daily_Servers_Health_Check_Reports.html b/PowerShell/SCCM_Client_Health/Daily_Servers_Health_Check_Reports/ConfigMgr_Daily_Servers_Health_Check_Reports.html
new file mode 100644
index 0000000..3393381
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/Daily_Servers_Health_Check_Reports/ConfigMgr_Daily_Servers_Health_Check_Reports.html
@@ -0,0 +1,705 @@
+   <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+    <html xmlns="http://www.w3.org/1999/xhtml">
+    <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    <title></title>
+    <style type="text/css">
+    <!--
+    body {
+            font: 100%/1.4 Verdana, Arial, Helvetica, sans-serIf;
+            background: #FFFFFF;
+            margin: 0;
+            padding: 0;
+            color: #000;
+         }
+    .container {
+            width: 100%;
+            margin: 0 auto;
+            }
+    h1 {
+            font-size: 18px;
+        }
+    h2 {
+            color: #FFF;
+            padding: 0px;
+            margin: 0px;
+            font-size: 14px;
+            background-color: #006400;
+        }
+    h3 {
+            color: #FFF;
+            padding: 0px;
+            margin: 0px;
+            font-size: 14px;
+            background-color: #191970;
+        }
+    h4 {
+            color: #348017;
+            padding: 0px;
+            margin: 0px;
+            font-size: 10px;
+            font-style: italic;
+        }
+    .header {
+            text-align: center;
+        }
+    .container table {
+            width: 100%;
+            font-family: Verdana, Geneva, sans-serIf;
+            font-size: 12px;
+            font-style: normal;
+            font-weight: bold;
+            font-variant: normal;
+            text-align: center;
+            border: 0px solid black;
+            padding: 0px;
+            margin: 0px;
+        }
+    td {
+            font-weight: normal;
+            border: 1px solid grey;
+            width='25%'
+        }
+    th {
+            font-weight: bold;
+            border: 1px solid grey;
+            text-align: center;
+        }
+    -->
+    </style></head>
+    <body>
+    <div class="container">
+    <div class="content">	
+	<table width='100%'><tbody>
+	<tr bgcolor = '#425563'> <td align='center'> <b> 
+	<Font color = 'white'> LAB - ConfigMgr Daily Servers Health Check Reports - Tuesday, February 27, 2018 8:20:36 AM </Font>
+	</b> </td> </tr>
+	</table>
+        <table width='100%'><tbody>
+   	    <tr bgcolor=#01A982> <td> <b> <Font color = 'white'> Servers Availability Details Status </Font> </b> </td> </tr>
+        </table>
+        <table width='100%' border = 0 > <tbody>
+	    <tr bgcolor=#CCCCCC>
+        <td width='5%'>SNo</td>
+        <td width='20%'>ServerName</td>
+        <td width='10%'>IPAddress</td>
+        <td width='20%'>Operating System</td>
+	    <td width='20%'>Domain</td>
+	    <td width='5%'>Status</td>
+	    </tr>
+        </table>
+                            <table width='100%' border = 0 > <tbody>
+	                        <tr>
+                            <td width='5%' align='center' >1</td>
+                            <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                            <td width='10%' align='center'>192.168.1.12</td>
+                            <td width='20%' align='center'>Microsoft Windows Server 2012 R2 Standard</td>
+	                        <td width='20%' align='center'>LAB.Com</td>
+	                        <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                        </tr>
+                            </table>
+                <table width='100%' border = 0 > <tbody>
+	            <tr>
+                <td width='5%' align='center' >2</td>
+				<td width='20%' align='left'>&nbspMP01.LAB.COM</td>
+                <td width='10%' align='center'></td>
+                <td width='20%' align='center'>NA</td>
+	            <td width='20%' align='center'>NA</td>
+	            <td width='5%' align='center' bgcolor='Red'> <Font color ='white'> DNS_Issue </Font> </td>
+	            </tr>
+                </table>
+        <table width='100%'><tbody>
+		<tr bgcolor=#01A982> <td> <b> <Font color = 'white'> Servers Disk Space Status </Font> </b> </td> </tr>
+        </table>
+        <table width='100%' border = 0 > <tbody>
+	    <tr bgcolor=#CCCCCC>
+        <td width='5%'>SNo</td>
+        <td width='20%'>ServerName</td> 
+        <td width='5%'>Drive</td> 
+        <td width='10%'>VolName</td>    
+        <td width='10%'>Total Capacity(GB)</td>
+	    <td width='10%'>Used Capacity(GB)</td>
+        <td width='10%'>Free Space(GB)</td>
+	    <td width='5%'>Free Space%</td>
+        <td width='5%'>Status</td>
+	    </tr>
+        </table>
+                                <table width='100%' border = 0 > <tbody>
+                                <tr align= 'center'>
+                                <td width='5%' align='center' >1</td> 
+								<td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                <td width='5%'>C:</td>    
+                                <td width='10%'>OS</td> 
+                                <td width='10%'>49.66</td>
+                                <td width='10%'>31.46</td>
+	                            <td width='10%'>18.2</td>
+                                <td width='5%'>36.65</td>
+	                            <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                            </tr>
+                                </table>
+                                <table width='100%' border = 0 > <tbody>
+                                <tr align= 'center'>
+                                <td width='5%' align='center' >2</td> 
+								<td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                <td width='5%'>D:</td>    
+                                <td width='10%'>CM</td> 
+                                <td width='10%'>50</td>
+                                <td width='10%'>19.14</td>
+	                            <td width='10%'>30.86</td>
+                                <td width='5%'>61.73</td>
+	                            <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                            </tr>
+                                </table>
+                                <table width='100%' border = 0 > <tbody>
+                                <tr align= 'center'>
+                                <td width='5%' align='center' >3</td> 
+								<td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                <td width='5%'>E:</td>    
+                                <td width='10%'>DP</td> 
+                                <td width='10%'>50</td>
+                                <td width='10%'>15.54</td>
+	                            <td width='10%'>34.46</td>
+                                <td width='5%'>68.92</td>
+	                            <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                            </tr>
+                                </table>
+                                <table width='100%' border = 0 > <tbody>
+                                <tr align= 'center'>
+                                <td width='5%' align='center' >4</td> 
+								<td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                <td width='5%'>F:</td>    
+                                <td width='10%'>Source</td> 
+                                <td width='10%'>50</td>
+                                <td width='10%'>31.89</td>
+	                            <td width='10%'>18.11</td>
+                                <td width='5%'>36.21</td>
+	                            <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                            </tr>
+                                </table>
+                <table width='100%' border = 0 > <tbody>
+                <tr align= 'center'>
+                <td width='5%' align='center' >5</td>
+                <td width='20%' align='left'>&nbspMP01.LAB.COM</td>  
+                <td width='5%'>NA</td>    
+                <td width='10%'>NA</td> 
+                <td width='10%'>NA</td>
+                <td width='10%'>NA</td>
+	            <td width='10%'>NA</td>
+                <td width='5%'>NA</td>
+	            <td width='5%' align='center' bgcolor='Red'> <Font color ='white'> DNS_Issue </Font> </td>
+	            </tr>
+                </table>
+        <table width='100%'><tbody>
+		<tr bgcolor=#01A982> <td> <b> <Font color = 'white'> Servers Management Point Status </Font> </b> </td> </tr>
+        </table>
+        <table width='100%' border = 0 > <tbody>
+	    <tr bgcolor=#CCCCCC>    
+        <td width='5%'>SNo</td>    
+        <td width='20%'>ServerName</td>
+        <td width='10%'>Site Code</td>
+        <td width='10%'>MPCert Status</td>
+	    <td width='10%'>MPCert Code</td>
+        <td width='10%'>MPList Status</td>
+        <td width='10%'>MPList Code</td>	   
+        <td width='5%'>Status</td>
+	    </tr>
+        </table>
+                <table width='100%' border = 0 > <tbody>
+    	        <tr align= 'center'>    
+                <td width='5%'>1</td>
+                <td width='20%' align='left'>&nbspCM01.LAB.COM</td>      
+                <td width='10%'>000</td>    
+                <td width='10%'>OK</td>
+    	        <td width='10%'>200</td>
+                <td width='10%'>OK</td>
+                <td width='10%'>200</td>
+    	        <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+    	        </tr>
+            </table>
+                <table width='100%' border = 0 > <tbody>
+    	        <tr align= 'center'>    
+                <td width='5%'>2</td>
+                <td width='20%' align='left'>&nbspMP01.LAB.COM</td>      
+                <td width='10%'>000</td>    
+                <td width='10%'></td>
+    	        <td width='10%'>0</td>
+                <td width='10%'>OK</td>
+                <td width='10%'>200</td>
+    	        <td width='5%' align='center' bgcolor='Red'> <Font color ='white'> Critical </Font> </td>
+    	        </tr>
+            </table>
+        <table width='100%'><tbody>
+		<tr bgcolor=#01A982> <td> <b> <Font color = 'white'> Servers Components Services Status </Font> </b> </td> </tr>
+        </table>
+        <table width='100%' border = 0 > <tbody>
+	    <tr bgcolor=#CCCCCC>
+        <td width='5%'>SNo</td>
+        <td width='20%'>ServerName</td>
+        <td width='30%'>Display Name</td>
+        <td width='15%'>Name</td>
+	    <td width='5%'>StartMode</td>
+	    <td width='5%'>Status</td>
+	    </tr>
+        </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>1</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>IIS Admin Service</td>
+                                    <td width='15%'>IISADMIN</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>2</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>World Wide Web Publishing Service</td>
+                                    <td width='15%'>W3SVC</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>3</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>Windows Management Instrumentation</td>
+                                    <td width='15%'>Winmgmt</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>4</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SMS Agent Host</td>
+                                    <td width='15%'>CcmExec</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>5</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SMS_EXECUTIVE</td>
+                                    <td width='15%'>SMS_EXECUTIVE</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>6</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SMS_SITE_COMPONENT_MANAGER</td>
+                                    <td width='15%'>SMS_SITE_COMPONENT_MANAGER</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0> <tbody>
+	                                <tr align='Left'>
+                                    <td width='5%' align='center'>7</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SMS_SITE_VSS_WRITER</td>
+                                    <td width='15%'>SMS_SITE_VSS_WRITER</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                <table width='100%' border = 0 > <tbody>
+	            <tr align= 'Left'>
+                <td width='5%' align='center' >8</td>
+                <td width='20%' align='left'>&nbspMP01.LAB.COM</td>
+                <td width='30%'>NA</td>
+                <td width='15%'>NA</td>
+                <td width='5%'>NA</td>
+	            <td width='5%' align='center' bgcolor='Red'> <Font color ='white'> DNS_Issue </Font> </td>
+	            </tr>
+                </table>
+        <table width='100%'><tbody>
+		<tr bgcolor=#01A982> <td> <b> <Font color = 'white'> SQL Server Services Status </Font> </b> </td> </tr>
+        </table>
+        <table width='100%' border = 0 > <tbody>
+	    <tr bgcolor=#CCCCCC>
+        <td width='5%'>SNo</td>
+        <td width='20%'>ServerName</td> 
+        <td width='30%'>Display Name</td>
+        <td width='15%'>Name</td>
+	    <td width='5%'>StartMode</td>
+	    <td width='5%'>Status</td>
+	    </tr>
+        </table>
+                                    <table width='100%' border = 0 > <tbody>
+	                                <tr align= 'Left'>
+                                    <td width='5%' align='center' >1</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>Windows Management Instrumentation</td>
+                                    <td width='15%'>Winmgmt</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0 > <tbody>
+	                                <tr align= 'Left'>
+                                    <td width='5%' align='center' >2</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SMS Agent Host</td>
+                                    <td width='15%'>CcmExec</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0 > <tbody>
+	                                <tr align= 'Left'>
+                                    <td width='5%' align='center' >3</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SMS_EXECUTIVE</td>
+                                    <td width='15%'>SMS_EXECUTIVE</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0 > <tbody>
+	                                <tr align= 'Left'>
+                                    <td width='5%' align='center' >4</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SQL Server Reporting Services (MSSQLSERVER)</td>
+                                    <td width='15%'>ReportServer</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+                                    <table width='100%' border = 0 > <tbody>
+	                                <tr align= 'Left'>
+                                    <td width='5%' align='center' >5</td>
+                                    <td width='20%' align='left'>&nbspCM01.LAB.COM</td>
+                                    <td width='30%'>SQL Server (MSSQLSERVER)</td>
+                                    <td width='15%'>MSSQLSERVER</td>
+	                                <td width='5%'>Auto</td>
+	                                <td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+	                                </tr>
+                                    </table>
+    <table width='100%'><tbody>
+	<tr bgcolor=#01A982> <td> <b> <Font color = 'white'> Backup Status </Font> </b> </td> </tr>
+    </table>
+    <table width='100%' border = 0 > <tbody>
+	<tr bgcolor=#CCCCCC >
+    <td width='5%'>SNo</td>
+    <td width='20%'>ServerName</td>
+    <td width='40%'>Backup Checking Time</td>
+    <td width='5%'>SiteBKP</td>
+    <td width='5%'>DBBKP</td>	
+	<td width='5%'>Status</td>
+	</tr>
+    </table>
+        <table width='100%' border = 0> <tbody>
+    	<tr align='Center'>
+        <td width='5%' align='center'>1</td>
+        <td width='20%' align='left'>&nbsp&nbspCM01.LAB.COM</td>
+        <td width='40%'>02/26/2018 21:00:00 and 02/27/2018 06:00:00</td>
+        <td width='5%'>Failed</td>
+        <td width='5%'>NA</td>	
+    	<td width='5%' align='center' bgcolor='Red'> <Font color ='white'> Critical </Font> </td>
+    	</tr>
+        </table>
+		<table width='100%' border = 0 > <tbody>
+    	<tr align='Center'>
+        <td width='5%' align='center'>2</td>
+        <td width='20%' align='left'>&nbsp&nbspCM01.LAB.COM</td>
+        <td width='40%'>02/26/2018 21:00:00 and 02/27/2018 06:00:00</td>
+        <td width='5%'>NA</td>
+        <td width='5%'>Failed</td>	
+    	<td width='5%' align='center' bgcolor='Red'> <Font color ='white'> Critical </Font> </td>
+    	</tr>
+		</table>
+    <table width='100%'><tbody>
+	<tr bgcolor=#01A982> <td> <b> <Font color = 'white'> Inbox Detail Status </Font> </b> </td> </tr>
+    </table>
+    <table width='100%' border = 0 > <tbody>
+	<tr bgcolor=#CCCCCC>
+    <td width='5%'>SNo</td>
+    <td width='20%'>Folder Name</td>
+    <td width='40%'>Folder Path</td>
+    <td width='5%'>File Count</td>
+	<td width='5%'>Folder Size</td>
+	<td width='5%'>Status</td>
+	</tr>
+    </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >1</td>
+            <td width='20%' align='left' >&nbspinboxes</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.09 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >2</td>
+            <td width='20%' align='left' >&nbspccr.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\ccr.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >3</td>
+            <td width='20%' align='left' >&nbspccrretry.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\ccrretry.box</td>
+            <td width='5%'>3</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >4</td>
+            <td width='20%' align='left' >&nbspauth</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.06 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >5</td>
+            <td width='20%' align='left' >&nbspddm.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\ddm.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >6</td>
+            <td width='20%' align='left' >&nbspBAD_DDRS</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\ddm.box\BAD_DDRS</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >7</td>
+            <td width='20%' align='left' >&nbspincoming</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\statesys.box\incoming</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >8</td>
+            <td width='20%' align='left' >&nbspsinv.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\sinv.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >9</td>
+            <td width='20%' align='left' >&nbspstatesys.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\auth\statesys.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >10</td>
+            <td width='20%' align='left' >&nbspretry</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\dataldr.box\retry</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >11</td>
+            <td width='20%' align='left' >&nbspdataldr.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\auth\dataldr.box</td>
+            <td width='5%'>1</td>
+        	<td width='5%'>0.06 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >12</td>
+            <td width='20%' align='left' >&nbspprocess</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\dataldr.box\process</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >13</td>
+            <td width='20%' align='left' >&nbspBADMIFS</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\auth\dataldr.box\BADMIFS</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >14</td>
+            <td width='20%' align='left' >&nbspschedule.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\schedule.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >15</td>
+            <td width='20%' align='left' >&nbsptosend</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\schedule.box\tosend</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >16</td>
+            <td width='20%' align='left' >&nbspReplmgr.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\Replmgr.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >17</td>
+            <td width='20%' align='left' >&nbsphigh</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\Replmgr.box\Outbound\high</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >18</td>
+            <td width='20%' align='left' >&nbsplow</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\Replmgr.box\Outbound\low</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >19</td>
+            <td width='20%' align='left' >&nbspnormal</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\inboxes\Replmgr.box\Outbound\normal</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >20</td>
+            <td width='20%' align='left' >&nbspIncoming</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\Replmgr.box\Incoming</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >21</td>
+            <td width='20%' align='left' >&nbspOutbound</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\Replmgr.box\Outbound</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >22</td>
+            <td width='20%' align='left' >&nbspoffermgr.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\offermgr.box</td>
+            <td width='5%'>10</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >23</td>
+            <td width='20%' align='left' >&nbspcompsumm.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\compsumm.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >24</td>
+            <td width='20%' align='left' >&nbspDespoolr.box</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\Despoolr.box</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+            <table width='100%' border = 0 > <tbody>
+        	<tr align='center'>
+            <td width='5%' >25</td>
+            <td width='20%' align='left' >&nbspReceive</td>
+            <td width='40%' align='left' >&nbsp\\CM01.LAB.COM\SMS_000\Inboxes\Despoolr.box\Receive</td>
+            <td width='5%'>0</td>
+        	<td width='5%'>0.00 MB</td>
+        	<td width='5%' align='center' bgcolor='Green'> <Font color ='white'> Ok </Font> </td>
+        	</tr>
+            </table>
+
+    <table width='30%'>
+    <tr bgcolor='White'> 
+	<td width='10%' align='center' bgcolor='Green'> <Font color = 'white'> <b> Normal </b> </Font> </td>  
+	<td width='10%' align='center' bgcolor='Orange'> <Font color = 'white'> <b> Warning below 15 % </b> </Font> </td>  
+	<td width='10%' align='center' bgcolor='Red'> <Font color = 'white'> <b> Critical below 10 % </b> </Font> </td>  
+    </tr>
+    </table>
+    
+
+    <table width='30%'>
+    <tr bgcolor='White'>
+    <td width='10%' align='center' bgcolor='Green'> <Font color = 'white'> <b> Normal </b> </Font> </td>  
+	<td width='10%' align='center' bgcolor='Orange'> <Font color = 'white'> <b> Warning </b> </Font> </td>  
+	<td width='10%' align='center' bgcolor='Red'> <Font color = 'white'> <b> Critical </b> </Font> </td> 
+	</tr>
+    </table>
+    
+    <table width='100%' bgcolor = '#425563'><tbody>
+   	<tr> <td align='center'> <b> <Font color = 'white'> Tool Developed By : Karthikeyan Anbarasu ( karthikeyan.anbarasu@lab.com ) - Tuesday, February 27, 2018 8:22:11 AM </Font> </b> </td> </tr>
+	<tr> <td align='center'> <b> <Font color = 'white'> LAB Restricted - Copyright 2018 </Font> </b> </td> </tr>
+    </table>
+</div></div></body></html>
diff --git a/PowerShell/SCCM_Client_Health/MostAmazingSCCMReport/MostAmazingSCCMReport.sql b/PowerShell/SCCM_Client_Health/MostAmazingSCCMReport/MostAmazingSCCMReport.sql
new file mode 100644
index 0000000..e87ca42
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/MostAmazingSCCMReport/MostAmazingSCCMReport.sql
@@ -0,0 +1,130 @@
+-- Written by Ammar Hasayen
+--http://ammarhasayen.com
+
+-- See other queries here(http://ammarhasayen.com/2015/03/01/config-manager-2012-sccm-most-amazing-hardware-inventory-sql-report/)
+
+
+SELECT DISTINCT 
+sys.Name0 'Machine',
+sys.AD_Site_Name0 'ADSite',
+CS.UserName0 'User Name',
+CASE
+    WHEN U.TopConsoleUser0 = '-1' OR U.TopConsoleUser0 IS NULL THEN 'N/A'
+    ELSE U.TopConsoleUser0
+END as TopUser,
+REPLACE (OS.Caption0, 'Microsoft Windows','Win') OS,
+REPLACE (OS.CSDVersion0,'Service Pack','SP') 'Service Pack',
+CS.Manufacturer0 'Manufacturer',
+CS.Model0 Model,
+BIOS.SerialNumber0 'Serial Number',
+BIOS.ReleaseDate0 as BIOSDate,
+BIOS.SMBIOSBIOSVersion0 as BIOSVersion,
+(SELECT CONVERT(DATE,sys.Creation_Date0)) 'Managed Date',
+SUM(ISNULL(RAM.Capacity0,0)) 'Memory (MB)',
+COUNT(RAM.ResourceID) '# Memory Slots',
+REPLACE (cs.SystemType0,'-based PC','') 'Type',
+SUM(D.Size0) / 1024 AS 'Disk Size GB',
+CASE SE.ChassisTypes0
+  when '1' then 'Other'
+  when '2' then 'Unknown'
+  when '3' then 'Desktop'
+  when '4' then 'Low Profile Desktop'
+  when '5' then 'Pizza Box'
+  when '6' then 'Mini Tower'
+  when '7' then 'Tower'
+  when '8' then 'Portable'
+  when '9' then 'Laptop'
+  when '10' then 'Notebook'
+  when '11' then 'Hand Held'
+  when '12' then 'Docking Station'
+  when '13' then 'All in One'
+  when '14' then 'Sub Notebook'
+  when '15' then 'Space-Saving'
+  when '16' then 'Lunch Box'
+  when '17' then 'Main System Chassis'
+  when '18' then 'Expansion Chassis'
+  when '19' then 'SubChassis'
+  when '20' then 'Bus Expansion Chassis'
+  when '21' then 'Peripheral Chassis'
+  when '22' then 'Storage Chassis'
+  when '23' then 'Rack Mount Chassis'
+  when '24' then 'Sealed-Case PC'
+  else 'Undefinded'
+END AS 'PC Type'
+FROM
+ v_R_System SYS
+INNER JOIN (
+     SELECT
+      Name0,
+      MAX(Creation_Date0) AS Creation_Date
+     FROM
+     dbo.v_R_System
+    GROUP BY
+     Name0
+) AS CleanSystem
+ON SYS.Name0 = CleanSystem.Name0 and sys.Creation_Date0 = CleanSystem.Creation_Date
+ LEFT JOIN v_GS_COMPUTER_SYSTEM CS
+ON sys.ResourceID=cs.ResourceID
+ LEFT JOIN v_GS_PC_BIOS BIOS
+ON sys.ResourceID=bios.ResourceID
+ LEFT JOIN (
+     SELECT
+      A.ResourceID,
+      MAX(A.[InstallDate0]) AS [InstallDate0]
+     FROM
+      v_GS_OPERATING_SYSTEM A
+     GROUP BY
+      A.ResourceID
+) AS X
+ON sys.ResourceID = X.ResourceID
+ INNER JOIN v_GS_OPERATING_SYSTEM OS
+ON X.ResourceID=OS.ResourceID and X.InstallDate0 = OS.InstallDate0
+ LEFT JOIN v_GS_PHYSICAL_MEMORY RAM
+ON sys.ResourceID=ram.ResourceID
+ LEFT OUTER join dbo.v_GS_LOGICAL_DISK D
+ON sys.ResourceID = D.ResourceID and D.DriveType0 = 3
+ LEFT outer join v_GS_SYSTEM_CONSOLE_USAGE_MAXGROUP U
+ON SYS.ResourceID = U.ResourceID
+ LEFT JOIN dbo.v_GS_SYSTEM_ENCLOSURE SE on SYS.ResourceID = SE.ResourceID
+ LEFT JOIN dbo.v_GS_ENCRYPTABLE_VOLUME En on SYS.ResourceID = En.ResourceID
+ 
+GROUP BY
+  sys.Creation_Date0, sys.Name0,
+  sys.AD_Site_Name0 , CS.UserName0 ,REPLACE (OS.Caption0, 'Microsoft Windows','Win') , REPLACE (OS.CSDVersion0,'Service Pack','SP') ,
+  CS.Manufacturer0 , CS.Model0 ,BIOS.SerialNumber0 , REPLACE (cs.SystemType0,'-based PC',''),
+CASE
+  WHEN U.TopConsoleUser0 = '-1' OR U.TopConsoleUser0 IS NULL THEN 'N/A'
+  ELSE U.TopConsoleUser0
+END,
+CASE SE.ChassisTypes0
+  when '1' then 'Other'
+  when '2' then 'Unknown'
+  when '3' then 'Desktop'
+  when '4' then 'Low Profile Desktop'
+  when '5' then 'Pizza Box'
+  when '6' then 'Mini Tower'
+  when '7' then 'Tower'
+  when '8' then 'Portable'
+  when '9' then 'Laptop'
+  when '10' then 'Notebook'
+  when '11' then 'Hand Held'
+  when '12' then 'Docking Station'
+  when '13' then 'All in One'
+  when '14' then 'Sub Notebook'
+  when '15' then 'Space-Saving'
+  when '16' then 'Lunch Box'
+  when '17' then 'Main System Chassis'
+  when '18' then 'Expansion Chassis'
+  when '19' then 'SubChassis'
+  when '20' then 'Bus Expansion Chassis'
+  when '21' then 'Peripheral Chassis'
+  when '22' then 'Storage Chassis'
+  when '23' then 'Rack Mount Chassis'
+  when '24' then 'Sealed-Case PC'
+  else 'Undefinded'
+END ,
+ 
+BIOS.ReleaseDate0 ,
+BIOS.SMBIOSBIOSVersion0
+ 
+ORDER BY sys.Name0
\ No newline at end of file
diff --git a/PowerShell/SCCM_Client_Health/Remove-WMIInvalidContent.ps1 b/PowerShell/SCCM_Client_Health/Remove-WMIInvalidContent.ps1
new file mode 100644
index 0000000..335d336
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/Remove-WMIInvalidContent.ps1
@@ -0,0 +1,86 @@
+﻿<#
+.Synopsis
+    Repairs the "The package data in WMI is not consistent to PkgLib" errors after ConfigMgr2012R2 upgrade
+.DESCRIPTION
+    This script repairs the "The package data in WMI is not consistent to PkgLib" errors after ConfigMgr2012R2 upgrade by
+    searching for packages that appear to be in de Content Library according to WMI but are not there and do not exist anymore
+    This cleanup will run against all distribution points and when invalid WMI instances are found, they will be removed.
+    Detailed description of this issue:
+    http://blogs.technet.com/b/configmgrteam/archive/2012/05/07/troubleshooting-content-mismatch-warnings-on-a-distribution-point-in-system-center-2012-configuration-manager.aspx?wa=wsignin1.0
+    Script is to be used at own risk
+.EXAMPLE
+    Remove-WMIInvalidContent.ps1 -Siteserver myserver.mydomain.com -Sitecode AAA
+.LINK
+    http://gallery.technet.microsoft.com/Powershell-script-to-fix-81dc4e69
+.NOTES
+    Written by Bart Serneels
+    Assisted by Stijn Callebaut
+#>
+#param([parameter(Mandatory=$true)][string]$SiteServer,[parameter(Mandatory=$true)][string]$SiteCode)
+Set-Variable -Name IP_Address -Value ((ipconfig|findstr [0-9].\.)[0]).Split()[-1]
+ForEach($IPv4 In $IP_Address){
+    $Parser=$IPv4.Split(".")
+    For($O=0;$O-le3;$O++){
+        Switch($O){
+            0{$Octet_1=$Parser[$O];Break}
+            1{$Octet_2=$Parser[$O];Break}
+            2{$Octet_3=$Parser[$O];Break}
+            3{$Octet_4=$Parser[$O];Break}
+        }
+    }
+    If($Octet_1-eq10){
+        If(($Octet_2-eq118)-or($Octet_2-eq119)){
+            $SiteServer="w16asccmdb01.inf.utshare.local"
+            $SiteCode="DFW"
+        }
+        If(($Octet_2-eq126)-or($Octet_2-eq127)){
+            $SiteServer="w16bsccmdb01.inf.utshare.local"
+            $SiteCode="AUS"
+        }
+    }
+}
+If(($SiteServer-eq$null)-or($SiteCode-eq$null)){
+    Set-Variable -Name SiteServer -Value "w16asccmdb01.inf.utshare.local"
+    Set-Variable -Name SiteCode -Value "DFW"
+}
+Clear-History;Clear-Host
+$Namespace="root\SMS\Site_"+$SiteCode
+Write-Host "Getting all valid packages... " -NoNewline
+$ValidPackages=Get-WMIObject -ComputerName $SiteServer -Namespace $Namespace -Query "Select * from SMS_ObjectContentExtraInfo"
+Write-Host ([string]($ValidPackages.count)+" packages found.")
+Write-Host "Getting all valid distribution points... " -NoNewline
+$DistributionPoints = Get-WMIObject -ComputerName $SiteServer -Namespace $Namespace -Query "select * from SMS_DistributionPointInfo where ResourceType = 'Windows NT Server'"
+Write-Host ([string]($DistributionPoints.count)+" distribution points found.")
+Write-Host ""
+Foreach($DistributionPoint In $DistributionPoints){
+    $InvalidPackages=@()
+    $DistributionPointName=$DistributionPoint.ServerName
+    If(!(Test-Connection $DistributionPointName -Quiet -Count 1)){
+        Write-error "Could not connect to DistributionPoint $DistributionPointName - Skipping this server..."
+    }Else{
+        Write-Host "$DistributionPointName is online." -ForegroundColor Green
+        Write-Host "Getting packages from $DistributionPointName ... " -NoNewline
+        $CurrentPackageList=@(Get-WMIObject -ComputerName $DistributionPointName -Namespace "root\sccmdp" -Query "Select * from SMS_PackagesInContLib")
+        Write-Host([string]($CurrentPackageList.Count)+" packages found.")
+        If(($CurrentPackageList.Count -eq 0)-or($CurrentPackageList-eq$null)){
+            Write-Host "Skipping this distribution point"
+        }Else{
+            Write-Host "Validating packages on $DistributionPointName ..."
+            $result=@(Compare-Object -ReferenceObject $CurrentPackageList -DifferenceObject $ValidPackages -Property PackageID -PassThru)
+            $InvalidPackages=@($result|Where-Object{$_.sideindicator-eq'<='})
+            If ($InvalidPackages.Count-eq0){
+                Write-Host "All packages on $DistributionPointName are valid" -ForegroundColor Green
+            }Else{
+                Write-Host "Invalid packages on $DistributionPointName :" -ForegroundColor Yellow
+                $InvalidPackages.PackageID
+                $InvalidPackages|Foreach{
+                    $InvalidPackageID=$_.PackageID
+                    Write-Host "Removing invalid package $InvalidPackageID from WMI on $DistributionPointName " -NoNewline
+                    Get-WMIObject -ComputerName $DistributionPointName -Namespace "root\sccmdp" -Query ("Select * from SMS_PackagesInContLib where PackageID = '"+([string]($_.PackageID))+"'")|Remove-WmiObject
+                    Write-Host "-Done"
+                    }
+                }
+            Write-Host ""
+            }
+        }
+    }
diff --git a/PowerShell/SCCM_Client_Health/Repair_User_Profile.ps1 b/PowerShell/SCCM_Client_Health/Repair_User_Profile.ps1
new file mode 100644
index 0000000..9d56870
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/Repair_User_Profile.ps1
@@ -0,0 +1,112 @@
+﻿PowerShell Set-ExecutionPolicy -ExecutionPolicy ByPass
+PowerShell Set-ExecutionPolicy Unrestricted
+Clear-History;Clear-Host
+Set-Variable -Name AdminSession -Value $null
+Set-Variable -Name CurrentUser -Value $env:USERNAME
+Set-Variable -Name ComputerName -Value $env:COMPUTERNAME
+$Global:Answer=$null
+$Global:AdminCreds=$null
+Set-Variable -Name LogonDomain -Value $($($env:USERDNSDOMAIN).Split(".")[0]).ToUpper()
+Set-Variable -Name ParentPath -Value "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
+$AdminCreds=Get-Credential -Credential "$LogonDomain\$CurrentUser" -ErrorAction SilentlyContinue
+Function RemoteSession-Open{Param([Parameter(Mandatory=$true)][ValidateNotNullorEmpty()][string]$Answer)
+    $Results=Test-WSMan -ComputerName $Answer;Clear
+    If($Results-eq$null){
+        $PSExecPath="\\$LogonDomain\replication\SysAdmins\SysInternals\psexec64.exe"
+        Start-Process -FilePath "$PSExecPath" -Credential $AdminCreds -ArgumentList "\\$Answer cmd /c powershell enable-psremoting -force""" -Wait
+    }
+    $AdminSession=New-PSSession -Credential $AdminCreds -ComputerName $Answer
+    Enter-PSSession $AdminSession
+    gpupdate /force
+    Return $Answer
+}
+<#
+
+    Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
+
+    Dir
+
+    ###
+    ###    Locate the correct registry profile
+    ###    Focus on the last four/five digits of SID for the account that you're fixing
+    ###    The ProfileImagePath will need to be changed.  You will change that first
+    ###
+    ###    In the next line, copy and paste to the SID at the below registry prompt
+    ###
+
+    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\###{SID of the user account that you're fixing}###" -Name ProfileImagePath
+
+    ###
+    ###    EXAMPLE:
+    ###
+    ###    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\S-1-5-21-1993002232-2661840759-1735431652-17172" -Name ProfileImagePath
+    ###
+    ###
+    ###    The above command will return the value that you want to change if it is formatted correctly
+    ###    Once you verify that you have the correct registry value being returned from the pervious command
+    ###    Up arrow one time on the keyboard to reveil the pervious command and hit the HOME key and change
+    ###    the "GET" command to "SET", then hit the END key and add the new value for the profile path
+    ###    An example of the complete command is below for what the SET command should look like for ProfileImagePath
+    ###
+
+    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\S-1-5-21-1993002232-2661840759-1735431652-17172" -Name ProfileImagePath -Value "C:\Users\ro1000829946"
+
+    ###
+    ###    The next value that is needed to be changed is the STATE value.  If you use the same sentax as the
+    ###    pervious GET statement, you'll need to change the -NAME from "ProfileImagePath" to "State"
+    ###    You'll need to change the "State" value from it's current random value to "16" for Remote profile
+    ###
+    ###    An example of the complete command is below for what the SET command should look like for State
+    ###
+
+    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\S-1-5-21-1993002232-2661840759-1735431652-17172" -Name State -Value 16
+
+    ###
+    ###    The registry values for the profile are now fixed, but the files in the C:\Users directory are still their
+    ###    We will now change the focus of PowerShell from the registry to the local system drive "C:\Windows\System32"
+    ###
+
+    Set-Location $env:SystemRoot\System32
+
+    ###
+    ###    From the current location you'll remove all profile directories that exist for the fixed account
+    ###
+    ###    An example of the command we'll use is formatted completely below to list all files and directories being removed
+    ###
+
+    Remove-Item C:\Users\ro1000829946.* -Recurse -Force -Verbose
+
+    ###
+    ###    Once you've completed cleaning up the remote computer, make sure that you close the session and run the last function
+    ###    Before closing the remote session, make sure that you have the UserName for the RemoteSession-Close command
+    ###
+
+    Exit-PSSession
+
+    ###
+    ###    Running the "RemoteSession-Close sy##########" command will copy the remote image profile to the users account
+    ###    This process will verify all the initial settings are in place on the user's profile
+    ###
+    ###    An example of the complete Function call is: RemoteSession-Close "ro1000829946"
+    ###
+
+    Echo $Answer
+
+    ###
+    ###    If the above variable doesn't return the correct value, then set the correct value before running the below
+    ###    function.  To set the correct value type, $Answer="HOSTNAME" at the PS prompt.
+    ###
+
+#>
+Function RemoteSession-Close{Param([Parameter(Mandatory=$true)][ValidateNotNullorEmpty()][String]$UserName)
+    Set-Variable -Name StoredProfiles -Value "\\w16adfs01.inf.utshare.local\VPRepository"
+    Set-Variable -Name LocalUserProfile -Value "\\$Answer\C$\Users\$UserName"
+    If(Test-Path -Path "$StoredProfiles\$UserName.V6"){
+        $StoredProfiles="$StoredProfiles\$UserName.V6"
+    }Else{
+        $StoredProfiles="$StoredProfiles\w10_gld_img.V6"
+    }
+    Start-Process -FilePath "PowerShell" -Credential $AdminCreds -ArgumentList "-noexit RoboCopy $StoredProfiles $LocalUserProfile /E""" -Wait
+    Set-Location $env:SystemRoot\System32
+    Clear
+}
\ No newline at end of file
diff --git a/PowerShell/SCCM_Client_Health/config.xml b/PowerShell/SCCM_Client_Health/config.xml
new file mode 100644
index 0000000..6aa03bf
--- /dev/null
+++ b/PowerShell/SCCM_Client_Health/config.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Configuration>
+	<LocalFiles>C:\ClientHealth</LocalFiles> <!-- Path locally on computer for temporary files and local clienthealth.log if LocalLogFile="True" -->
+	<Client Name="Version">5.00.8740.1031</Client>
+	<Client Name="SiteCode">DFW</Client>
+	<Client Name="Domain">utshare.local</Client>
+	<Client Name="AutoUpgrade">True</Client>
+	<Client Name="Share">\\w16asccmdb01.inf.utshare.local\Clienthealth$\Client</Client>
+	<Client Name="CacheSize" Value="10240" DeleteOrphanedData="True" Enable="True" />
+	<Client Name="Log" MaxLogSize="4096" MaxLogHistory="1" Enable="True" />
+	<ClientInstallProperty>SMSSITECODE=DFW</ClientInstallProperty>
+	<ClientInstallProperty>MP=w16asccmdb01.inf.utshare.local</ClientInstallProperty>
+	<ClientInstallProperty>FSP=w16bsccmdb01.inf.utshare.local</ClientInstallProperty>
+	<ClientInstallProperty>DNSSUFFIX=vdi.utshare.local</ClientInstallProperty>
+	<ClientInstallProperty>/Source:\\w16asccmdb01.inf.utshare.local\Clienthealth$\client</ClientInstallProperty>
+	<ClientInstallProperty>/MP:w16asccmdb01.inf.utshare.local</ClientInstallProperty>
+	<ClientInstallProperty>/skipprereq:silverlight.exe</ClientInstallProperty>
+	<Log Name="File" Share="\\w16asccmdb01.inf.utshare.local\ClientHealthLogs$" Level="Full" MaxLogHistory="8" LocalLogFile="True" Enable="True" /> <!-- Level: Full = everything. ClientInstall = only if installation of sccm agent fails.  -->
+	<Log Name="SQL" Server="w16asccmdb01.inf.utshare.local" Enable="True" />
+	<Log Name="Time" Format="ClientLocal" /> <!-- Valid formats: ClientLocal / UTC  -->
+	<Option Name="CcmSQLCELog" Enable="False" /> <!-- Optional check on the ConfigMgr agent if local database is corrupt -->
+	<Option Name="BITSCheck" Fix="True" Enable="True" />
+	<Option Name="DNSCheck" Fix="True" Enable="True" />
+	<Option Name="Drivers" Enable="True" />
+	<Option Name="Updates" Share="\\w16asccmdb01.inf.utshare.local\ClientHealth$\Updates" Fix="True" Enable="False" />
+	<Option Name="PendingReboot" StartRebootApplication="True"  Enable="True" />
+	<Option Name="RebootApplication" Application="\\w16asccmdb01.inf.utshare.local\ClientHealth$\RebootApp\shutdowntool.exe /t:7200 /m:1440" Enable="False" />
+	<Option Name="MaxRebootDays" Days="7" Enable="True" />
+	<Option Name="OSDiskFreeSpace">10</Option>
+	<Option Name="HardwareInventory" Days="10" Fix="True" Enable="True" />
+	<Option Name="SoftwareMetering" Fix="True" Enable="True" />
+	<Option Name="WMI" Fix="True" Enable="True"/>
+	<Option Name="RefreshComplianceState" Days="30" Enable="True"/>
+	<Service Name="BITS" StartupType="Automatic (Delayed Start)" State="Running" Uptime=""/>
+	<Service Name="winmgmt" StartupType="Automatic" State="Running" Uptime=""/>
+	<Service Name="wuauserv" StartupType="Automatic (Delayed Start)" State="Running" Uptime=""/>
+	<Service Name="lanmanserver" StartupType="Automatic" State="Running" Uptime=""/>
+	<Service Name="RpcSs" StartupType="Automatic" State="Running" Uptime=""/>
+	<Service Name="W32Time" StartupType="Automatic" State="Running" Uptime=""/>
+	<Service Name="ccmexec" StartupType="Automatic (Delayed Start)" State="Running" Uptime="7" />
+	<Remediation Name="AdminShare" Fix="True" />
+	<Remediation Name="ClientProvisioningMode" Fix="True" />
+	<Remediation Name="ClientStateMessages" Fix="True" />
+	<Remediation Name="ClientWUAHandler" Fix="True"  Days="30"/>
+	<Remediation Name="ClientCertificate" Fix="True" />
+</Configuration>
\ No newline at end of file
diff --git a/PowerShell/TestingSSH.ps1 b/PowerShell/TestingSSH.ps1
new file mode 100644
index 0000000..981a4d8
--- /dev/null
+++ b/PowerShell/TestingSSH.ps1
@@ -0,0 +1,105 @@
+Clear-Host;Clear-History
+Import-Module -Global -Name "E:\Scripts\Modules" -Verbose
+$Global:SiteCode=("B")
+$Global:Domain=("utshare.local")
+$Global:DateTime=(Get-Date)
+$Global:DomainUser=(($env:USERNAME+"@"+$Domain).ToLower())
+$Global:Power6Path=($env:ProgramFiles+"\PowerShell\6")
+$ScriptPath=$MyInvocation.MyCommand.Definition
+$ScriptName=$MyInvocation.MyCommand.Name
+$ErrorActionPreference='SilentlyContinue'
+Set-Location ($ScriptPath.Replace($ScriptName,""))
+Set-Variable -Name SecureCredentials -Value $null
+Set-Variable -Name vSphere -Value ("vcmgr01"+$SiteCode+".inf."+$Domain)
+Set-Variable -Name EndTime -Value $null
+Function LoadModules(){
+   ReportStartOfActivity "Searching for $ProductShortName module components..."
+   $Loaded=Get-Module -Name $ModuleList -ErrorAction Ignore|ForEach-Object {$_.Name}
+   $Registered=Get-Module -Name $ModuleList -ListAvailable -ErrorAction Ignore|ForEach-Object {$_.Name}
+   $NotLoaded=$Registered|Where-Object {$Loaded -notcontains $_}
+   ReportFinishedActivity
+   Foreach($Module In $Registered){
+      If($Loaded -notcontains $Module){
+		 ReportStartOfActivity "Loading module $Module"
+		 Import-Module $Module
+		 ReportFinishedActivity
+      }
+   }
+}
+Function ReportStartOfActivity($Activity){
+   $Script:CurrentActivity=$Activity
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ReportFinishedActivity(){
+   $Script:CompletedActivities++
+   $Script:PercentComplete=(100.0/$TotalActivities)*$Script:CompletedActivities
+   $Script:PercentComplete=[Math]::Min(99,$PercentComplete)
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Switch($DomainUser){
+    {($_-like"sy10*")-or($_-like"sy60*")}{Break}
+    Default{$DomainUser=(("sy1000829946@"+$Domain).ToLower());Break}
+}
+$Validate=SetCredentials -SecureUser $DomainUser -Domain ($Domain).Split(".")[0]
+If(!($SecureCredentials)){$SecureCredentials=get-credential};$Validate=$null
+#Load PowerCli Context
+$Script:PromptForCEIP=$false
+$ModuleList=@(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+)
+$ProductName="PowerCli"
+$ProductShortName="PowerCli"
+$LoadingActivity="Loading $ProductName"
+$Script:CompletedActivities=0
+$Script:PercentComplete=0
+$Script:Validate=$null
+$Script:CurrentActivity=""
+$Script:ServerList="ServerList.txt"
+$Script:WorkingPath=($env:USERPROFILE+"\Desktop")
+$Script:ProcessList=($WorkingPath+"\"+$ServerList)
+$Script:totalActivities=$ModuleList.Count+1
+LoadModules
+$PowerCliFriendlyVersion=[VMware.VimAutomation.Sdk.Util10.ProductInfo]::PowerCliFriendlyVersion
+$Host.ui.RawUI.WindowTitle=$PowerCliFriendlyVersion
+Try{
+	$configuration=Get-PowerCliConfiguration -Scope Session
+	If($PromptForCEIP-and!($configuration.ParticipateInCEIP)-and[VMware.VimAutomation.Sdk.Util10Ps.CommonUtil]::InInteractiveMode($Host.UI)){
+		$caption="Participate in VMware Customer Experience Improvement Program (CEIP)"
+		$Message=`
+			"VMware's Customer Experience Improvement Program (`"CEIP`") provides VMware with information "+
+			"that enables VMware to improve its Products and services, to fix problems, and to advise you "+
+			"on how best to deploy and use our Products.  As part of the CEIP, VMware collects technical information "+
+			"about your organization’s use of VMware Products and services on a regular basis in association "+
+			"with your organization’s VMware license key(s).  This information does not personally identify "+
+			"any individual."+
+			"`n`nFor more details: press Ctrl+C to exit this prompt and type `"help about_ceip`" to see the related help article."+
+			"`n`nYou can join or leave the program at any time by executing: Set-PowerCliConfiguration -Scope User -ParticipateInCEIP `$true or `$false."
+		$AcceptLabel="&Join"
+		$choices=(
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList $AcceptLabel,"Participate in the CEIP"),
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList "&Leave","Don`t participate")
+		)
+		$userChoiceIndex = $Host.UI.PromptForChoice($caption, $Message, $choices, 0)
+		$participate = $choices[$userChoiceIndex].Label -eq $AcceptLabel
+		If($participate){
+            [VMware.VimAutomation.Sdk.Interop.V1.CoreServiceFactory]::CoreService.CeipService.JoinCeipProgram();
+        }Else{
+            Set-PowerCliConfiguration -Scope User -ParticipateInCEIP $false -Confirm:$false | Out-Null
+        }
+    }
+}Catch{}
+Write-Progress -Activity $LoadingActivity -Completed
+#Connect vSphere
+$Validate=Connect-VIServer -Server $vSphere -credential $SecureCredentials;Clear-Host
diff --git a/PowerShell/delegate permissions.ps1 b/PowerShell/delegate permissions.ps1
new file mode 100644
index 0000000..d332976
--- /dev/null
+++ b/PowerShell/delegate permissions.ps1	
@@ -0,0 +1,28 @@
+﻿<# modified via a script from https://gallery.technet.microsoft.com/Create-System-Management-0d6b7909
+#  niall brady 2016/12/5
+#>
+
+#Import AD module if not already loaded
+Import-Module -Name ActiveDirectory
+# Derive domain name
+$namingContext = (Get-ADRootDSE).defaultNamingContext
+$ConfigMgrSrv = $env:COMPUTERNAME
+# Define path for System Management Container
+$sccmContainer = "CN=System Management,CN=System,$namingContext"
+# Get SID of SCCM Server
+$configMgrSid = [System.Security.Principal.IdentityReference] (Get-ADComputer $ConfigMgrSrv).SID
+# Get current ACL set for System Management Container
+$cnACL = Get-Acl -Path "ad:$sccmContainer"
+# Sepcify Permission to Full Control
+$adPermissions = [System.DirectoryServices.ActiveDirectoryRights] 'GenericAll'
+# Specify Permission type to allow access
+$permissionType = [System.Security.AccessControl.AccessControlType] 'Allow'
+# Set Inheritance for the Container to "This object and all child objects"
+$inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] 'All'
+# Set System Management container Access Control Entry
+$cnACE = New-Object -TypeName System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $configMgrSid, $adPermissions, $permissionType , $inheritanceType
+# Add Access Control Entry to existing ACL
+$cnACL.AddAccessRule($cnACE) 
+# Finally Set ACL on System Management Container
+Set-Acl -AclObject $cnACL -Path "AD:$sccmContainer"
+write-host "Permissions delegated."
\ No newline at end of file
diff --git a/PowerShell/install roles and features.ps1 b/PowerShell/install roles and features.ps1
new file mode 100644
index 0000000..65b1615
--- /dev/null
+++ b/PowerShell/install roles and features.ps1	
@@ -0,0 +1,26 @@
+﻿<#
+# install some roles and features for Configuration Manager
+# requirements are listed here https://technet.microsoft.com/library/gg682077.aspx#BKMK_SiteSystemRolePrereqs
+#
+# https://technet.microsoft.com/en-us/library/jj205467.aspx
+# This example installs all roles, role services and features that are specified in a configuration file named DeploymentConfigTemplate.xml. 
+# The configuration file was created by clicking Export configuration settings on the Confirm installation selections page of the Server Manager.
+# 
+# Please make sure that your source files (Server 2016 Media) are in the path listed below, or adjust as necessary.
+#
+# niall brady 2016/12/5
+#
+#>
+
+    If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(`
+        [Security.Principal.WindowsBuiltInRole] “Administrator”))
+
+    {
+        Write-Warning “You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!”
+        Break
+    }
+
+$Scriptspath = "E:\Sources\scripts"
+$SourceFiles = "E:\Sources\SXS"
+Write-Host "Installing roles and features, please wait... "  -nonewline
+Install-WindowsFeature -ConfigurationFilePath $Scriptspath\DeploymentConfigTemplate.xml -Source $SourceFiles
diff --git a/PowerShell/install roles and features_WSUS.ps1 b/PowerShell/install roles and features_WSUS.ps1
new file mode 100644
index 0000000..2b9d7d7
--- /dev/null
+++ b/PowerShell/install roles and features_WSUS.ps1	
@@ -0,0 +1,35 @@
+﻿<# 
+# This Script:        Niall Brady      - http://www.windows-noob.com
+#                                      - 2016/12/6.
+#                                      - Installs WSUS for ConfigMgr, SQL should be installed priot
+#>
+  If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(`
+        [Security.Principal.WindowsBuiltInRole] “Administrator”))
+
+    {
+        Write-Warning “You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!”
+        Break
+    }
+$WSUSFolder = "E:\WSUS"
+$SourceFiles = "E:\Sources\SXS"
+$servername="CM01"
+# create WSUS folder
+if (Test-Path $WSUSFolder){
+ write-host "The WSUS folder already exists."
+ } else {
+
+New-Item -Path $WSUSFolder -ItemType Directory
+}
+if (Test-Path $SourceFiles){
+ write-host "Windows Server 2016 source files found"
+ } else {
+
+write-host "Windows Server 2016 source files not found, aborting"
+break
+}
+
+Write-Host "Installing roles and features, please wait... "  -nonewline
+Install-WindowsFeature -ConfigurationFilePath E:\Sources\scripts\DeploymentConfigTemplate_WSUS.xml -Source $SourceFiles
+Start-Sleep -s 10
+& ‘C:\Program Files\Update Services\Tools\WsusUtil.exe’ postinstall SQL_INSTANCE_NAME=$servername CONTENT_DIR=$WSUSFolder |out-file Null
+write-host "All done !"
\ No newline at end of file
diff --git a/PowerShell/setup ADK and WDS.ps1 b/PowerShell/setup ADK and WDS.ps1
new file mode 100644
index 0000000..ac1b624
--- /dev/null
+++ b/PowerShell/setup ADK and WDS.ps1	
@@ -0,0 +1,64 @@
+﻿<# 
+# This Script:        Niall Brady      - http://www.windows-noob.com
+#                                      - 2016/12/5.
+# Downloads ADK version 1607, then installs it and WDS.
+#
+#>
+
+    If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(`
+        [Security.Principal.WindowsBuiltInRole] “Administrator”))
+
+    {
+        Write-Warning “You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!”
+        Break
+    }
+$SourcePath = "E:\Sources\"
+# create Source folder if needed
+if (Test-Path $SourcePath){
+ write-host "The Source folder already exists."
+ } else {
+
+New-Item -Path $SourcePath -ItemType Directory
+}
+# These 2 lines with help from Trevor !
+$ADKPath = '{0}\Windows Kits\10\ADK' -f $SourcePath;
+$ArgumentList1 = '/layout "{0}" /quiet' -f $ADKPath;
+
+
+# Check if these files exists, if not, download them
+ $file1 = $SourcePath+"\adksetup.exe"
+
+if (Test-Path $file1){
+ write-host "The file $file1 exists."
+ } else {
+ 
+# Download Windows Assessment and Deployment Kit (ADK 10)
+		Write-Host "Downloading Adksetup.exe " -nonewline
+		$clnt = New-Object System.Net.WebClient
+		$url = "https://go.microsoft.com/fwlink/p/?LinkId=526740"
+		$clnt.DownloadFile($url,$file1)
+		Write-Host "done!" -ForegroundColor Green
+ }
+
+ 
+if (Test-Path $ADKPath){
+ Write-Host "The folder $ADKPath exists."
+ } else{
+Write-Host "Downloading Windows ADK 10 which is approx 3GB in size, please wait..."  -nonewline
+Start-Process -FilePath "$SourcePath\adksetup.exe" -Wait -ArgumentList $ArgumentList1
+Write-Host "done!" -ForegroundColor Green
+ }
+
+Start-Sleep -s 10
+
+# This installs Windows Deployment Service
+Write-Host "Installing Windows Deployment Services"  -nonewline
+Import-Module ServerManager
+Install-WindowsFeature -Name WDS -IncludeManagementTools
+Start-Sleep -s 10
+
+# Install ADK Deployment Tools,  Windows Preinstallation Enviroment
+Write-Host "Installing Windows ADK 10"
+Start-Process -FilePath "$ADKPath\adksetup.exe" -Wait -ArgumentList " /Features OptionId.DeploymentTools OptionId.WindowsPreinstallationEnvironment OptionId.ImagingAndConfigurationDesigner OptionId.UserStateMigrationTool /norestart /quiet /ceip off"
+Start-Sleep -s 20
+Write-Host "Done !"
diff --git a/backup/MapNetworkDrives.ps1 b/backup/MapNetworkDrives.ps1
new file mode 100644
index 0000000..5537625
--- /dev/null
+++ b/backup/MapNetworkDrives.ps1
@@ -0,0 +1,222 @@
+﻿Clear-Host;Clear-History
+Set-Location ($env:SystemRoot+"\System32")
+$CurrentLocation=Get-Location
+Set-Variable -Name SecureCredentials -Value $null
+If((!($env:USERDNSDOMAIN)-eq$null)-or($env:USERDNSDOMAIN)-eq"home.net"){
+    $Global:DomainA=($env:USERDNSDOMAIN.ToLower())
+}
+$Global:DomainB=("utshare.local")
+$Global:Validate=$null
+$Global:UserAccount="sy1000829946"
+$Global:SecureUserDA=($env:USERNAME+"@"+$DomainA)
+$Global:SecureUserDB=($UserAccount+"@"+$DomainB)
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$true)]$SecureUser="",[String][Parameter(Mandatory=$true)]$Domain="")
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Clear
+Set-Variable -Name Loops -Value 0
+Set-Variable -Name LoopCount -Value 0
+Do{
+    Set-Variable -Name utsis -Value ("grey."+$DomainA)
+    Set-Variable -Name utshare -Value ($DomainB+"\replication")
+    If(($DomainA-eq$DomainB)-or($DomainA-eq$null)){
+        Set-Variable -Name Drives -Value @("S","W")
+    }Else{
+        Set-Variable -Name Drives -Value @("G","S","W")
+    }
+    $Domain=($DomainB).split(".")[0]
+    ForEach($Drive In $Drives){
+        Set-Variable -Name ShareName -Value $null
+        Switch ($Drive){
+            "G"{$Validate=SetCredentials -SecureUser $SecureUserDA -Domain ($DomainA).split(".")[0]
+                $SecureUser=($env:USERNAME+"@"+$DomainA)
+                $ShareName=("\\"+$utsis+"\apps")
+                Break}
+            "S"{$Validate=SetCredentials -SecureUser $SecureUserDB -Domain ($DomainB).split(".")[0]
+                $SecureUser=($Domain+"\"+$UserAccount)
+                $ShareName=("\\"+$utshare+"\SysAdmins")
+                Break}
+            "W"{$Validate=SetCredentials -SecureUser $SecureUserDB -Domain ($DomainB).split(".")[0]
+                $SecureUser=($Domain+"\"+$UserAccount)
+                $UserShare=($SecureUserDB.SubString(0,2)+"\"+$SecureUserDB.Substring(0,12))
+                $ShareName=("\\"+$utshare+"\Users\"+$UserShare)
+                Break}
+        }
+        $NetName=$ShareName.Replace("\","\\")
+        $NetDrive = Get-WmiObject -Class Win32_mappedLogicalDisk -filter ("ProviderName='"+$NetName+"'")
+        If($NetDrive.Name-ne$null){net use $NetDrive.Name /delete}
+        Net Use ($Drive+":") $ShareName /user:$SecureUser $Validate /Persistent:NO;$Validate=$null
+    }
+    $LoopCount++
+}While($LoopCount-le$Loops)
+Set-Location -Path $CurrentLocation
diff --git a/backup/PowerCLI_Examples.txt b/backup/PowerCLI_Examples.txt
new file mode 100644
index 0000000..f988265
--- /dev/null
+++ b/backup/PowerCLI_Examples.txt
@@ -0,0 +1,82 @@
+UPTIME
+-----------------------------------------------------------------------------------------------------------------------------------------
+Connect-VIServer server1.domain.local 
+
+$VMs = Get-VM | Where-Object {$_.PowerState -eq "PoweredOn"}
+$Output = ForEach ($VM in $VMs){ 
+    "" | Select @{N="Name";E={$VM.Name}},
+    @{N="Powered On";E={$Event = Get-VM $VM.Name | Get-VIEvent -MaxSamples [int]::MaxValue | Where-Object {$_.FullFormattedMessage -like "*powered on*"} | Select-First 1 
+    $Event.CreatedTime}},
+    @{N="Up Time";E={$Timespan = New-Timespan -Seconds (Get-Stat -Entity $VM.Name -Stat sys.uptime.latest -Realtime -MaxSamples 1).Value
+    "" + $Timespan.Days + " Days, "+ $Timespan.Hours + " Hours, " +$Timespan.Minutes + " Minutes"}}
+    } 
+    
+$Output | Export-Csv -Path "D:\Output\VMUptimeReport.csv "-NoTypeInformation
+
+
+POWERED OFF DATE
+-----------------------------------------------------------------------------------------------------------------------------------------
+Connect-VIServer -Server XXX-vcenter1 -User administrator@vsphere.local -Password XXXXXXXXXXXX
+
+$Report = @()
+
+$VMs = get-vm |Where-object {$_.powerstate -eq "poweredoff"}
+$Datastores = Get-Datastore | select Name, Id
+
+Get-VIEvent -Entity $VMs -MaxSamples ([int]::MaxValue) |
+where {$_ -is [VMware.Vim.VmPoweredOffEvent]} |
+Group-Object -Property {$_.Vm.Name} | %{
+  $lastPO = $_.Group | Sort-Object -Property CreatedTime -Descending | Select -First 1
+  $vm = Get-VM -Name $_.Name
+  $row = '' | select VMName,Powerstate,OS,Host,Cluster,Datastore,NumCPU,MemMb,DiskGb,PowerOFF
+    $row.VMName = $vm.Name
+    $row.Powerstate = $vm.Powerstate
+    $row.OS = $vm.Guest.OSFullName
+    $row.Host = $vm.VMHost.name
+    $row.Cluster = $vm.VMHost.Parent.Name
+    $row.Datastore = ($Datastores | where {$_.ID -match (($vm.Datastore | Select -First 1) | Select Value).Value} | Select Name).Name
+    $row.NumCPU = $vm.NumCPU
+    $row.MemMb = $vm.MemoryMB
+    $row.DiskGb = ((($vm.HardDisks | Measure-Object -Property CapacityKB -Sum).Sum * 1KB / 1GB),2)
+    $row.PowerOFF = $lastPO.CreatedTime
+    $report += $row
+}
+
+$report | Sort Name | Export-Csv -Path "C:\XXXXX\Powered_Off_VMs.csv" -NoTypeInformation -UseCulture
+
+disconnect-viserver * -confirm:$false
+
+
+MONITOR AND RESTART LOCKED VM
+-----------------------------------------------------------------------------------------------------------------------------------------
+Get-VM -Name MyVM  | Select @{N="OverallStatus";E={$_.ExtensionData.OverallStatus}}
+
+- OR -
+
+$vm = Get-VM -Name MyVM
+if(!(Test-Connection -ComputerName $vm.Guest.HostName -Quiet) -and
+    $vm.Guest.State -eq "NotRunning"){
+    Stop-VM -VM $vm -Confirm:$false -Kill
+    Start-VM -VM $vm
+}
+
+
+WHEN A VM WAS CREATED AND BY WHO
+-----------------------------------------------------------------------------------------------------------------------------------------
+$vmName = '*'
+$eventTYpes = 'VmCreatedEvent', 'VmClonedEvent', 'VmDeployedEvent', 'VmRegisteredEvent'
+Get-VM -Name $vmName |
+   ForEach-Object -Process {
+   Get-VIEvent -Entity $_ -MaxSamples ([int]::MaxValue) |
+   where { $eventTYpes -contains $_.GetType().Name } |
+   Sort-Object -Property CreatedTime -Descending |
+  Select -First 1 |
+   ForEach-Object -Process {
+   New-Object PSObject -Property ([ordered]@{
+   VM = $_.VM.Name
+   CreatedTime = $_.CreatedTime
+   User = $_.UserName
+   EventType = $_.GetType().Name
+   })
+   }
+   }
diff --git a/backup/ResetFailedVM.ps1 b/backup/ResetFailedVM.ps1
new file mode 100644
index 0000000..6610163
--- /dev/null
+++ b/backup/ResetFailedVM.ps1
@@ -0,0 +1,622 @@
+﻿Clear-Host;Clear-History
+$Global:Separator="________________________________________________________________________________________________________________________"
+$Global:ResetHost=@()
+$Global:Validate=$null
+$Global:SiteCode="A"
+$Global:Domain=("utshare.local")
+$Global:DomainUser=(($env:USERNAME+"@"+$Domain).ToLower())
+$Global:ExcludedFolders=@("Retired","Templates","UTD IaaS (Root)")
+$ScriptPath=$MyInvocation.MyCommand.Definition
+$ScriptName=$MyInvocation.MyCommand.Name
+$ErrorActionPreference='SilentlyContinue'
+Set-Location ($ScriptPath.Replace($ScriptName,""))
+Set-Variable -Name DateTime -Value (Get-Date)
+Set-Variable -Name SecureCredentials -Value $null
+Set-Variable -Name vSphere -Value ("vcmgr01"+$SiteCode+".inf."+$Domain).ToLower()
+Set-Variable -Name LogName -Value ($ScriptName.Replace("ps1","log"))
+Set-Variable -Name LogFile -Value ($env:USERPROFILE+"\Desktop\"+$LogName)
+Set-Variable -Name TempFile -Value ($env:TEMP+"\"+$LogName)
+Set-Variable -Name ExcludedName -Value ("ExcludedSystems.log")
+Set-Variable -Name ExcludedFile -Value ($env:USERPROFILE+"\Desktop\"+$ExcludedName)
+Set-Variable -Name PoweredOffName -Value ("PoweredOff.log")
+Set-Variable -Name PoweredOffFile -Value ($env:USERPROFILE+"\Desktop\"+$PoweredOffName)
+Set-Variable -Name MailServer -Value ("mail.utshare.utsystem.edu")
+#Set-Variable -Name SendTo -Value ("GRP-SIS_SysAdmin@utsystem.edu")
+Set-Variable -Name SendTo -Value ("bstobie@utsystem.edu")
+Set-Variable -Name EndTime -Value $null
+Set-Variable -Name Sender -Value $null
+Function LoadModules(){
+   ReportStartOfActivity "Searching for $ProductShortName module components..."
+   $Loaded=Get-Module -Name $ModuleList -ErrorAction Ignore|ForEach-Object{$_.Name}
+   $Registered=Get-Module -Name $ModuleList -ListAvailable -ErrorAction Ignore|ForEach-Object{$_.Name}
+   $NotLoaded=$Registered|Where-Object{$Loaded -notcontains $_}
+   ReportFinishedActivity
+   Foreach($Module In $Registered){
+      If($Loaded -notcontains $Module){
+		 ReportStartOfActivity "Loading module $Module"
+		 Import-Module $Module
+		 ReportFinishedActivity
+      }
+   }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$True)]$String,[String][Parameter(Mandatory=$True)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function ReportStartOfActivity($Activity){
+   $Script:CurrentActivity=$Activity
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ReportFinishedActivity(){
+   $Script:CompletedActivities++
+   $Script:PercentComplete=(100.0/$TotalActivities)*$Script:CompletedActivities
+   $Script:PercentComplete=[Math]::Min(99,$PercentComplete)
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ResolveIPAddress{Param([IPAddress][Parameter(Mandatory=$True)]$IP,[Parameter(Mandatory=$True)]$FQDN)
+    $SubDomain=($FQDN.Split(".")[1])    
+    Try{
+        If($IP-eq0.0.0.0){
+            $AddressList=([System.Net.Dns]::GetHostEntry($FQDN).AddressList)
+            $IP=$AddressList.IPAddressToString
+            $1st=($IP.Split(".")[0]);$2nd=($IP.Split(".")[1]);$3rd=($IP.Split(".")[2]);$4th=($IP.Split(".")[3])
+            $ReverseZone=($3rd+"."+$2nd+"."+$1st+".in-addr.arpa")
+            Add-DnsServerResourceRecordPtr -Name ($4th) -ZoneName ($ReverseZone) -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $FQDN
+            Return $AddressList
+        }Else{
+            $ComputerName=[System.Net.Dns]::GetHostEntry($IP).HostName
+            Return ($ComputerName.ToLower())
+        }
+    }Catch{
+        $FQDN=($NetBIOS+"."+$SubDomain+"."+$Domain).ToLower()
+        If($_.Exception.Message-eq'Exception calling "GetHostByAddress" with "1" argument(s): "The requested name is valid, but no data of the requested type was found"'){
+            $1st=($IP.Split(".")[0]);$2nd=($IP.Split(".")[1]);$3rd=($IP.Split(".")[2]);$4th=($IP.Split(".")[3])
+            $ReverseZone=($3rd+"."+$2nd+"."+$1st+".in-addr.arpa")
+            Add-DnsServerResourceRecordPtr -Name ($4th) -ZoneName ($ReverseZone) -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $FQDN
+        }ElseIf($_.Exception.Message-eq'Exception calling "GetHostByName" with "1" argument(s): "No such host is known"'){
+            $ForwardZone=(($FQDN.Split(".")[1])+"."+$Domain).ToLower()
+            Add-DnsServerResourceRecordA -Name $ComputerName -ZoneName ($ForwardZone) -AllowUpdateAny -IPv4Address $IP -TimeToLive 01:00:00 -CreatePtr
+        }Else{
+            Write-Host $_.Exception.Message -ForegroundColor Green
+        }
+    }
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$True)]$SecureUser,[String][Parameter(Mandatory=$True)]$Domain)
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|ForEach-Object{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$True)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|ForEach-Object{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$False){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $Script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Function Test-OpenPort{[CmdletBinding()]Param([Parameter(Position=0)]$Target='localhost', 
+[Parameter(Mandatory=$True,Position=1,Helpmessage='Enter Port Numbers. Separate them by comma.')]$Port)
+    $Result=@()
+    ForEach($T In $Target){
+        ForEach($P In $Port){
+            $A=Test-NetConnection -ComputerName $T -Port $P -WarningAction SilentlyContinue
+            $Result+=New-Object -TypeName PSObject -Property ([ordered]@{'Target'=$A.ComputerName;'RemoteAddress'=$A.RemoteAddress;'Port'=$A.RemotePort;'Status'=$A.tcpTestSucceeded})
+        }
+    }
+    Return $Result
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$True)]$String,[String][Parameter(Mandatory=$True)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $False
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Switch($DomainUser){
+    {($_-like"sy10*")-or($_-like"sy60*")}{Break}
+    Default{$DomainUser=(("sy1000829946@"+$Domain).ToLower());Break}
+}
+$Validate=SetCredentials -SecureUser $DomainUser -Domain ($Domain).Split(".")[0]
+If(!($SecureCredentials)){$SecureCredentials=get-credential};$Validate=$null
+#Load PowerCli Context
+$Script:PromptForCEIP=$False
+$ModuleList=@(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+)
+$ProductName="PowerCli"
+$ProductShortName="PowerCli"
+$LoadingActivity="Loading $ProductName"
+$Script:CompletedActivities=0
+$Script:StartTime=$DateTime
+$Script:PercentComplete=0
+$Script:Reason=""
+$Script:VMGuest=$null
+$Script:Validate=$null
+$Script:LastBootProp=@()
+$Script:CurrentActivity=""
+$Script:ServerList="ServerList.txt"
+$Script:WorkingPath=($env:USERPROFILE+"\Desktop")
+$Script:ProcessList=($WorkingPath+"\"+$ServerList)
+$Script:totalActivities=$ModuleList.Count+1
+LoadModules
+$PowerCliFriendlyVersion=[VMware.VimAutomation.Sdk.Util10.ProductInfo]::PowerCliFriendlyVersion
+$Host.ui.RawUI.WindowTitle=$PowerCliFriendlyVersion
+Try{
+	$configuration=Get-PowerCliConfiguration -Scope Session
+	If($PromptForCEIP-and!($configuration.ParticipateInCEIP)-and[VMware.VimAutomation.Sdk.Util10Ps.CommonUtil]::InInteractiveMode($Host.UI)){
+		$caption="Participate in VMware Customer Experience Improvement Program (CEIP)"
+		$Message=`
+			"VMware's Customer Experience Improvement Program (`"CEIP`") provides VMware with information "+
+			"that enables VMware to improve its Products and services, to fix problems, and to advise you "+
+			"on how best to deploy and use our Products.  As part of the CEIP, VMware collects technical information "+
+			"about your organization’s use of VMware Products and services on a regular basis in association "+
+			"with your organization’s VMware license key(s).  This information does not personally identify "+
+			"any individual."+
+			"`n`nFor more details: press Ctrl+C to exit this prompt and type `"help about_ceip`" to see the related help article."+
+			"`n`nYou can join or leave the program at any time by executing: Set-PowerCliConfiguration -Scope User -ParticipateInCEIP `$True or `$False."
+		$AcceptLabel="&Join"
+		$choices=(
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList $AcceptLabel,"Participate in the CEIP"),
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList "&Leave","Don`t participate")
+		)
+		$userChoiceIndex = $Host.UI.PromptForChoice($caption, $Message, $choices, 0)
+		$Participate = $choices[$userChoiceIndex].Label -eq $AcceptLabel
+		If($Participate){
+            [VMware.VimAutomation.Sdk.Interop.V1.CoreServiceFactory]::CoreService.CeipService.JoinCeipProgram();
+        }Else{
+            Set-PowerCliConfiguration -Scope User -ParticipateInCEIP $False -Confirm:$False | Out-Null
+        }
+    }
+}Catch{}
+Write-Progress -Activity $LoadingActivity -Completed
+#Connect vSphere
+$Validate=Connect-VIServer -Server $vSphere -credential $SecureCredentials;Clear-Host
+$LastBootProp=@{Name='LastBootTime';Expression={(Get-Date)-(New-TimeSpan -Seconds $_.Summary.QuickStats.UptimeSeconds)}}
+If($Validate){
+    If((Get-Service -Name sshd).Status-eq"Stopped"){
+        Start-Service sshd
+        Set-Service -Name sshd -StartupType 'Automatic'
+        Get-NetFirewallRule -Name *ssh*
+    }
+    If(Test-Path -Path $ExcludedFile){Remove-Item $ExcludedFile -ErrorAction $ErrorActionPreference}
+    If(Test-Path -Path $PoweredOffFile){Remove-Item $PoweredOffFile -ErrorAction $ErrorActionPreference}
+    If(Test-Path -Path $LogFile){Remove-Item $LogFile -ErrorAction $ErrorActionPreference}
+    $Reason=("["+$SecureCredentials.UserName+"] was successfully connected to: ["+$vSphere+"}")
+    ("Beginning to process script because "+$Reason+".")|Out-File $ExcludedFile -Append
+    ("Beginning to process script because "+$Reason+".")|Out-File $PoweredOffFile -Append
+    ("Beginning to process script because "+$Reason+".")|Out-File $LogFile -Append
+    ("<<<"+$Separator+">>>")|Out-File $LogFile -Append
+    Write-Host ("Beginning to process script because "+$Reason+".") -ForegroundColor Cyan -BackgroundColor DarkBlue
+    If(!(Test-Path -Path ($ProcessList))){
+        (Get-VM).Name|Sort-Object|Out-File ($ProcessList)
+    }
+    #Health Check
+<#
+    Foreach($Server In [System.IO.File]::ReadLines($ProcessList)){
+        $FQDN=$null
+        $Bypass=$True
+        $NetBIOS=$null
+        $VMStatus=$null
+        $HostName=$null
+        $SubDomain="inf"
+        $IPAddress=$null
+        $ServerName=$null
+        $FolderName=$null
+        $DateTime=Get-Date
+        $PowerState="PoweredOff"
+        $IPAddressToString=$null
+        $VMStatus=Get-VM|Where-Object{$_.Name-like($Server)}|Select *
+        If($Server-like"*.*"){
+            $Server=(($Server).Split(("."))[0])
+        }
+        $Sender=($Server+"@utsystem.edu")
+        If($VMStatus-ne$null){
+            $Hostname=$VMStatus.Name
+            $PowerState=$VMStatus.PowerState
+            $FolderName=($VMStatus.Folder).Name
+            If($FolderName-eq"UTD IaaS (Root)"){
+                $Reason=("host VM is not being managed by our team")
+            }Else{
+                If(($PowerState-eq"PoweredOn")-and($PowerState-ne$null)){
+                    $FQDN=(Get-VM $Hostname).Guest.HostName
+                    If($Hostname-like"*.*"){
+                        $NetBIOS=($FQDN.Split(".")[0])
+                        $SubDomain=($FQDN.Split(".")[1])
+                    }Else{
+                        $NetBIOS=$Hostname
+                    }
+                    Try{
+                        $IPAddressToString=([System.Net.Dns]::GetHostEntry($FQDN).AddressList).IPAddressToString
+                    }Catch{
+                        $IPAddressToString=(ResolveIPAddress -IP "0.0.0.0" -NetBIOS $FQDN -Environment $SubDomain).IPAddressToString
+                    }
+                    If($IPAddressToString-ne$null){
+                        ForEach($IP In $IPAddressToString){
+                            If(($IP-ne$null)-and($IP.Split(".")[0]-eq"10")-and{($IP.Split(".")[1]-eq"118")-or($IP.Split(".")[1]-eq"126")}){
+                                $ServerName=ResolveIPAddress -IP $IP -FQDN $FQDN
+                                If($ServerName-ne$null){
+                                    $Bypass=$False
+                                }Else{
+                                    $Bypass=$True
+                                }
+                            }Else{
+                                $Reason=("host VM has an invalid IP Address: ["+$IP+"]")
+                            }
+                        }
+                    }Else{
+                        $Reason=("host VM isn`t registered in DNS")
+                    }
+                }Else{
+                    $Reason=("host VM is currently powered off")
+                }
+            }
+        }
+        Write-Host ("Currently working on hostname(VM): '"+$Hostname+"' and is currently: "+$PowerState)
+        If(($PowerState-eq"PoweredOn")-and($Bypass-eq$False)){
+            ("Currently working on hostname(VM): ["+$Hostname+"] and is currently: powered on.")|Out-File $LogFile -Append
+            Try{
+                If(Test-Connection -ComputerName $FQDN -Count 3 -BufferSize 256 -ThrottleLimit 32){
+                    (“`tTesting connection to $ServerName is successful”)|Out-File $LogFile -Append
+                }Else{
+                    $EndTime=Get-Date
+                    "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" not responding") -Body ($ServerName+" not responding, waiting 10 seconds and will try again.") -SmtpServer $MailServer
+                    "Waiting 10 seconds"
+                    Start-Sleep 10
+                    If(!(Test-Connection -ComputerName $FQDN -Count 3 -BufferSize 256 -ThrottleLimit 32)){
+                        $EndTime=Get-Date
+                        "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                        (Get-VM -Name $Hostname).ExtensionData.ResetVM() 
+#                        Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ("Server: '"+$ServerName+"' crashed!") -Body ($ServerName+" must have crashed and was reset.") -SmtpServer $MailServer
+                        Start-Sleep 30
+                    }Else{
+                        $EndTime=Get-Date
+                        “Successful `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                        Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" is responding") -Body ($ServerName+" is responding again and was not reset.") -SmtpServer $MailServer
+                    }
+                }
+            }Catch{}
+        }Else{
+            ("Bypassing ["+$Server+"] because "+$Reason+".")|Out-File $LogFile -Append
+        }
+        ("----------------------------------------------------------------------------------------------------")|Out-File $LogFile -Append
+    }
+#>
+    $VM=$null
+    $Script:EXCount=0
+    $Script:POCount=0
+    $Script:VMCount=0
+    $Script:VMProcessed=0
+    ForEach($VMGuest In [System.IO.File]::ReadLines($ProcessList)){
+        $VMLabel=Get-View -Filter @{"Name"="^$VMGuest$"} -ViewType VirtualMachine -Property Name, Summary.QuickStats.UptimeSeconds|Select-Object Name,$LastBootProp
+        ForEach($VM In $VMLabel){
+            $FQDN=""
+            $LineCount=0
+            $ByPass=$False
+            $VMTools=$null
+            $VMStatus=$null
+            $IPAddress=$null
+            $DnsError=$False
+            $SystemDetails=$null
+            [System.Net.IPAddress]$IPAddress=@()
+            If(Test-Path -Path $TempFile){Remove-Item $TempFile}
+            If(($VM.Name-eq$VMGuest)-or($VM-eq$VMGuest)){
+                $VMCount++
+                Write-Host ("Beginning to process: "+$VMGuest)
+                $FQDN=((Get-VM $VMGuest).Guest.HostName).ToLower()
+                $VMStatus=Get-VM|Where-Object{$_.Name-like($VMGuest)}|Select-Object *
+                $OSState=$VMStatus.Guest.State
+                $IPAddress+=@($VMStatus.Guest.IPAddress)
+                $OSFullName=$VMStatus.Guest.OSFullName
+                If((!($FQDN))-or($FQDN-eq"")){
+                    $FQDN=$VMGuest
+                }
+                ("VMWare object name: ["+$VMGuest+"] is being processed at this time.")|Out-File $TempFile -Append
+                ("`tGuest system: ["+$FQDN+"] was last rebooted on: ["+$VMLabel.LastBootTime+"].")|Out-File $TempFile -Append
+                ("`tThe current state of: ["+$FQDN+"] is:")|Out-File $TempFile -Append
+                ("`tHost (ESXi):`t`t"+$VMStatus.VMHost)|Out-File $TempFile -Append
+                ("`tPower state:`t`t"+$VMStatus.PowerState)|Out-File $TempFile -Append
+                ("`tOperating System:`t"+$OSFullName)|Out-File $TempFile -Append
+                ("`tOS Status:`t`t"+$OSState)|Out-File $TempFile -Append
+                ("`tIP Address(es):`t`t"+$IPAddress)|Out-File $TempFile -Append
+                ("`tCPU count:`t`t"+$VMStatus.NumCpu)|Out-File $TempFile -Append
+                ("`tCores Per Socket:`t"+$VMStatus.CoresPerSocket)|Out-File $TempFile -Append
+                ("`tMemory in MB:`t`t"+$VMStatus.MemoryMB)|Out-File $TempFile -Append
+                ("`tFolder:`t`t`t"+$VMStatus.Folder)|Out-File $TempFile -Append
+                ("`tSpace used in GB:`t"+$VMStatus.UsedSpaceGB)|Out-File $TempFile -Append
+                ("`tProvisioned in GB:`t"+$VMStatus.ProvisionedSpaceGB)|Out-File $TempFile -Append
+                If($ExcludedFolders-like("*"+$VMStatus.Folder.Name+"*")){
+                    ("****`tBypassing ["+$FQDN+"] because it's in the excluded folder: ["+$VMStatus.Folder+"].`t****")|Out-File $LogFile -Append
+                    ("<<<"+$Separator+">>>")|Out-File $ExcludedFile -Append
+                    $SystemDetails=Get-Content -Path $TempFile
+                    ForEach($Line In $SystemDetails){
+                        ($Line)|Out-File $ExcludedFile -Append
+                    }
+                    $ByPass=$True
+                    $EXCount++
+                }ElseIf($VMStatus.PowerState-eq"PoweredOff"){
+                    ("****`tBypassing ["+$FQDN+"] because it's power state is currently ["+$VMStatus.PowerState+"].`t****")|Out-File $LogFile -Append
+                    ("<<<"+$Separator+">>>")|Out-File $PoweredOffFile -Append
+                    $SystemDetails=Get-Content -Path $TempFile
+                    ForEach($Line In $SystemDetails){
+                        ($Line)|Out-File $PoweredOffFile -Append
+                    }
+                    $ByPass=$True
+                    $POCount++
+                }Else{
+                    $SystemDetails=Get-Content -Path $TempFile
+                    ForEach($Line In $SystemDetails){
+                        ($Line)|Out-File $LogFile -Append
+                    }
+                    Try{
+                        $IPAddressToString=([System.Net.Dns]::GetHostEntry($FQDN).AddressList).IPAddressToString
+                        ("`t"+$VMGuest+" is returning: ["+$FQDN+"] as the FQDN with an IP Address of ["+$IPAddressToString+"].")|Out-File $LogFile -Append
+                    }Catch{
+                        $DnsError=$True
+                        Switch($FQDN){
+                            {($_-like"*."+$Domain)}{$DnsError=$False;Break}
+                            {($_-like"*.edu")}{$DnsError=$False;Break}
+                        }
+                        If($DnsError-eq$True){
+                            $FQDN=$VMGuest
+                        }
+                        ("`t["+$FQDN+"] failed to return DNS information using the Hostname.")|Out-File $LogFile -Append
+                        $Error.Clear()
+                        If(($ByPass-eq$False)-and(!($IPAddress))){
+                            $IPAddressToString=ResolveIPAddress -IP $IPAddress -FQDN $FQDN
+                            $FQDN=([System.Net.Dns]::GetHostEntry("($IPAddress)").Hostname)
+                        }
+                    }
+                }
+                If(($ByPass-eq$False)-and(($FQDN-ne"")-or(!($FQDN)))){
+                    Write-Host ("`tVerifying a running and health state for ["+$FQDN+"].")
+                    $VMTools=Get-View -ViewType VirtualMachine -Filter @{"Name"="^$VMGuest$"}|Select-Object Name,
+                        @{N="HW Version";E={$_.Config.version}},
+                        @{N='VMware Tools Status';E={$_.Guest.ToolsStatus}},
+                        @{N="VMware Tools version";E={$_.Config.Tools.ToolsVersion}}
+                    ("`tHardware version:`t"+$VMTools.'HW Version')|Out-File $LogFile -Append
+                    ("`tvmtools version:`t"+$VMTools.'VMware Tools version')|Out-File $LogFile -Append
+                    ("`tvmtools status:`t"+$VMTools.'VMware Tools Status')|Out-File $LogFile -Append
+                    If($OSState-eq"Running"){
+                        $TestPort=$null
+                        $PortCheck=$null
+                        $TraceRoute=$null
+                        $RemoteTest=$null
+                        $PingResults=$null
+                        $TestReturn=Test-NetConnection -ComputerName $FQDN -TraceRoute
+                        If($TestReturn){
+                            $PingResults=$TestReturn.PingSucceeded
+                            $TraceRoute=@($TestReturn.TraceRoute)
+                            Switch($OSFullName){
+                                {($_-like"Microsoft*")}{$PortCheck=3389;Break}
+                                Default{$PortCheck=22;Break}
+                            }
+                            If($PingResults){
+                                ("`t"+$FQDN+" successfully returned a ping with a TTL of "+$TestReturn.PingReplyDetails.RoundtripTime+" ms.")|Out-File $LogFile -Append
+                                $TestPort=Test-OpenPort -Target $FQDN -Port $PortCheck
+                            }
+                        }
+                        If($TestPort.Status-eq$True){
+                            ("`tSuccessfully connected to ["+$TestPort.Target+"] on port ["+$TestPort.Port+"].")|Out-File $LogFile -Append
+                            Switch($OSFullName){
+                                {($_-like"Microsoft*")}{
+                                    Write-Host("`tConnecting to "+$FQDN+".")
+                                    ("`tAttempting to remotely connect to "+$FQDN+".")|Out-File $LogFile -Append
+                                    Try{
+                                        $RemoteTest=Test-WSMan -ComputerName $FQDN -Credential $SecureCredentials -Authentication Default
+                                        $RemoteTest=$True
+                                    }Catch{
+                                        Write-Host $_.Exception.Message
+                                        $RemoteTest=$False
+                                        $Error.Clear()
+                                    }
+                                    Break
+                                }
+                                Default{
+                                    $RemoteTest=Test-OpenPort -Target $FQDN -Port 22
+                                    Break
+                                }
+                            }
+                        }Else{
+                            ("`tFailed to connected to ["+$TestPort.Target+"] on port ["+$TestPort.Port+"].")|Out-File $LogFile -Append
+                            $ResetHost+=($FQDN)
+                        }
+                    }Else{}
+                }
+            }
+        }
+        ("<<<"+$Separator+">>>")|Out-File $LogFile -Append
+    }
+    $AttachmentList=$null
+    $VMProcessed=([int]$VMCount-([int]$EXcount+[int]$POCount))
+    $Sender=($vSphere.Split(".")[0]+"@"+$Domain)
+    $SendTo=("Bob Stobie <$($SendTo)>")
+#    $SendTo=("GRP-SIS_SysAdmin <$($SendTo)>")
+    $Message=("Start Time: "+$StartTime+"`n`n")
+    $Message+=("The attachment: ["+$ServerList+"] is a list of ["+$VMCount+"] systems that were processed for being reset.  ")
+    $Message+=("The second attachment are the results from each VM of the ["+$VMProcessed+"] VMs processed from the ["+$LogName+"] file.  ")
+    $AttachmentList=@($ProcessList,$LogFile)
+    If($EXcount-gt0){
+        $AttachmentList+=($ExcludedFile)
+        $Message+=("The third attachment ["+$ExcludedName+"] is a list of ["+$EXcount+"] systems that have been marked as excluded.  ")
+    }Else{
+        $Message+=("The attachment ["+$ExcludedName+"] was not included because there were ["+$EXcount+"] systems that were excluded.  ")
+    }
+    If($POCount-gt0){
+        $AttachmentList+=($PoweredOffFile)
+        $Message+=("The last attachment ["+$PoweredOffName+"] is a list of ["+$POCount+"] systems that are currently powered off and won't be reset.")
+    }Else{
+        $Message+=("The attachment ["+$PoweredOffName+"] was not included because there were ["+$POcount+"] systems that were powered off.")
+    }
+    $Message+=("`n`nEnd Time: "+(Get-Date))
+    Send-MailMessage -From "<$($Sender)>" -To $SendTo -Subject ("Summary of VMWare systems from Site-"+$SiteCode+"") -Body $Message -Attachments $AttachmentList -SmtpServer $MailServer
+}Else{
+    $Reason=("["+$SecureCredentials.UserName+"] was unable to connect to: ["+$vSphere+"}")
+    ("Failed to beginning process script because "+$Reason+".")|Out-File $LogFile -Append
+    Write-Host ("Failed to beginning process script because "+$Reason+".") -ForegroundColor Yellow -BackgroundColor DarkRed
+}
+$Message=$null;$Reason=$null;$VMProcessed=0;$VMCount=0;$EXcount=0;$POCount=0
+Rename-Item -Path ($ProcessList) -NewName "ProcessedList.txt" -Force
+Disconnect-VIServer -Server $global:DefaultVIServers -Force
+Set-Location ($env:SystemRoot+"\System32")
\ No newline at end of file
diff --git a/backup/ResetFailedVM_bk0.ps1 b/backup/ResetFailedVM_bk0.ps1
new file mode 100644
index 0000000..aff4864
--- /dev/null
+++ b/backup/ResetFailedVM_bk0.ps1
@@ -0,0 +1,339 @@
+﻿Clear-Host;Clear-History
+$Global:Validate=$null
+$Global:Domain=("utshare.local")
+$Global:DomainUser=(($env:USERNAME+"@"+$Domain).ToLower())
+$ScriptPath=$MyInvocation.MyCommand.Definition
+$ScriptName=$MyInvocation.MyCommand.Name
+Set-Location ($ScriptPath.Replace($ScriptName,""))
+Set-Variable -Name DateTime -Value (Get-Date)
+Set-Variable -Name SecureCredentials -Value $null
+Set-Variable -Name vSphere -Value ("vcmgr01a.inf."+$Domain)
+Set-Variable -Name LogFile -Value ($ScriptName.Replace("ps1","log"))
+Set-Variable -Name LogFile -Value ($env:USERPROFILE+"\Desktop\"+$LogFile)
+Set-Variable -Name SendTo -Value ("GRP-SIS_SysAdmin@utsystem.edu")
+Set-Variable -Name MailServer -Value ("mail.utshare.utsystem.edu")
+Set-Variable -Name EndTime -Value $null
+Set-Variable -Name Sender -Value $null
+Function LoadModules(){
+   ReportStartOfActivity "Searching for $ProductShortName module components..."
+   $Loaded=Get-Module -Name $ModuleList -ErrorAction Ignore|% {$_.Name}
+   $Registered=Get-Module -Name $ModuleList -ListAvailable -ErrorAction Ignore|% {$_.Name}
+   $NotLoaded=$Registered|? {$Loaded -notcontains $_}
+   ReportFinishedActivity
+   Foreach($Module In $Registered){
+      If($Loaded -notcontains $Module){
+		 ReportStartOfActivity "Loading module $Module"
+		 Import-Module $Module
+		 ReportFinishedActivity
+      }
+   }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function ReportStartOfActivity($Activity){
+   $Script:CurrentActivity=$Activity
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ReportFinishedActivity(){
+   $Script:CompletedActivities++
+   $Script:PercentComplete=(100.0/$TotalActivities)*$Script:CompletedActivities
+   $Script:PercentComplete=[Math]::Min(99,$PercentComplete)
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$true)]$SecureUser="",[String][Parameter(Mandatory=$true)]$Domain="")
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $Script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Switch($DomainUser){
+    {($_-like"sy10*")-or($_-like"sy60*")}{Break}
+    Default{$DomainUser=(("sy1000829946@"+$Domain).ToLower());Break}
+}
+$Validate=SetCredentials -SecureUser $DomainUser -Domain ($Domain).Split(".")[0]
+If($SecureCredentials-eq$null){$SecureCredentials=get-credential};$Validate=$null
+
+#Load PowerCli Context
+$Script:PromptForCEIP=$false
+$ModuleList=@(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+)
+$ProductName="PowerCli"
+$ProductShortName="PowerCli"
+$LoadingActivity="Loading $ProductName"
+$Script:CompletedActivities=0
+$Script:PercentComplete=0
+$Script:CurrentActivity=""
+$Script:totalActivities=$ModuleList.Count+1
+LoadModules
+$PowerCliFriendlyVersion=[VMware.VimAutomation.Sdk.Util10.ProductInfo]::PowerCliFriendlyVersion
+$Host.ui.RawUI.WindowTitle=$PowerCliFriendlyVersion
+Try{
+	$configuration=Get-PowerCliConfiguration -Scope Session
+	If($PromptForCEIP-and$configuration.ParticipateInCEIP-eq$null-and[VMware.VimAutomation.Sdk.Util10Ps.CommonUtil]::InInteractiveMode($Host.UI)){
+		$caption="Participate in VMware Customer Experience Improvement Program (CEIP)"
+		$message=`
+			"VMware's Customer Experience Improvement Program (`"CEIP`") provides VMware with information "+
+			"that enables VMware to improve its Products and services, to fix problems, and to advise you "+
+			"on how best to deploy and use our Products.  As part of the CEIP, VMware collects technical information "+
+			"about your organization’s use of VMware Products and services on a regular basis in association "+
+			"with your organization’s VMware license key(s).  This information does not personally identify "+
+			"any individual."+
+			"`n`nFor more details: press Ctrl+C to exit this prompt and type `"help about_ceip`" to see the related help article."+
+			"`n`nYou can join or leave the program at any time by executing: Set-PowerCliConfiguration -Scope User -ParticipateInCEIP `$true or `$false."
+		$AcceptLabel="&Join"
+		$choices=(
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList $AcceptLabel,"Participate in the CEIP"),
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList "&Leave","Don't participate")
+		)
+		$userChoiceIndex = $Host.UI.PromptForChoice($caption, $message, $choices, 0)
+		$participate = $choices[$userChoiceIndex].Label -eq $AcceptLabel
+		If($participate){
+            [VMware.VimAutomation.Sdk.Interop.V1.CoreServiceFactory]::CoreService.CeipService.JoinCeipProgram();
+        }Else{
+            Set-PowerCliConfiguration -Scope User -ParticipateInCEIP $false -Confirm:$false | Out-Null
+        }
+    }
+}Catch{}
+Write-Progress -Activity $LoadingActivity -Completed
+
+#Connect vSphere
+$Validate=Connect-VIServer -Server $vSphere -credential $SecureCredentials;Clear
+If($Validate-ne$null){
+    If(!(Test-Path -Path ($env:USERPROFILE+"\Desktop\ServerList.txt"))){
+        (Get-VM).Name|Out-File ($env:USERPROFILE+"\Desktop\ServerList.txt")
+    }
+    If(Test-Path -Path $LogFile){Remove-Item $LogFile -ErrorAction SilentlyContinue}
+    #Health Check
+    Foreach($Server In [System.IO.File]::ReadLines($env:USERPROFILE+"\Desktop\ServerList.txt")){
+        $Bypass=$false
+        $HostName=$null
+        $IPAddress=$null
+        $ServerName=$null
+        $PowerState="N/A"
+        $DateTime=Get-Date
+        $Sender=(($Server).Split(".")[0]+"@utsystem.edu")
+        $VMStatus=Get-VM|Where-Object{$_.Name-like(($Server).Split(".")[0]+"*")}
+        If($VMStatus-ne$null){
+            $Hostname=$VMStatus.Name
+            $PowerState=$VMStatus.PowerState
+            If($PowerState-eq"PoweredOn"){
+                $IPAddress=(Get-VM -Name $Hostname|Select Name,VMHost,@{N='IP';E={$_.Guest.IPAddress[0]}}).IP
+                If(($IPAddress-ne$null)-and($IPAddress.Split(".")[0]-eq"10")-and{($IPAddress.Split(".")[1]-eq"118")-or($IPAddress.Split(".")[1]-eq"126")}){
+                    $ServerName=[System.Net.Dns]::GetHostByAddress($IPAddress).HostName
+                }Else{
+                    $Reason=("host VM has an invalid IP Address: ["+$IPAddress+"]")
+                    $Bypass=$true
+                }
+            }Else{
+                $Reason=("host VM is currently powered off")
+            }
+        }
+        Write-Host ("Currently working on hostname(VM): '"+$Hostname+"' and is currently: "+$PowerState)
+        If(($PowerState-eq"PoweredOn")-and($Bypass-eq$false)){
+            ("Currently working on hostname(VM): ["+$Hostname+"] and is currently: powered on.")|Out-File $LogFile -Append
+            If(Test-Connection -Cn $ServerName -BufferSize 16 -Count 1 -ea 0 -quiet){
+                (“`tTesting connection to $ServerName is successful”)|Out-File $LogFile -Append
+#                Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" is responding") -Body ($ServerName+" is responding again.") -SmtpServer $MailServer
+            }ElseIf(!(Test-Connection -Cn $ServerName -BufferSize 16 -Count 1 -ea 0 -quiet)){
+                $EndTime=Get-Date
+                "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" not responding") -Body ($ServerName+" not responding, waiting 10 seconds and will try again.") -SmtpServer $MailServer
+                "Waiting 10 seconds"
+                Start-Sleep 10
+                If(!(Test-Connection -Cn $ServerName -BufferSize 16 -Count 4 -ea 0 -quiet)){
+                    $EndTime=Get-Date
+                    "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                    (Get-VM -Name $Hostname).ExtensionData.ResetVM() 
+#                    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ("Server: '"+$ServerName+"' crashed!") -Body ($ServerName+" must have crashed and was reset.") -SmtpServer $MailServer
+                    Start-Sleep 30
+                }Else{
+                    $EndTime=Get-Date
+                    “Successful `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" is responding") -Body ($ServerName+" is responding again and was not reset.") -SmtpServer $MailServer
+                }
+            }
+        }Else{
+            ("Bypassing ["+$Server+"] because "+$Reason+".")|Out-File $LogFile -Append
+        }
+        ("----------------------------------------------------------------------------------------------------")|Out-File $LogFile -Append
+    }
+}
+Set-Location ($env:SystemRoot+"\System32")
\ No newline at end of file
diff --git a/backup/ResetFailedVM_bk1.ps1 b/backup/ResetFailedVM_bk1.ps1
new file mode 100644
index 0000000..d0e6f31
--- /dev/null
+++ b/backup/ResetFailedVM_bk1.ps1
@@ -0,0 +1,489 @@
+﻿Clear-Host;Clear-History
+$Global:Validate=$null
+$Global:Domain=("utshare.local")
+$Global:DomainUser=(($env:USERNAME+"@"+$Domain).ToLower())
+$Global:DnsServer=("dca01."+$Domain)
+$Global:ExcludedFolders=@("UTD IaaS (Root)")
+$ScriptPath=$MyInvocation.MyCommand.Definition
+$ScriptName=$MyInvocation.MyCommand.Name
+$ErrorActionPreference='SilentlyContinue'
+Set-Location ($ScriptPath.Replace($ScriptName,""))
+Set-Variable -Name DateTime -Value (Get-Date)
+Set-Variable -Name SecureCredentials -Value $null
+Set-Variable -Name vSphere -Value ("vcmgr01a.inf."+$Domain)
+Set-Variable -Name LogFile -Value ($ScriptName.Replace("ps1","log"))
+Set-Variable -Name LogFile -Value ($env:USERPROFILE+"\Desktop\"+$LogFile)
+Set-Variable -Name SendTo -Value ("GRP-SIS_SysAdmin@utsystem.edu")
+Set-Variable -Name MailServer -Value ("mail.utshare.utsystem.edu")
+Set-Variable -Name EndTime -Value $null
+Set-Variable -Name Sender -Value $null
+Function LoadModules(){
+   ReportStartOfActivity "Searching for $ProductShortName module components..."
+   $Loaded=Get-Module -Name $ModuleList -ErrorAction Ignore|% {$_.Name}
+   $Registered=Get-Module -Name $ModuleList -ListAvailable -ErrorAction Ignore|% {$_.Name}
+   $NotLoaded=$Registered|? {$Loaded -notcontains $_}
+   ReportFinishedActivity
+   Foreach($Module In $Registered){
+      If($Loaded -notcontains $Module){
+		 ReportStartOfActivity "Loading module $Module"
+		 Import-Module $Module
+		 ReportFinishedActivity
+      }
+   }
+}
+Function Protect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{      
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        Return ConvertTo-SecureString $String -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey
+    }
+    End{}
+}
+Function ReportStartOfActivity($Activity){
+   $Script:CurrentActivity=$Activity
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ReportFinishedActivity(){
+   $Script:CompletedActivities++
+   $Script:PercentComplete=(100.0/$TotalActivities)*$Script:CompletedActivities
+   $Script:PercentComplete=[Math]::Min(99,$PercentComplete)
+   Write-Progress -Activity $LoadingActivity -CurrentOperation $Script:CurrentActivity -PercentComplete $Script:PercentComplete
+}
+Function ResolveIPAddress{Param([String][Parameter(Mandatory=$true)]$IP="",[Parameter(Mandatory=$true)]$FQDN="")
+    Try{
+        If($IP-eq"0.0.0.0"){
+            $AddressList=([System.Net.Dns]::GetHostByName($FQDN).AddressList)
+            $IP=$AddressList.IPAddressToString
+            $1st=($IP.Split(".")[0]);$2nd=($IP.Split(".")[1]);$3rd=($IP.Split(".")[2]);$4th=($IP.Split(".")[3])
+            $ReverseZone=($3rd+"."+$2nd+"."+$1st+".in-addr.arpa")
+            Add-DnsServerResourceRecordPtr -Name ($4th) -ZoneName ($ReverseZone) -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $FQDN
+            Return $AddressList
+        }Else{
+            $ComputerName=[System.Net.Dns]::GetHostByAddress($IP).HostName
+            Return ($ComputerName.ToLower())
+        }
+    }Catch{
+        $FQDN=($NetBIOS+"."+$env+"."+$Domain).ToLower()
+        If($_.Exception.Message-eq'Exception calling "GetHostByAddress" with "1" argument(s): "The requested name is valid, but no data of the requested type was found"'){
+            $1st=($IP.Split(".")[0]);$2nd=($IP.Split(".")[1]);$3rd=($IP.Split(".")[2]);$4th=($IP.Split(".")[3])
+            $ReverseZone=($3rd+"."+$2nd+"."+$1st+".in-addr.arpa")
+            Add-DnsServerResourceRecordPtr -Name ($4th) -ZoneName ($ReverseZone) -AllowUpdateAny -TimeToLive 01:00:00 -AgeRecord -PtrDomainName $FQDN
+        }ElseIf($_.Exception.Message-eq'Exception calling "GetHostByName" with "1" argument(s): "No such host is known"'){
+            $ForwardZone=(($FQDN.Split(".")[1])+"."+$Domain).ToLower()
+            Add-DnsServerResourceRecordA -Name $ComputerName -ZoneName ($ForwardZone) -AllowUpdateAny -IPv4Address $IP -TimeToLive 01:00:00 -CreatePtr
+        }Else{
+            Write-Host $_.Exception.Message -ForegroundColor Green
+        }
+    }
+}
+Function SetCredentials{[CmdletBinding()]Param([String][Parameter(Mandatory=$true)]$SecureUser="",[String][Parameter(Mandatory=$true)]$Domain="")
+    Set-Variable -Name WorkingPath -Value ($($env:USERProfile)+"\AppData\Local\Credentials\"+$($Domain))
+    Set-Variable -Name SecureFile -Value ("$WorkingPath\"+$($SecureUser.Split("@")[0])+".pwd")
+    If(Test-Path -Path $SecureFile){
+        Set-Variable -Name Extensions -Value @("pwd","key")
+        Set-Variable -Name KeyDate -Value $null
+        Set-Variable -Name PwdDate -Value $null
+        ForEach($FileType In $Extensions){
+            $Results=Get-ChildItem -Path $WorkingPath
+            $Extension=$($Results.Name).Split(".")[1]
+            If($Extension-eq$FileType){
+                $PwdDate=$($Results.CreationTime)[1]
+                If($KeyDate.Date-ne$PwdDate.Date){
+                    Set-Variable -Name SecureString -Value 0
+                }Else{
+                    $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+                    $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }Else{
+                $KeyDate=$($Results.CreationTime)[0]
+                $KeyName=$($Results.Name).Split(".")[0]
+                If(([System.Text.Encoding]::Unicode).GetByteCount($KeyName)*8-notin"128,192,256"){
+                    $EncryptionKeyFile="$WorkingPath\$KeyName.$Extension"
+                    $SecureKey=ConvertTo-SecureString -String $KeyName -AsPlainText -Force
+                    $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                    $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                    $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                }
+            }
+        }
+    }Else{
+        $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+        $Encrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+        Set-Variable -Name "EncryptionKeyFile" -Value ""
+        Set-Variable -Name "Characters" -Value ""
+        Set-Variable -Name "PrivateKey" -Value ""
+        Set-Variable -Name "SecureKey" -Value ""
+        [String]$Key=0
+        [Int]$Min=8
+        [Int]$Max=1024
+        $Prompt="Enter the length you want to use for the security key: [8, 12, or 16]"
+        If($Prompt.Length-eq0){$Prompt=8}
+        [Int]$RandomKey=Read-Host -Prompt $Prompt
+        If(Test-Path $WorkingPath){
+            $Results=Get-ChildItem -Path $WorkingPath -File
+            ForEach($File In $Results){
+                $FileName=$($File.Name).Split(".")[0]
+                If($FileName.length-eq$RandomKey){
+                    $KeyFile="$($File.Name)"
+                    $Key=$($KeyFile).Split(".")[0]
+                    If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin"128,192,256"){
+                        $EncryptionKeyFile="$WorkingPath\$KeyFile"
+                        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+                        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+                        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+                        $UnEncrypted=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+                        Break
+                    }
+                }
+            }
+        }Else{
+            $Dir=MkDir $WorkingPath
+        }
+        If($PrivateKey.length-lt1){
+            Do{
+                Switch($RandomKey){
+                    {($_-eq8)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq12)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($_-eq16)}{
+                        $Key=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        $Key+=-join((48..57)|Get-Random -Count 4|%{[char]$_})
+                        Break
+                    }
+                    {($Key.length-lt$RandomKey)}{
+                        $RandomKey+=1
+                        Break
+                    }
+                    {($Key.length-gt$RandomKey)}{
+                        $RandomKey-=1
+                        Break
+                    }
+                    Default{
+                        $RandomKey=16
+                        Break
+                    }
+                }
+            }Until(($Key.length-eq8)-or($Key.length-eq12)-or($Key.length-eq16))
+            $i=0
+            Do{
+                $i++
+                If(Test-Path -Path $SecureFile){
+                    $SecureFile="$WorkingPath\Encrypted$i.pwd"
+                }
+            }While((Test-Path -Path $SecureFile)-eq$true)
+            $Prompt="Enter the amount of characters you want to use for the encryption key: [min $Min, max $Max]"
+            Do{
+                [Int]$Characters=Read-Host -Prompt $Prompt
+                If(($Characters-ge$Min)-and($Characters-le$Max)){
+                }Else{
+                    $Prompt="Please enter a value between the minimum '$Min' and maximum '$Max' range"
+                }
+            }Until(($Characters-ge$Min)-and($Characters-le$Max))
+            For($i=0;$i-le$Characters;$i++){
+                Switch($i){
+                    {($_-gt0)-and($_-le$Characters)}{$Set=-join((65..90)+(97..122)|Get-Random -Count 1|%{[Char]$_});Break}
+                    Default{$PrivateKey="";$Set="";Break}
+                }
+                $PrivateKey+=$Set
+            }
+            Set-Variable -Name "EncryptionKeyFile" -Value "$WorkingPath\$Key.key"
+            Protect-String $PrivateKey $Key|Out-File -Filepath $EncryptionKeyFile
+            $Validate=Unprotect-String $PrivateKey $Key
+            If($Validate-ne$false){
+                $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+            }Else{
+                $SecureString=Read-Host -Prompt "Enter your [$SecureUser] credentials" -AsSecureString
+            }
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $EncryptedString=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            $EncryptedString|ConvertTo-SecureString -AsPlainText -Force|ConvertFrom-SecureString -SecureKey $SecureKey|Out-File -FilePath $SecureFile
+        }
+        Try{
+            $SecureString=Get-Content -Path $SecureFile|ConvertTo-SecureString -SecureKey $SecureKey -ErrorAction Stop
+            $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString)
+            $Validate=[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+            If($EncryptedString-ceq$Validate){}
+        }Catch [Exception]{
+            $Message="Error: [Validation]: $($_.Exception.Message)";Write-Host $Message -ForegroundColor Yellow -BackgroundColor DarkRed
+            $EncryptedString=$null;$BSTR=$null
+        }
+    }
+    $EncryptedString=$null;$BSTR=$null
+    $Script:SecureCredentials=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $SecureUser,$SecureString
+    Return $Validate
+}
+Function Unprotect-String{[CmdletBinding()]param([String][Parameter(Mandatory=$true)]$String,[String][Parameter(Mandatory=$true)]$Key)
+    Begin{}
+    Process{
+        If(([System.Text.Encoding]::Unicode).GetByteCount($Key)*8-notin128,192,256){
+            Throw "Given encryption key has an invalid length.  The specified key must have a length of 128, 192, or 256 bits."
+            Return $false
+        }
+        $SecureKey=ConvertTo-SecureString -String $Key -AsPlainText -Force
+        $PrivateKey=Get-Content -Path $EncryptionKeyFile|ConvertTo-SecureString -SecureKey $SecureKey
+        $BSTR=[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($PrivateKey)
+        Return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
+    }
+    End{}
+}
+Switch($DomainUser){
+    {($_-like"sy10*")-or($_-like"sy60*")}{Break}
+    Default{$DomainUser=(("sy1000829946@"+$Domain).ToLower());Break}
+}
+$Validate=SetCredentials -SecureUser $DomainUser -Domain ($Domain).Split(".")[0]
+If($SecureCredentials-eq$null){$SecureCredentials=get-credential};$Validate=$null
+#Load PowerCli Context
+$Script:PromptForCEIP=$false
+$ModuleList=@(
+    "VMware.VimAutomation.Core",
+    "VMware.VimAutomation.Vds",
+    "VMware.VimAutomation.Cloud",
+    "VMware.VimAutomation.PCloud",
+    "VMware.VimAutomation.Cis.Core",
+    "VMware.VimAutomation.Storage",
+    "VMware.VimAutomation.HorizonView",
+    "VMware.VimAutomation.HA",
+    "VMware.VimAutomation.vROps",
+    "VMware.VumAutomation",
+    "VMware.DeployAutomation",
+    "VMware.ImageBuilder",
+    "VMware.VimAutomation.License"
+)
+$ProductName="PowerCli"
+$ProductShortName="PowerCli"
+$LoadingActivity="Loading $ProductName"
+$Script:CompletedActivities=0
+$Script:PercentComplete=0
+$Script:Reason=""
+$Script:VMGuest=$null
+$Script:Validate=$null
+$Script:LastBootProp=@()
+$Script:CurrentActivity=""
+$Script:ServerList="ServerList.txt"
+$Script:WorkingPath=($env:USERPROFILE+"\Desktop")
+$Script:ProcessList=($WorkingPath+"\"+$ServerList)
+$Script:totalActivities=$ModuleList.Count+1
+LoadModules
+$PowerCliFriendlyVersion=[VMware.VimAutomation.Sdk.Util10.ProductInfo]::PowerCliFriendlyVersion
+$Host.ui.RawUI.WindowTitle=$PowerCliFriendlyVersion
+Try{
+	$configuration=Get-PowerCliConfiguration -Scope Session
+	If($PromptForCEIP-and$configuration.ParticipateInCEIP-eq$null-and[VMware.VimAutomation.Sdk.Util10Ps.CommonUtil]::InInteractiveMode($Host.UI)){
+		$caption="Participate in VMware Customer Experience Improvement Program (CEIP)"
+		$Message=`
+			"VMware's Customer Experience Improvement Program (`"CEIP`") provides VMware with information "+
+			"that enables VMware to improve its Products and services, to fix problems, and to advise you "+
+			"on how best to deploy and use our Products.  As part of the CEIP, VMware collects technical information "+
+			"about your organization’s use of VMware Products and services on a regular basis in association "+
+			"with your organization’s VMware license key(s).  This information does not personally identify "+
+			"any individual."+
+			"`n`nFor more details: press Ctrl+C to exit this prompt and type `"help about_ceip`" to see the related help article."+
+			"`n`nYou can join or leave the program at any time by executing: Set-PowerCliConfiguration -Scope User -ParticipateInCEIP `$true or `$false."
+		$AcceptLabel="&Join"
+		$choices=(
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList $AcceptLabel,"Participate in the CEIP"),
+			(New-Object -TypeName "System.Management.Automation.Host.ChoiceDescription" -ArgumentList "&Leave","Don`t participate")
+		)
+		$userChoiceIndex = $Host.UI.PromptForChoice($caption, $Message, $choices, 0)
+		$participate = $choices[$userChoiceIndex].Label -eq $AcceptLabel
+		If($participate){
+            [VMware.VimAutomation.Sdk.Interop.V1.CoreServiceFactory]::CoreService.CeipService.JoinCeipProgram();
+        }Else{
+            Set-PowerCliConfiguration -Scope User -ParticipateInCEIP $false -Confirm:$false | Out-Null
+        }
+    }
+}Catch{}
+Write-Progress -Activity $LoadingActivity -Completed
+#Connect vSphere
+$Validate=Connect-VIServer -Server $vSphere -credential $SecureCredentials;Clear
+$LastBootProp=@{Name='LastBootTime';Expression={(Get-Date)-(New-TimeSpan -Seconds $_.Summary.QuickStats.UptimeSeconds)}}
+If($Validate-ne$null){
+    If(Test-Path -Path $LogFile){Remove-Item $LogFile -ErrorAction $ErrorActionPreference}
+    $Reason=("["+$SecureCredentials.UserName+"] was successfully connected to: ["+$vSphere+"}")
+    ("Beginning to process script because "+$Reason+".")|Out-File $LogFile -Append
+    Write-Host ("Beginning to process script because "+$Reason+".") -ForegroundColor Cyan -BackgroundColor DarkBlue
+    If(!(Test-Path -Path ($ProcessList))){
+        (Get-VM).Name|Sort|Out-File ($ProcessList)
+    }
+    #Health Check
+<#
+    Foreach($Server In [System.IO.File]::ReadLines($ProcessList)){
+        $FQDN=$null
+        $Bypass=$true
+        $NetBIOS=$null
+        $VMStatus=$null
+        $HostName=$null
+        $SubDomain="inf"
+        $IPAddress=$null
+        $ServerName=$null
+        $FolderName=$null
+        $DateTime=Get-Date
+        $PowerState="PoweredOff"
+        $IPAddressToString=$null
+        $VMStatus=Get-VM|Where-Object{$_.Name-like($Server)}|Select *
+        If($Server-like"*.*"){
+            $Server=(($Server).Split(("."))[0])
+        }
+        $Sender=($Server+"@utsystem.edu")
+        If($VMStatus-ne$null){
+            $Hostname=$VMStatus.Name
+            $PowerState=$VMStatus.PowerState
+            $FolderName=($VMStatus.Folder).Name
+            If($FolderName-eq"UTD IaaS (Root)"){
+                $Reason=("host VM is not being managed by our team")
+            }Else{
+                If(($PowerState-eq"PoweredOn")-and($PowerState-ne$null)){
+                    $FQDN=(Get-VM $Hostname).Guest.HostName
+                    If($Hostname-like"*.*"){
+                        $NetBIOS=($FQDN.Split(".")[0])
+                        $SubDomain=($FQDN.Split(".")[1])
+                    }Else{
+                        $NetBIOS=$Hostname
+                    }
+                    Try{
+                        $IPAddressToString=([System.Net.Dns]::GetHostByName($FQDN).AddressList).IPAddressToString
+                    }Catch{
+                        $IPAddressToString=(ResolveIPAddress -IP "0.0.0.0" -NetBIOS $FQDN -Environment $SubDomain).IPAddressToString
+                    }
+                    If($IPAddressToString-ne$null){
+                        ForEach($IP In $IPAddressToString){
+                            If(($IP-ne$null)-and($IP.Split(".")[0]-eq"10")-and{($IP.Split(".")[1]-eq"118")-or($IP.Split(".")[1]-eq"126")}){
+                                $ServerName=ResolveIPAddress -IP $IP -FQDN $FQDN
+                                If($ServerName-ne$null){
+                                    $Bypass=$false
+                                }Else{
+                                    $Bypass=$true
+                                }
+                            }Else{
+                                $Reason=("host VM has an invalid IP Address: ["+$IP+"]")
+                            }
+                        }
+                    }Else{
+                        $Reason=("host VM isn`t registered in DNS")
+                    }
+                }Else{
+                    $Reason=("host VM is currently powered off")
+                }
+            }
+        }
+        Write-Host ("Currently working on hostname(VM): '"+$Hostname+"' and is currently: "+$PowerState)
+        If(($PowerState-eq"PoweredOn")-and($Bypass-eq$false)){
+            ("Currently working on hostname(VM): ["+$Hostname+"] and is currently: powered on.")|Out-File $LogFile -Append
+            Try{
+                If(Test-Connection -ComputerName $FQDN -Count 3 -BufferSize 256 -ThrottleLimit 32){
+                    (“`tTesting connection to $ServerName is successful”)|Out-File $LogFile -Append
+                }Else{
+                    $EndTime=Get-Date
+                    "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" not responding") -Body ($ServerName+" not responding, waiting 10 seconds and will try again.") -SmtpServer $MailServer
+                    "Waiting 10 seconds"
+                    Start-Sleep 10
+                    If(!(Test-Connection -ComputerName $FQDN -Count 3 -BufferSize 256 -ThrottleLimit 32)){
+                        $EndTime=Get-Date
+                        "Connection Failed `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                        (Get-VM -Name $Hostname).ExtensionData.ResetVM() 
+#                        Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ("Server: '"+$ServerName+"' crashed!") -Body ($ServerName+" must have crashed and was reset.") -SmtpServer $MailServer
+                        Start-Sleep 30
+                    }Else{
+                        $EndTime=Get-Date
+                        “Successful `t`t"+$DateTime.DateTime+"`t`t"+($EndTime–$DateTime).TotalSeconds+" seconds"|Out-File $LogFile -Append
+#                        Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ($ServerName+" is responding") -Body ($ServerName+" is responding again and was not reset.") -SmtpServer $MailServer
+                    }
+                }
+            }Catch{}
+        }Else{
+            ("Bypassing ["+$Server+"] because "+$Reason+".")|Out-File $LogFile -Append
+        }
+        ("----------------------------------------------------------------------------------------------------")|Out-File $LogFile -Append
+    }
+#>
+    ForEach($VMGuest In [System.IO.File]::ReadLines($ProcessList)){
+        $VMLabel=Get-View -Filter @{"Name"="($VMGuest)"} -ViewType VirtualMachine -Property Name, Summary.QuickStats.UptimeSeconds|Select Name,$LastBootProp
+        ForEach($VM In $VMLabel){
+            $FQDN=""
+            $Reset=$false
+            $ByPass=$false
+            $VMTools=$null
+            $VMStatus=$null
+            $IPAddressToString=$null
+            If($VM.Name-eq$VMGuest){
+                Write-Host ("Beginning to process: "+$VM.Name)
+                $FQDN=((Get-VM $VMGuest).Guest.HostName).ToLower()
+                If(($FQDN-eq$null)-or($FQDN-eq"")){
+                    $FQDN=$VMGuest
+                }
+                Try{
+                    $IPAddressToString=([System.Net.Dns]::GetHostByName($FQDN).AddressList).IPAddressToString
+                    ($VM.Name+" is returning: ["+$FQDN+"] as the Fully Qualified Domain Name.")|Out-File $LogFile -Append
+                }Catch{
+                    $Reset=$true
+                    Switch($FQDN){
+                        {($_-like"*."+$Domain)}{$Reset=$false;Break}
+                        {($_-like"*.edu")}{$Reset=$false;Break}
+                    }
+                    If($Reset-eq$true){
+                        $FQDN=$VM.Name
+                    }
+                    ("`t["+$FQDN+"] failed to return DNS information using the Hostname.")|Out-File $LogFile -Append
+                    $Error.Clear()
+                }
+                ("Guest system: ["+$FQDN+"] was last rebooted on: ["+$VM.LastBootTime+"].")|Out-File $LogFile -Append
+                $VMStatus=Get-VM|Where-Object{$_.Name-like($VMGuest)}|Select *
+                $OSState=$VMStatus.Guest.State
+                $IPAddress=$VMStatus.Guest.IPAddress
+                $OSFullName=$VMStatus.Guest.OSFullName
+                ("The current state of: ["+$FQDN+"] is:")|Out-File $LogFile -Append
+                ("`tHost (ESXi):`t`t"+$VMStatus.VMHost)|Out-File $LogFile -Append
+                ("`tPower state:`t`t"+$VMStatus.PowerState)|Out-File $LogFile -Append
+                ("`tOperating System:`t"+$OSFullName)|Out-File $LogFile -Append
+                ("`tOS Status:`t`t"+$OSState)|Out-File $LogFile -Append
+                ("`tIP Address:`t`t"+$IPAddress)|Out-File $LogFile -Append
+                ("`tCPU count:`t`t"+$VMStatus.NumCpu)|Out-File $LogFile -Append
+                ("`tCores Per Socket:`t"+$VMStatus.CoresPerSocket)|Out-File $LogFile -Append
+                ("`tMemory in MB:`t`t"+$VMStatus.MemoryMB)|Out-File $LogFile -Append
+                ("`tFolder:`t`t`t"+$VMStatus.Folder)|Out-File $LogFile -Append
+                ("`tSpace used in GB:`t"+$VMStatus.UsedSpaceGB)|Out-File $LogFile -Append
+                ("`tProvisioned in GB:`t"+$VMStatus.ProvisionedSpaceGB)|Out-File $LogFile -Append
+                If($ExcludedFolders-like("*"+$VMStatus.Folder.Name+"*")){
+                    ("***`tBypassing ["+$FQDN+"] because it's in the excluded folder: ["+$VMStatus.Folder+"].")|Out-File $LogFile -Append
+                    $ByPass=$true
+                }
+            }
+            If(($ByPass-eq$false)-and($FQDN-ne"")){
+                Write-Host ("`tVerifying that ["+$FQDN+"] is powered on and VMTools are running.")
+                $VMTools=Get-View -ViewType VirtualMachine -Filter @{'Name'=$VMGuest}|Select Name,
+                    @{N="HW Version";E={$_.Config.version}},
+                    @{N='VMware Tools Status';E={$_.Guest.ToolsStatus}},
+                    @{N="VMware Tools version";E={$_.Config.Tools.ToolsVersion}}
+                ("`Hardware version:`t"+$VMTools.'HW Version')|Out-File $LogFile -Append
+                ("`tvmtools version:`t"+$VMTools.'VMware Tools version')|Out-File $LogFile -Append
+                ("`tvmtools status:`t"+$VMTools.'VMware Tools Status')|Out-File $LogFile -Append
+            }
+        }
+        ("----------------------------------------------------------------------------------------------------")|Out-File $LogFile -Append
+    }
+    $Message=("The attachment: ["+$ServerList+"] is a list of systems that were processed for being reset.  The second attachment are the results from each VM processed from the ["+$ServerList+"] file.")
+#    Send-MailMessage -From "<$($Sender)>" -To "GRP-SIS_SysAdmin <$($SendTo)>" -Subject ("Summary of system reset of non-responding VMs") -Body ($Message) -Attachments ($ProcessList,$LogFile) -SmtpServer $MailServer
+}Else{
+    $Reason=("["+$SecureCredentials.UserName+"] was unable to connect to: ["+$vSphere+"}")
+    ("Failed to beginning process script because "+$Reason+".")|Out-File $LogFile -Append
+    Write-Host ("Failed to beginning process script because "+$Reason+".") -ForegroundColor Yellow -BackgroundColor DarkRed
+}
+Rename-Item -Path ($ProcessList) -NewName "ProcessedList.txt" -Force
+#Disconnect-VIServer -Server $global:DefaultVIServers -Force
+Set-Location ($env:SystemRoot+"\System32")
\ No newline at end of file
-- 
2.20.1.windows.1

